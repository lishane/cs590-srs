{"writePackedDouble": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writePackedDouble", "replacementComments": "/**\n* Write a list of packed proto \"double\" type field values.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writePackedDouble(long,double[])", "method": "writePackedDouble(long,double[])"}, "onGetInstantAppResolveInfo": {"methodClass": "android.app.InstantAppResolverService", "methodName": "onGetInstantAppResolveInfo", "replacementComments": "/**\n* Called to retrieve resolve info for instant applications immediately.\n*\n* @param digestPrefix The hash prefix of the instant app's domain.\n* @deprecated should implement {@link #onGetInstantAppResolveInfo(Intent, int[], String,\n* InstantAppResolutionCallback)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "onGetInstantAppResolveInfo(Intent, int[], String,  InstantAppResolutionCallback)", "methodReturn": "void", "isValid": true, "cleanReplacement": "onGetInstantAppResolveInfo(Intent, int[], String,  InstantAppResolutionCallback)", "fullMethod": "void onGetInstantAppResolveInfo(int[],String,InstantAppResolutionCallback)", "method": "onGetInstantAppResolveInfo(int[],String,InstantAppResolutionCallback)"}, "iterator": {"methodClass": "androidx.core.app.TaskStackBuilder", "methodName": "iterator", "replacementComments": "/**\n* @deprecated Use editIntentAt instead\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "editIntentAt", "methodReturn": "Iterator<Intent>", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "Iterator<Intent> iterator()", "method": "iterator()"}, "getUidUdpTxPackets": {"methodClass": "android.net.TrafficStats", "methodName": "getUidUdpTxPackets", "replacementComments": "/**\n* @deprecated Starting in {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2},\n* transport layer statistics are no longer available, and will\n* always return {@link #UNSUPPORTED}.\n* @see #getUidTxPackets(int)\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getUidTxPackets(int)", "methodReturn": "long", "isValid": true, "cleanReplacement": "getUidTxPackets(int)", "fullMethod": "long getUidUdpTxPackets(int)", "method": "getUidUdpTxPackets(int)"}, "writeRepeatedObject": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writeRepeatedObject", "replacementComments": "/**\n* Write an object that has already been flattend.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writeRepeatedObject(long,byte[])", "method": "writeRepeatedObject(long,byte[])"}, "hasText": {"methodClass": "android.content.ClipboardManager", "methodName": "hasText", "replacementComments": "/**\n* @deprecated Use {@link #hasPrimaryClip()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "hasPrimaryClip()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "hasPrimaryClip()", "fullMethod": "boolean hasText()", "method": "hasText()"}, "getItemId": {"methodClass": "androidx.legacy.app.FragmentPagerAdapter", "methodName": "getItemId", "replacementComments": "/**\n* Return a unique identifier for the item at the given position.\n*\n* <p>The default implementation returns the given position.\n* Subclasses should override this method if the positions of items can change.</p>\n*\n* @param position Position within this adapter\n* @return Unique identifier for the item at position\n*\n* @deprecated Use {@link androidx.fragment.app.FragmentPagerAdapter} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "androidx.fragment.app.FragmentPagerAdapter", "methodReturn": "long", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "long getItemId(int)", "method": "getItemId(int)"}, "buildDrawingCache": {"methodClass": "android.view.View", "methodName": "buildDrawingCache", "replacementComments": "/**\n* <p>Forces the drawing cache to be built if the drawing cache is invalid.</p>\n*\n* <p>If you call {@link #buildDrawingCache()} manually without calling\n* {@link #setDrawingCacheEnabled(boolean) setDrawingCacheEnabled(true)}, you\n* should cleanup the cache by calling {@link #destroyDrawingCache()} afterwards.</p>\n*\n* <p>Note about auto scaling in compatibility mode: When auto scaling is not enabled,\n* this method will create a bitmap of the same size as this view. Because this bitmap\n* will be drawn scaled by the parent ViewGroup, the result on screen might show\n* scaling artifacts. To avoid such artifacts, you should call this method by setting\n* the auto scaling to true. Doing so, however, will generate a bitmap of a different\n* size than the view. This implies that your application must be able to handle this\n* size.</p>\n*\n* <p>You should avoid calling this method when hardware acceleration is enabled. If\n* you do not need the drawing cache bitmap, calling this method will increase memory\n* usage and cause the view to be rendered in software once, thus negatively impacting\n* performance.</p>\n*\n* @see #getDrawingCache()\n* @see #destroyDrawingCache()\n*\n* @deprecated The view drawing cache was largely made obsolete with the introduction of\n* hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache\n* layers are largely unnecessary and can easily result in a net loss in performance due to the\n* cost of creating and updating the layer. In the rare cases where caching layers are useful,\n* such as for alpha animations, {@link #setLayerType(int, Paint)} handles this with hardware\n* rendering. For software-rendered snapshots of a small part of the View hierarchy or\n* individual Views it is recommended to create a {@link Canvas} from either a {@link Bitmap} or\n* {@link android.graphics.Picture} and call {@link #draw(Canvas)} on the View. However these\n* software-rendered usages are discouraged and have compatibility issues with hardware-only\n* rendering features such as {@link android.graphics.Bitmap.Config#HARDWARE Config.HARDWARE}\n* bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback\n* reports or unit testing the {@link PixelCopy} API is recommended.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setLayerType(int, Paint)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setLayerType(int, Paint)", "fullMethod": "void buildDrawingCache(boolean)", "method": "buildDrawingCache(boolean)"}, "getThreadStatsTag": {"methodClass": "androidx.core.net.TrafficStatsCompat", "methodName": "getThreadStatsTag", "replacementComments": "/**\n* Get the active tag used when accounting {@link Socket} traffic originating\n* from the current thread. Only one active tag per thread is supported.\n* {@link #tagSocket(Socket)}.\n*\n* @deprecated Use {@link TrafficStats#getThreadStatsTag()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "TrafficStats#getThreadStatsTag()", "methodReturn": "int", "isValid": true, "cleanReplacement": "TrafficStats#getThreadStatsTag()", "fullMethod": "int getThreadStatsTag()", "method": "getThreadStatsTag()"}, "getLayerType": {"methodClass": "androidx.core.view.ViewCompat", "methodName": "getLayerType", "replacementComments": "/**\n* Indicates what type of layer is currently associated with this view. By default\n* a view does not have a layer, and the layer type is {@link View#LAYER_TYPE_NONE}.\n* Refer to the documentation of\n* {@link #setLayerType(android.view.View, int, android.graphics.Paint)}\n* for more information on the different types of layers.\n*\n* @param view The view to fetch the layer type from\n* @return {@link View#LAYER_TYPE_NONE}, {@link View#LAYER_TYPE_SOFTWARE} or\n* {@link View#LAYER_TYPE_HARDWARE}\n*\n* @see #setLayerType(android.view.View, int, android.graphics.Paint)\n* @see View#LAYER_TYPE_NONE\n* @see View#LAYER_TYPE_SOFTWARE\n* @see View#LAYER_TYPE_HARDWARE\n*\n* @deprecated Use {@link View#getLayerType()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "View#getLayerType()", "methodReturn": "int", "isValid": true, "cleanReplacement": "getLayerType()", "fullMethod": "int getLayerType(View)", "method": "getLayerType(View)"}, "setParameter": {"methodClass": "java.security.Signature", "methodName": "setParameter", "replacementComments": "/**\n* Sets the specified algorithm parameter to the specified value.\n* This method supplies a general-purpose mechanism through\n* which it is possible to set the various parameters of this object.\n* A parameter may be any settable parameter for the algorithm, such as\n* a parameter size, or a source of random bits for signature generation\n* (if appropriate), or an indication of whether or not to perform\n* a specific but optional computation. A uniform algorithm-specific\n* naming scheme for each parameter is desirable but left unspecified\n* at this time.\n*\n* @param param the string identifier of the parameter.\n* @param value the parameter value.\n*\n* @exception InvalidParameterException if {@code param} is an\n* invalid parameter for this signature algorithm engine,\n* the parameter is already set\n* and cannot be set again, a security exception occurs, and so on.\n*\n* @see #getParameter\n*\n* @deprecated Use\n* {@link #setParameter(java.security.spec.AlgorithmParameterSpec)\n* setParameter}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setParameter(java.security.spec.AlgorithmParameterSpec)  setParameter", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void setParameter(String,Object)", "method": "setParameter(String,Object)"}, "enableRowScaling": {"methodClass": "androidx.leanback.app.RowsSupportFragment", "methodName": "enableRowScaling", "replacementComments": "/**\n* @deprecated use {@link BrowseSupportFragment#enableRowScaling(boolean)} instead.\n*\n* @param enable true to enable row scaling\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "BrowseSupportFragment#enableRowScaling(boolean)", "methodReturn": "void", "isValid": true, "cleanReplacement": "BrowseSupportFragment#enableRowScaling(boolean)", "fullMethod": "void enableRowScaling(boolean)", "method": "enableRowScaling(boolean)"}, "setUserVisibleHint": {"methodClass": "androidx.legacy.app.FragmentCompat", "methodName": "setUserVisibleHint", "replacementComments": "/**\n* Call {@link Fragment#setUserVisibleHint(boolean) setUserVisibleHint(boolean)}\n* if running on an appropriate version of the platform.\n*\n* @deprecated Use {@link androidx.fragment.app.Fragment} instead of the framework\n* {@link Fragment}.\n*/\n", "isClassDeprecated": true, "dirtyReplacement": "androidx.fragment.app.Fragment", "methodReturn": "void", "isValid": true, "cleanReplacement": "androidx.fragment.app.Fragment", "fullMethod": "void setUserVisibleHint(Fragment,boolean)", "method": "setUserVisibleHint(Fragment,boolean)"}, "classDepth": {"methodClass": "java.lang.SecurityManager", "methodName": "classDepth", "replacementComments": "/**\n* @deprecated Use {@link #checkPermission} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "checkPermission", "methodReturn": "int", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "int classDepth(String)", "method": "classDepth(String)"}, "setOverScrollMode": {"methodClass": "androidx.core.view.ViewCompat", "methodName": "setOverScrollMode", "replacementComments": "/**\n* Set the over-scroll mode for this view. Valid over-scroll modes are\n* {@link #OVER_SCROLL_ALWAYS} (default), {@link #OVER_SCROLL_IF_CONTENT_SCROLLS}\n* (allow over-scrolling only if the view content is larger than the container),\n* or {@link #OVER_SCROLL_NEVER}.\n*\n* Setting the over-scroll mode of a view will have an effect only if the\n* view is capable of scrolling.\n*\n* @param v The View against which to invoke the method.\n* @param overScrollMode The new over-scroll mode for this view.\n* @deprecated Call {@link View#setOverScrollMode(int)} directly. This method will be\n* removed in a future release.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "View#setOverScrollMode(int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setOverScrollMode(int)", "fullMethod": "void setOverScrollMode(View,int)", "method": "setOverScrollMode(View,int)"}, "isVolteEnabledByPlatform": {"methodClass": "com.android.ims.ImsManager", "methodName": "isVolteEnabledByPlatform", "replacementComments": "/**\n* Returns a platform configuration for VoLTE which may override the user setting.\n* @deprecated Does not support MSIM devices. Please use\n* {@link #isVolteEnabledByPlatform()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "isVolteEnabledByPlatform()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "isVolteEnabledByPlatform()", "fullMethod": "boolean isVolteEnabledByPlatform(Context)", "method": "isVolteEnabledByPlatform(Context)"}, "computeScrollOffset": {"methodClass": "androidx.core.widget.ScrollerCompat", "methodName": "computeScrollOffset", "replacementComments": "/**\n* Call this when you want to know the new location.  If it returns true,\n* the animation is not yet finished.  loc will be altered to provide the\n* new location.\n*\n* @deprecated Use {@link OverScroller#computeScrollOffset()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "OverScroller#computeScrollOffset()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "OverScroller#computeScrollOffset()", "fullMethod": "boolean computeScrollOffset()", "method": "computeScrollOffset()"}, "isNonTtyOrTtyOnVolteEnabled": {"methodClass": "com.android.ims.ImsManager", "methodName": "isNonTtyOrTtyOnVolteEnabled", "replacementComments": "/**\n* Indicates whether the call is non-TTY or if TTY - whether TTY on VoLTE is\n* supported.\n* @deprecated Does not support MSIM devices. Please use\n* {@link #isNonTtyOrTtyOnVolteEnabled()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "isNonTtyOrTtyOnVolteEnabled()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "isNonTtyOrTtyOnVolteEnabled()", "fullMethod": "boolean isNonTtyOrTtyOnVolteEnabled(Context)", "method": "isNonTtyOrTtyOnVolteEnabled(Context)"}, "send": {"methodClass": "java.net.MulticastSocket", "methodName": "send", "replacementComments": "/**\n* Sends a datagram packet to the destination, with a TTL (time-\n* to-live) other than the default for the socket.  This method\n* need only be used in instances where a particular TTL is desired;\n* otherwise it is preferable to set a TTL once on the socket, and\n* use that default TTL for all packets.  This method does <B>not\n* </B> alter the default TTL for the socket. Its behavior may be\n* affected by {@code setInterface}.\n*\n* <p>If there is a security manager, this method first performs some\n* security checks. First, if {@code p.getAddress().isMulticastAddress()}\n* is true, this method calls the\n* security manager's {@code checkMulticast} method\n* with {@code p.getAddress()} and {@code ttl} as its arguments.\n* If the evaluation of that expression is false,\n* this method instead calls the security manager's\n* {@code checkConnect} method with arguments\n* {@code p.getAddress().getHostAddress()} and\n* {@code p.getPort()}. Each call to a security manager method\n* could result in a SecurityException if the operation is not allowed.\n*\n* @param p is the packet to be sent. The packet should contain\n* the destination multicast ip address and the data to be sent.\n* One does not need to be the member of the group to send\n* packets to a destination multicast address.\n* @param ttl optional time to live for multicast packet.\n* default ttl is 1.\n*\n* @exception IOException is raised if an error occurs i.e\n* error while setting ttl.\n* @exception  SecurityException  if a security manager exists and its\n* {@code checkMulticast} or {@code checkConnect}\n* method doesn't allow the send.\n*\n* @deprecated Use the following code or its equivalent instead:\n* ......\n* int ttl = mcastSocket.getTimeToLive();\n* mcastSocket.setTimeToLive(newttl);\n* mcastSocket.send(p);\n* mcastSocket.setTimeToLive(ttl);\n* ......\n*\n* @see DatagramSocket#send\n* @see DatagramSocket#receive\n* @see SecurityManager#checkMulticast(java.net.InetAddress, byte)\n* @see SecurityManager#checkConnect\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "the following code or its equivalent", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void send(DatagramPacket,byte)", "method": "send(DatagramPacket,byte)"}, "getLocalizedOutputStream": {"methodClass": "java.lang.Runtime", "methodName": "getLocalizedOutputStream", "replacementComments": "/**\n* Creates a localized version of an output stream. This method\n* takes an <code>OutputStream</code> and returns an\n* <code>OutputStream</code> equivalent to the argument in all respects\n* except that it is localized: as Unicode characters are written to\n* the stream, they are automatically converted to the local\n* character set.\n* <p>\n* If the argument is already a localized stream, it may be returned\n* as the result.\n*\n* @deprecated As of JDK&nbsp;1.1, the preferred way to translate a\n* Unicode character stream into a byte stream in the local encoding is via\n* the <code>OutputStreamWriter</code>, <code>BufferedWriter</code>, and\n* <code>PrintWriter</code> classes.\n*\n* @param      out OutputStream to localize\n* @return     a localized output stream\n* @see        java.io.OutputStream\n* @see        java.io.BufferedWriter#BufferedWriter(java.io.Writer)\n* @see        java.io.OutputStreamWriter#OutputStreamWriter(java.io.OutputStream)\n* @see        java.io.PrintWriter#PrintWriter(java.io.OutputStream)\n*/\n", "isClassDeprecated": true, "dirtyReplacement": "java.io.OutputStream", "methodReturn": "OutputStream", "isValid": true, "cleanReplacement": "java.io.OutputStream", "fullMethod": "OutputStream getLocalizedOutputStream(OutputStream)", "method": "getLocalizedOutputStream(OutputStream)"}, "getParcelableData": {"methodClass": "androidx.core.view.accessibility.AccessibilityRecordCompat", "methodName": "getParcelableData", "replacementComments": "/**\n* Gets the {@link Parcelable} data.\n*\n* @return The parcelable data.\n*\n* @deprecated Use {@link AccessibilityRecord#getParcelableData()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityRecord#getParcelableData()", "methodReturn": "Parcelable", "isValid": true, "cleanReplacement": "AccessibilityRecord#getParcelableData()", "fullMethod": "Parcelable getParcelableData()", "method": "getParcelableData()"}, "getMessage": {"methodClass": "android.service.voice.VoiceInteractionSession.CompleteVoiceRequest", "methodName": "getMessage", "replacementComments": "/**\n* Return the message informing the user of the completion, as per\n* {@link android.app.VoiceInteractor.CompleteVoiceRequest\n* VoiceInteractor.CompleteVoiceRequest}.\n* @deprecated Prefer {@link #getVoicePrompt()} which allows a separate visual message.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getVoicePrompt()", "methodReturn": "CharSequence", "isValid": true, "cleanReplacement": "getVoicePrompt()", "fullMethod": "CharSequence getMessage()", "method": "getMessage()"}, "recycle": {"methodClass": "androidx.core.view.accessibility.AccessibilityRecordCompat", "methodName": "recycle", "replacementComments": "/**\n* Return an instance back to be reused.\n* <p>\n* <strong>Note:</strong> You must not touch the object after calling this\n* function.\n* </p>\n*\n* @throws IllegalStateException If the record is already recycled.\n*\n* @deprecated Use {@link AccessibilityRecord#recycle()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityRecord#recycle()", "methodReturn": "void", "isValid": true, "cleanReplacement": "AccessibilityRecord#recycle()", "fullMethod": "void recycle()", "method": "recycle()"}, "allowThreadSuspension": {"methodClass": "java.lang.ThreadGroup", "methodName": "allowThreadSuspension", "replacementComments": "/**\n* Used by VM to control lowmem implicit suspension.\n*\n* @param b boolean to allow or disallow suspension\n* @return true on success\n* @since   JDK1.1\n* @deprecated The definition of this call depends on {@link #suspend},\n* which is deprecated.  Further, the behavior of this call\n* was never specified.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "suspend", "methodReturn": "boolean", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "boolean allowThreadSuspension(boolean)", "method": "allowThreadSuspension(boolean)"}, "setIntent": {"methodClass": "android.view.textclassifier.TextClassification.Builder", "methodName": "setIntent", "replacementComments": "/**\n* Sets the intent for the <i>primary</i> action that may be fired to act on the classified\n* text.\n*\n* <p><strong>NOTE: </strong>This field is not parcelled.\n*\n* @deprecated Use {@link #addAction(RemoteAction)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "addAction(RemoteAction)", "methodReturn": "Builder", "isValid": true, "cleanReplacement": "addAction(RemoteAction)", "fullMethod": "Builder setIntent(Intent)", "method": "setIntent(Intent)"}, "formatNanpNumber": {"methodClass": "android.telephony.PhoneNumberUtils", "methodName": "formatNanpNumber", "replacementComments": "/**\n* Formats a phone number in-place using the NANP formatting rules. Numbers will be formatted\n* as:\n*\n* <p><code>\n* xxxxx\n* xxx-xxxx\n* xxx-xxx-xxxx\n* 1-xxx-xxx-xxxx\n* +1-xxx-xxx-xxxx\n* </code></p>\n*\n* @param text the number to be formatted, will be modified with the formatting\n*\n* @deprecated Use link #formatNumber(String phoneNumber, String defaultCountryIso) instead\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "link #formatNumber(String phoneNumber, String defaultCountryIso)", "methodReturn": "void", "isValid": true, "cleanReplacement": "formatNumber(String phoneNumber, String defaultCountryIso)", "fullMethod": "void formatNanpNumber(Editable)", "method": "formatNanpNumber(Editable)"}, "getSupportedRefreshRates": {"methodClass": "android.view.Display", "methodName": "getSupportedRefreshRates", "replacementComments": "/**\n* Get the supported refresh rates of this display in frames per second.\n* <p>\n* This method only returns refresh rates for the display's default modes. For more options, use\n* {@link #getSupportedModes()}.\n*\n* @deprecated use {@link #getSupportedModes()} instead\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getSupportedModes()", "methodReturn": "float[]", "isValid": true, "cleanReplacement": "getSupportedModes()", "fullMethod": "float[] getSupportedRefreshRates()", "method": "getSupportedRefreshRates()"}, "getNetworkInfo": {"methodClass": "android.net.ConnectivityManager", "methodName": "getNetworkInfo", "replacementComments": "/**\n* Returns connection status information about a particular\n* network type.\n*\n* @param networkType integer specifying which networkType in\n* which you're interested.\n* @return a {@link NetworkInfo} object for the requested\n* network type or {@code null} if the type is not\n* supported by the device. If {@code networkType} is\n* TYPE_VPN and a VPN is active for the calling app,\n* then this method will try to return one of the\n* underlying networks for the VPN or null if the\n* VPN agent didn't specify any.\n*\n* @deprecated This method does not support multiple connected networks\n* of the same type. Use {@link #getAllNetworks} and\n* {@link #getNetworkInfo(android.net.Network)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getAllNetworks", "methodReturn": "NetworkInfo", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "NetworkInfo getNetworkInfo(int)", "method": "getNetworkInfo(int)"}, "setChildrenDrawingOrderEnabled": {"methodClass": "androidx.core.view.ViewCompat", "methodName": "setChildrenDrawingOrderEnabled", "replacementComments": "/**\n* Tells the ViewGroup whether to draw its children in the order defined by the method\n* {@code ViewGroup.getChildDrawingOrder(int, int)}.\n*\n* @param enabled true if the order of the children when drawing is determined by\n* {@link ViewGroup#getChildDrawingOrder(int, int)}, false otherwise\n*\n* <p>Prior to API 7 this will have no effect.</p>\n*\n* @deprecated Use {@link ViewGroup#setChildrenDrawingOrderEnabled(boolean)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "ViewGroup#setChildrenDrawingOrderEnabled(boolean)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setChildrenDrawingOrderEnabled(boolean)", "fullMethod": "void setChildrenDrawingOrderEnabled(ViewGroup,boolean)", "method": "setChildrenDrawingOrderEnabled(ViewGroup,boolean)"}, "willNotCacheDrawing": {"methodClass": "android.view.View", "methodName": "willNotCacheDrawing", "replacementComments": "/**\n* Returns whether or not this View can cache its drawing or not.\n*\n* @return true if this view does not cache its drawing, false otherwise\n*\n* @deprecated The view drawing cache was largely made obsolete with the introduction of\n* hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache\n* layers are largely unnecessary and can easily result in a net loss in performance due to the\n* cost of creating and updating the layer. In the rare cases where caching layers are useful,\n* such as for alpha animations, {@link #setLayerType(int, Paint)} handles this with hardware\n* rendering. For software-rendered snapshots of a small part of the View hierarchy or\n* individual Views it is recommended to create a {@link Canvas} from either a {@link Bitmap} or\n* {@link android.graphics.Picture} and call {@link #draw(Canvas)} on the View. However these\n* software-rendered usages are discouraged and have compatibility issues with hardware-only\n* rendering features such as {@link android.graphics.Bitmap.Config#HARDWARE Config.HARDWARE}\n* bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback\n* reports or unit testing the {@link PixelCopy} API is recommended.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setLayerType(int, Paint)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "setLayerType(int, Paint)", "fullMethod": "boolean willNotCacheDrawing()", "method": "willNotCacheDrawing()"}, "onPasswordExpiring": {"methodClass": "android.app.admin.DeviceAdminReceiver", "methodName": "onPasswordExpiring", "replacementComments": "/**\n* Called periodically when the device or profile challenge password is about to expire\n* or has expired.  It will typically be called at these times: on device boot, once per day\n* before the password expires, and at the time when the password expires.\n*\n* <p>If the password is not updated by the user, this method will continue to be called\n* once per day until the password is changed or the device admin disables password expiration.\n*\n* <p>The admin will typically post a notification requesting the user to change their password\n* in response to this call. The actual password expiration time can be obtained by calling\n* {@link DevicePolicyManager#getPasswordExpiration(ComponentName) }\n*\n* <p>The admin should be sure to take down any notifications it posted in response to this call\n* when it receives {@link DeviceAdminReceiver#onPasswordChanged(Context, Intent) }.\n*\n* @param context The running context as per {@link #onReceive}.\n* @param intent The received intent as per {@link #onReceive}.\n*\n* @deprecated From {@link android.os.Build.VERSION_CODES#O}, use\n* {@link #onPasswordExpiring(Context, Intent, UserHandle)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "onPasswordExpiring(Context, Intent, UserHandle)", "methodReturn": "void", "isValid": true, "cleanReplacement": "onPasswordExpiring(Context, Intent, UserHandle)", "fullMethod": "void onPasswordExpiring(Context,Intent)", "method": "onPasswordExpiring(Context,Intent)"}, "setExpandedViewHolder": {"methodClass": "androidx.leanback.widget.GuidedActionsStylist", "methodName": "setExpandedViewHolder", "replacementComments": "/**\n* Expands or collapse the sub actions list view with transition animation\n* @param avh When not null, fill sub actions list of this ViewHolder into sub actions list and\n* hide the other items in main list.  When null, collapse the sub actions list.\n* @deprecated use {@link #expandAction(GuidedAction, boolean)} and\n* {@link #collapseAction(boolean)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "expandAction(GuidedAction, boolean)", "methodReturn": "void", "isValid": true, "cleanReplacement": "expandAction(GuidedAction, boolean)", "fullMethod": "void setExpandedViewHolder(ViewHolder)", "method": "setExpandedViewHolder(ViewHolder)"}, "getContainerId": {"methodClass": "com.android.setupwizardlib.TemplateLayout", "methodName": "getContainerId", "replacementComments": "/**\n* @return ID of the default container for this layout. This will be used to find the container\n* ViewGroup, which all children views of this layout will be placed in.\n* @deprecated Override {@link #findContainer(int)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "findContainer(int)", "methodReturn": "int", "isValid": true, "cleanReplacement": "findContainer(int)", "fullMethod": "int getContainerId()", "method": "getContainerId()"}, "setDefaults": {"methodClass": "android.app.Notification.Builder", "methodName": "setDefaults", "replacementComments": "/**\n* Set which notification properties will be inherited from system defaults.\n* <p>\n* The value should be one or more of the following fields combined with\n* bitwise-or:\n* {@link #DEFAULT_SOUND}, {@link #DEFAULT_VIBRATE}, {@link #DEFAULT_LIGHTS}.\n* <p>\n* For all default values, use {@link #DEFAULT_ALL}.\n*\n* @deprecated use {@link NotificationChannel#enableVibration(boolean)} and\n* {@link NotificationChannel#enableLights(boolean)} and\n* {@link NotificationChannel#setSound(Uri, AudioAttributes)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "NotificationChannel#enableVibration(boolean)", "methodReturn": "Builder", "isValid": true, "cleanReplacement": "enableVibration(boolean)", "fullMethod": "Builder setDefaults(int)", "method": "setDefaults(int)"}, "combineMeasuredStates": {"methodClass": "androidx.core.view.ViewCompat", "methodName": "combineMeasuredStates", "replacementComments": "/**\n* Merge two states as returned by {@link #getMeasuredState(View)}.\n* @param curState The current state as returned from a view or the result\n* of combining multiple views.\n* @param newState The new view state to combine.\n* @return Returns a new integer reflecting the combination of the two\n* states.\n*\n* @deprecated Use {@link View#combineMeasuredStates(int, int)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "View#combineMeasuredStates(int, int)", "methodReturn": "int", "isValid": true, "cleanReplacement": "combineMeasuredStates(int, int)", "fullMethod": "int combineMeasuredStates(int,int)", "method": "combineMeasuredStates(int,int)"}, "removeAction": {"methodClass": "android.view.accessibility.AccessibilityNodeInfo", "methodName": "removeAction", "replacementComments": "/**\n* Removes an action that can be performed on the node. If the action was\n* not already added to the node, calling this method has no effect.\n* <p>\n* <strong>Note:</strong> Cannot be called from an\n* {@link android.accessibilityservice.AccessibilityService}.\n* This class is made immutable before being delivered to an AccessibilityService.\n* </p>\n*\n* @param action The action to be removed.\n*\n* @throws IllegalStateException If called from an AccessibilityService.\n* @deprecated Use {@link #removeAction(AccessibilityAction)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "removeAction(AccessibilityAction)", "methodReturn": "void", "isValid": true, "cleanReplacement": "removeAction(AccessibilityAction)", "fullMethod": "void removeAction(int)", "method": "removeAction(int)"}, "getInCheck": {"methodClass": "java.lang.SecurityManager", "methodName": "getInCheck", "replacementComments": "/**\n* @deprecated Use {@link #checkPermission} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "checkPermission", "methodReturn": "boolean", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "boolean getInCheck()", "method": "getInCheck()"}, "isString": {"methodClass": "android.database.AbstractWindowedCursor", "methodName": "isString", "replacementComments": "/**\n* @deprecated Use {@link #getType}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getType", "methodReturn": "boolean", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "boolean isString(int)", "method": "isString(int)"}, "getContextHubHandles": {"methodClass": "android.hardware.location.ContextHubManager", "methodName": "getContextHubHandles", "replacementComments": "/**\n* Get a handle to all the context hubs in the system\n*\n* @return array of context hub handles\n*\n* @deprecated Use {@link #getContextHubs()} instead. The use of handles are deprecated in the\n* new APIs.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getContextHubs()", "methodReturn": "int[]", "isValid": true, "cleanReplacement": "getContextHubs()", "fullMethod": "int[] getContextHubHandles()", "method": "getContextHubHandles()"}, "endObject": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "endObject", "replacementComments": "/**\n* End a child object. Pass in the token from the correspoinding startObject call.\n*\n* @deprecated Use #end() instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "end()", "methodReturn": "void", "isValid": true, "cleanReplacement": "end()", "fullMethod": "void endObject(long)", "method": "endObject(long)"}, "setDefaultRequestProperty": {"methodClass": "java.net.URLConnection", "methodName": "setDefaultRequestProperty", "replacementComments": "/**\n* Sets the default value of a general request property. When a\n* {@code URLConnection} is created, it is initialized with\n* these properties.\n*\n* @param   key     the keyword by which the request is known\n* (e.g., \"{@code Accept}\").\n* @param   value   the value associated with the key.\n*\n* @see java.net.URLConnection#setRequestProperty(java.lang.String,java.lang.String)\n*\n* @deprecated The instance specific setRequestProperty method\n* should be used after an appropriate instance of URLConnection\n* is obtained. Invoking this method will have no effect.\n*\n* @see #getDefaultRequestProperty(java.lang.String)\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getDefaultRequestProperty(java.lang.String)", "methodReturn": "void", "isValid": true, "cleanReplacement": "getDefaultRequestProperty(java.lang.String)", "fullMethod": "void setDefaultRequestProperty(String,String)", "method": "setDefaultRequestProperty(String,String)"}, "getMeasuredWidthAndState": {"methodClass": "androidx.core.view.ViewCompat", "methodName": "getMeasuredWidthAndState", "replacementComments": "/**\n* Return the full width measurement information for this view as computed\n* by the most recent call to {@link android.view.View#measure(int, int)}.\n* This result is a bit mask as defined by {@link #MEASURED_SIZE_MASK} and\n* {@link #MEASURED_STATE_TOO_SMALL}.\n* This should be used during measurement and layout calculations only. Use\n* {@link android.view.View#getWidth()} to see how wide a view is after layout.\n*\n* @return The measured width of this view as a bit mask.\n*\n* @deprecated Use {@link View#getMeasuredWidth()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "View#getMeasuredWidth()", "methodReturn": "int", "isValid": true, "cleanReplacement": "getMeasuredWidth()", "fullMethod": "int getMeasuredWidthAndState(View)", "method": "getMeasuredWidthAndState(View)"}, "noteAlarmStart": {"methodClass": "android.app.ActivityManagerNative", "methodName": "noteAlarmStart", "replacementComments": "/**\n* @deprecated use ActivityManager.noteAlarmStart instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "ActivityManager.noteAlarmStart", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void noteAlarmStart(PendingIntent,int,String)", "method": "noteAlarmStart(PendingIntent,int,String)"}, "onCreateActionView": {"methodClass": "android.view.ActionProvider", "methodName": "onCreateActionView", "replacementComments": "/**\n* Factory method called by the Android framework to create new action views.\n*\n* <p>This method has been deprecated in favor of {@link #onCreateActionView(MenuItem)}.\n* Newer apps that wish to support platform versions prior to API 16 should also\n* implement this method to return a valid action view.</p>\n*\n* @return A new action view.\n*\n* @deprecated use {@link #onCreateActionView(MenuItem)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "onCreateActionView(MenuItem)", "methodReturn": "View", "isValid": true, "cleanReplacement": "onCreateActionView(MenuItem)", "fullMethod": "View onCreateActionView()", "method": "onCreateActionView()"}, "createDragToOpenListener": {"methodClass": "androidx.core.widget.ListPopupWindowCompat", "methodName": "createDragToOpenListener", "replacementComments": "/**\n* On API {@link android.os.Build.VERSION_CODES#KITKAT} and higher, returns\n* an {@link OnTouchListener} that can be added to the source view to\n* implement drag-to-open behavior. Generally, the source view should be the\n* same view that was passed to ListPopupWindow.setAnchorView(View).\n* <p>\n* When the listener is set on a view, touching that view and dragging\n* outside of its bounds will open the popup window. Lifting will select the\n* currently touched list item.\n* <p>\n* Example usage:\n*\n* <pre>\n* ListPopupWindow myPopup = new ListPopupWindow(context);\n* myPopup.setAnchor(myAnchor);\n* OnTouchListener dragListener = myPopup.createDragToOpenListener(myAnchor);\n* myAnchor.setOnTouchListener(dragListener);\n* </pre>\n*\n* @param listPopupWindow the ListPopupWindow against which to invoke the\n* method\n* @param src the view on which the resulting listener will be set\n* @return a touch listener that controls drag-to-open behavior, or {@code null} on\n* unsupported APIs\n*\n* @deprecated Use {@link #createDragToOpenListener(ListPopupWindow, View)} that takes in\n* {@link ListPopupWindow} instead of {@link Object}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "createDragToOpenListener(ListPopupWindow, View)", "methodReturn": "OnTouchListener", "isValid": true, "cleanReplacement": "createDragToOpenListener(ListPopupWindow, View)", "fullMethod": "OnTouchListener createDragToOpenListener(Object,View)", "method": "createDragToOpenListener(Object,View)"}, "shouldOfferSwitchingToNextInputMethod": {"methodClass": "android.view.inputmethod.InputMethodManager", "methodName": "shouldOfferSwitchingToNextInputMethod", "replacementComments": "/**\n* Returns true if the current IME needs to offer the users ways to switch to a next input\n* method (e.g. a globe key.).\n* When an IME sets supportsSwitchingToNextInputMethod and this method returns true,\n* the IME has to offer ways to to invoke {@link #switchToNextInputMethod} accordingly.\n* <p> Note that the system determines the most appropriate next input method\n* and subtype in order to provide the consistent user experience in switching\n* between IMEs and subtypes.\n* @param imeToken Supplies the identifying token given to an input method when it was started,\n* which allows it to perform this operation on itself.\n* @deprecated Use {@link InputMethodService#shouldOfferSwitchingToNextInputMethod()}\n* instead. This method was intended for IME developers who should be accessing APIs through\n* the service. APIs in this class are intended for app developers interacting with the IME.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "InputMethodService#shouldOfferSwitchingToNextInputMethod()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "shouldOfferSwitchingToNextInputMethod()", "fullMethod": "boolean shouldOfferSwitchingToNextInputMethod(IBinder)", "method": "shouldOfferSwitchingToNextInputMethod(IBinder)"}, "getAlpha": {"methodClass": "androidx.core.view.ViewCompat", "methodName": "getAlpha", "replacementComments": "/**\n* The opacity of the view. This is a value from 0 to 1, where 0 means the view is\n* completely transparent and 1 means the view is completely opaque.\n*\n* <p>By default this is 1.0f.\n* @return The opacity of the view.\n*\n* @deprecated Use {@link View#getAlpha()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "View#getAlpha()", "methodReturn": "float", "isValid": true, "cleanReplacement": "getAlpha()", "fullMethod": "float getAlpha(View)", "method": "getAlpha(View)"}, "setSize": {"methodClass": "androidx.core.widget.EdgeEffectCompat", "methodName": "setSize", "replacementComments": "/**\n* Set the size of this edge effect in pixels.\n*\n* @param width Effect width in pixels\n* @param height Effect height in pixels\n*\n* @deprecated Use {@link EdgeEffect#setSize(int, int)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "EdgeEffect#setSize(int, int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setSize(int, int)", "fullMethod": "void setSize(int,int)", "method": "setSize(int,int)"}, "setAnalogForced": {"methodClass": "android.hardware.radio.RadioTuner", "methodName": "setAnalogForced", "replacementComments": "/**\n* Forces the analog playback for the supporting radio technology.\n*\n* User may disable digital playback for FM HD Radio or hybrid FM/DAB with\n* this option. This is purely user choice, ie. does not reflect digital-\n* analog handover managed from the HAL implementation side.\n*\n* Some radio technologies may not support this, ie. DAB.\n*\n* @param isForced {@code true} to force analog, {@code false} for a default behaviour.\n* @throws IllegalStateException if the switch is not supported at current\n* configuration.\n* @deprecated Use {@link setConfigFlag(int, boolean)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setConfigFlag(int, boolean)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setConfigFlag(int, boolean)", "fullMethod": "void setAnalogForced(boolean)", "method": "setAnalogForced(boolean)"}, "canScrollHorizontally": {"methodClass": "androidx.core.view.ViewCompat", "methodName": "canScrollHorizontally", "replacementComments": "/**\n* Check if this view can be scrolled horizontally in a certain direction.\n*\n* @param view The View against which to invoke the method.\n* @param direction Negative to check scrolling left, positive to check scrolling right.\n* @return true if this view can be scrolled in the specified direction, false otherwise.\n*\n* @deprecated Use {@link View#canScrollHorizontally(int)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "View#canScrollHorizontally(int)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "canScrollHorizontally(int)", "fullMethod": "boolean canScrollHorizontally(View,int)", "method": "canScrollHorizontally(View,int)"}, "getActionMasked": {"methodClass": "androidx.core.view.MotionEventCompat", "methodName": "getActionMasked", "replacementComments": "/**\n* Call {@link MotionEvent#getAction}, returning only the {@link #ACTION_MASK}\n* portion.\n*\n* @deprecated Call {@link MotionEvent#getAction()} directly. This method will be\n* removed in a future release.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "MotionEvent#getAction()", "methodReturn": "int", "isValid": true, "cleanReplacement": "getAction()", "fullMethod": "int getActionMasked(MotionEvent)", "method": "getActionMasked(MotionEvent)"}, "sync": {"methodClass": "android.webkit.CookieSyncManager", "methodName": "sync", "replacementComments": "/**\n* sync() forces sync manager to sync now\n* @deprecated Use {@link CookieManager#flush} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "CookieManager#flush", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void sync()", "method": "sync()"}, "setExtraVisibility": {"methodClass": "androidx.leanback.widget.BaseCardView", "methodName": "setExtraVisibility", "replacementComments": "/**\n* Sets the visibility of the extra region of the card.\n*\n* @param visibility The region visibility to use for the extra region. Must\n* be one of {@link #CARD_REGION_VISIBLE_ALWAYS},\n* {@link #CARD_REGION_VISIBLE_SELECTED}, or\n* {@link #CARD_REGION_VISIBLE_ACTIVATED}.\n* @deprecated Extra view's visibility is controlled by {@link #setInfoVisibility(int)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setInfoVisibility(int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setInfoVisibility(int)", "fullMethod": "void setExtraVisibility(int)", "method": "setExtraVisibility(int)"}, "setLayerType": {"methodClass": "androidx.core.view.ViewCompat", "methodName": "setLayerType", "replacementComments": "/**\n* <p>Specifies the type of layer backing this view. The layer can be\n* {@link View#LAYER_TYPE_NONE disabled}, {@link View#LAYER_TYPE_SOFTWARE software} or\n* {@link View#LAYER_TYPE_HARDWARE hardware}.</p>\n*\n* <p>A layer is associated with an optional {@link android.graphics.Paint}\n* instance that controls how the layer is composed on screen. The following\n* properties of the paint are taken into account when composing the layer:</p>\n* <ul>\n* <li>{@link android.graphics.Paint#getAlpha() Translucency (alpha)}</li>\n* <li>{@link android.graphics.Paint#getXfermode() Blending mode}</li>\n* <li>{@link android.graphics.Paint#getColorFilter() Color filter}</li>\n* </ul>\n*\n* <p>If this view has an alpha value set to < 1.0 by calling\n* setAlpha(float), the alpha value of the layer's paint is replaced by\n* this view's alpha value. Calling setAlpha(float) is therefore\n* equivalent to setting a hardware layer on this view and providing a paint with\n* the desired alpha value.<p>\n*\n* <p>Refer to the documentation of {@link View#LAYER_TYPE_NONE disabled},\n* {@link View#LAYER_TYPE_SOFTWARE software} and {@link View#LAYER_TYPE_HARDWARE hardware}\n* for more information on when and how to use layers.</p>\n*\n* @param view View to set the layer type for\n* @param layerType The type of layer to use with this view, must be one of\n* {@link View#LAYER_TYPE_NONE}, {@link View#LAYER_TYPE_SOFTWARE} or\n* {@link View#LAYER_TYPE_HARDWARE}\n* @param paint The paint used to compose the layer. This argument is optional\n* and can be null. It is ignored when the layer type is\n* {@link View#LAYER_TYPE_NONE}\n*\n* @deprecated Use {@link View#setLayerType(int, Paint)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "View#setLayerType(int, Paint)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setLayerType(int, Paint)", "fullMethod": "void setLayerType(View,int,Paint)", "method": "setLayerType(View,int,Paint)"}, "isVtEnabledByPlatform": {"methodClass": "com.android.ims.ImsManager", "methodName": "isVtEnabledByPlatform", "replacementComments": "/**\n* Returns a platform configuration for VT which may override the user setting.\n*\n* Note: VT presumes that VoLTE is enabled (these are configuration settings\n* which must be done correctly).\n*\n* @deprecated Does not support MSIM devices. Please use\n* {@link #isVtEnabledByPlatform()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "isVtEnabledByPlatform()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "isVtEnabledByPlatform()", "fullMethod": "boolean isVtEnabledByPlatform(Context)", "method": "isVtEnabledByPlatform(Context)"}, "notifyHorizontalEdgeReached": {"methodClass": "androidx.core.widget.ScrollerCompat", "methodName": "notifyHorizontalEdgeReached", "replacementComments": "/**\n* Notify the scroller that we've reached a horizontal boundary.\n* Normally the information to handle this will already be known\n* when the animation is started, such as in a call to one of the\n* fling functions. However there are cases where this cannot be known\n* in advance. This function will transition the current motion and\n* animate from startX to finalX as appropriate.\n*\n* @param startX Starting/current X position\n* @param finalX Desired final X position\n* @param overX Magnitude of overscroll allowed. This should be the maximum\n* desired distance from finalX. Absolute value - must be positive.\n*\n* @deprecated Use {@link OverScroller#notifyHorizontalEdgeReached(int, int, int)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "OverScroller#notifyHorizontalEdgeReached(int, int, int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "notifyHorizontalEdgeReached(int, int, int)", "fullMethod": "void notifyHorizontalEdgeReached(int,int,int)", "method": "notifyHorizontalEdgeReached(int,int,int)"}, "saveConfiguration": {"methodClass": "android.net.wifi.WifiManager", "methodName": "saveConfiguration", "replacementComments": "/**\n* Tell the device to persist the current list of configured networks.\n* <p>\n* Note: It is possible for this method to change the network IDs of\n* existing networks. You should assume the network IDs can be different\n* after calling this method.\n*\n* @return {@code false} Will always return true.\n* @deprecated There is no need to call this method -\n* {@link #addNetwork(WifiConfiguration)}, {@link #updateNetwork(WifiConfiguration)}\n* and {@link #removeNetwork(int)} already persist the configurations automatically.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "addNetwork(WifiConfiguration)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "addNetwork(WifiConfiguration)", "fullMethod": "boolean saveConfiguration()", "method": "saveConfiguration()"}, "registerForCarrierPrivilegeRulesLoaded": {"methodClass": "com.android.internal.telephony.uicc.UiccCard", "methodName": "registerForCarrierPrivilegeRulesLoaded", "replacementComments": "/**\n* Notifies handler when carrier privilege rules are loaded.\n* @deprecated Please use\n* {@link UiccProfile#registerForCarrierPrivilegeRulesLoaded(Handler, int, Object)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "UiccProfile#registerForCarrierPrivilegeRulesLoaded(Handler, int, Object)", "methodReturn": "void", "isValid": true, "cleanReplacement": "registerForCarrierPrivilegeRulesLoaded(Handler, int, Object)", "fullMethod": "void registerForCarrierPrivilegeRulesLoaded(Handler,int,Object)", "method": "registerForCarrierPrivilegeRulesLoaded(Handler,int,Object)"}, "startRepeatedObject": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "startRepeatedObject", "replacementComments": "/**\n* Start a repeated child object.\n*\n* Returns a token which should be passed to endObject.  Calls to endObject must be\n* nested properly.\n*\n* @deprecated Use #start() instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "start()", "methodReturn": "long", "isValid": true, "cleanReplacement": "start()", "fullMethod": "long startRepeatedObject(long)", "method": "startRepeatedObject(long)"}, "writePackedSFixed32": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writePackedSFixed32", "replacementComments": "/**\n* Write a list of packed proto \"sfixed32\" type field value.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writePackedSFixed32(long,int[])", "method": "writePackedSFixed32(long,int[])"}, "setWfcSetting": {"methodClass": "com.android.ims.ImsManager", "methodName": "setWfcSetting", "replacementComments": "/**\n* Change persistent WFC enabled setting.\n* @deprecated Does not support MSIM devices. Please use\n* {@link #setWfcSetting} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setWfcSetting", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void setWfcSetting(Context,boolean)", "method": "setWfcSetting(Context,boolean)"}, "isChildrenDrawnWithCacheEnabled": {"methodClass": "android.view.ViewGroup", "methodName": "isChildrenDrawnWithCacheEnabled", "replacementComments": "/**\n* Indicates whether the ViewGroup is currently drawing its children using\n* their drawing cache.\n*\n* @return true if children should be drawn with their cache, false otherwise\n*\n* @see #setAlwaysDrawnWithCacheEnabled(boolean)\n* @see #setChildrenDrawnWithCacheEnabled(boolean)\n*\n* @deprecated As of {@link android.os.Build.VERSION_CODES#M}, this property is ignored.\n* Child views may no longer be forced to cache their rendering state by their parents.\n* Use {@link View#setLayerType(int, Paint)} on individual Views instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "View#setLayerType(int, Paint)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "setLayerType(int, Paint)", "fullMethod": "boolean isChildrenDrawnWithCacheEnabled()", "method": "isChildrenDrawnWithCacheEnabled()"}, "setBackgroundDrawable": {"methodClass": "android.view.View", "methodName": "setBackgroundDrawable", "replacementComments": "/**\n* @deprecated use {@link #setBackground(Drawable)} instead\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setBackground(Drawable)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setBackground(Drawable)", "fullMethod": "void setBackgroundDrawable(Drawable)", "method": "setBackgroundDrawable(Drawable)"}, "writePackedFixed32": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writePackedFixed32", "replacementComments": "/**\n* Write a list of packed proto \"fixed32\" type field value.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writePackedFixed32(long,int[])", "method": "writePackedFixed32(long,int[])"}, "getUserDisplayName": {"methodClass": "android.app.Notification.MessagingStyle", "methodName": "getUserDisplayName", "replacementComments": "/**\n* Returns the name to be displayed for any replies sent by the user\n*\n* @deprecated use {@link #getUser()} instead\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getUser()", "methodReturn": "CharSequence", "isValid": true, "cleanReplacement": "getUser()", "fullMethod": "CharSequence getUserDisplayName()", "method": "getUserDisplayName()"}, "setFadingEnabled": {"methodClass": "androidx.leanback.app.PlaybackFragment", "methodName": "setFadingEnabled", "replacementComments": "/**\n* @deprecated Uses {@link #setControlsOverlayAutoHideEnabled(boolean)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setControlsOverlayAutoHideEnabled(boolean)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setControlsOverlayAutoHideEnabled(boolean)", "fullMethod": "void setFadingEnabled(boolean)", "method": "setFadingEnabled(boolean)"}, "getCurrentMinute": {"methodClass": "android.widget.TimePicker", "methodName": "getCurrentMinute", "replacementComments": "/**\n* @return the currently selected minute, in the range (0-59)\n* @deprecated Use {@link #getMinute()}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getMinute()", "methodReturn": "Integer", "isValid": true, "cleanReplacement": "getMinute()", "fullMethod": "Integer getCurrentMinute()", "method": "getCurrentMinute()"}, "writePackedSInt32": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writePackedSInt32", "replacementComments": "/**\n* Write a list of packed proto \"sint32\" type field value.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writePackedSInt32(long,int[])", "method": "writePackedSInt32(long,int[])"}, "setItemCount": {"methodClass": "androidx.core.view.accessibility.AccessibilityRecordCompat", "methodName": "setItemCount", "replacementComments": "/**\n* Sets the number of items that can be visited.\n*\n* @param itemCount The number of items.\n*\n* @throws IllegalStateException If called from an AccessibilityService.\n*\n* @deprecated Use {@link AccessibilityRecord#setItemCount(int)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityRecord#setItemCount(int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "AccessibilityRecord#setItemCount(int)", "fullMethod": "void setItemCount(int)", "method": "setItemCount(int)"}, "restoreState": {"methodClass": "androidx.legacy.app.FragmentStatePagerAdapter", "methodName": "restoreState", "replacementComments": "/**\n* @deprecated Use {@link androidx.fragment.app.FragmentStatePagerAdapter} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "androidx.fragment.app.FragmentStatePagerAdapter", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void restoreState(Parcelable,ClassLoader)", "method": "restoreState(Parcelable,ClassLoader)"}, "writeUInt64": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writeUInt64", "replacementComments": "/**\n* Write a single proto \"uint64\" type field value.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writeUInt64(long,long)", "method": "writeUInt64(long,long)"}, "getUidUdpRxBytes": {"methodClass": "android.net.TrafficStats", "methodName": "getUidUdpRxBytes", "replacementComments": "/**\n* @deprecated Starting in {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2},\n* transport layer statistics are no longer available, and will\n* always return {@link #UNSUPPORTED}.\n* @see #getUidRxBytes(int)\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getUidRxBytes(int)", "methodReturn": "long", "isValid": true, "cleanReplacement": "getUidRxBytes(int)", "fullMethod": "long getUidUdpRxBytes(int)", "method": "getUidUdpRxBytes(int)"}, "setScrollable": {"methodClass": "androidx.core.view.accessibility.AccessibilityRecordCompat", "methodName": "setScrollable", "replacementComments": "/**\n* Sets if the source is scrollable.\n*\n* @param scrollable True if the source is scrollable, false otherwise.\n*\n* @throws IllegalStateException If called from an AccessibilityService.\n*\n* @deprecated Use {@link AccessibilityRecord#setScrollable(boolean)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityRecord#setScrollable(boolean)", "methodReturn": "void", "isValid": true, "cleanReplacement": "AccessibilityRecord#setScrollable(boolean)", "fullMethod": "void setScrollable(boolean)", "method": "setScrollable(boolean)"}, "isFinished": {"methodClass": "androidx.core.widget.ScrollerCompat", "methodName": "isFinished", "replacementComments": "/**\n* Returns whether the scroller has finished scrolling.\n*\n* @return True if the scroller has finished scrolling, false otherwise.\n*\n* @deprecated Use {@link OverScroller#isFinished()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "OverScroller#isFinished()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "OverScroller#isFinished()", "fullMethod": "boolean isFinished()", "method": "isFinished()"}, "getCurrentSync": {"methodClass": "android.content.ContentResolver", "methodName": "getCurrentSync", "replacementComments": "/**\n* If a sync is active returns the information about it, otherwise returns null.\n* <p>\n* This method requires the caller to hold the permission\n* {@link android.Manifest.permission#READ_SYNC_STATS}.\n* <p>\n* @return the SyncInfo for the currently active sync or null if one is not active.\n* @deprecated\n* Since multiple concurrent syncs are now supported you should use\n* {@link #getCurrentSyncs()} to get the accurate list of current syncs.\n* This method returns the first item from the list of current syncs\n* or null if there are none.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getCurrentSyncs()", "methodReturn": "SyncInfo", "isValid": true, "cleanReplacement": "getCurrentSyncs()", "fullMethod": "SyncInfo getCurrentSync()", "method": "getCurrentSync()"}, "equals": {"methodClass": "androidx.core.view.accessibility.AccessibilityRecordCompat", "methodName": "equals", "replacementComments": "/**\n* @deprecated Use {@link AccessibilityRecord} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityRecord", "methodReturn": "boolean", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "boolean equals(Object)", "method": "equals(Object)"}, "getFinalY": {"methodClass": "androidx.core.widget.ScrollerCompat", "methodName": "getFinalY", "replacementComments": "/**\n* @return The final Y position for the scroll in progress, if known.\n*\n* @deprecated Use {@link OverScroller#getFinalY()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "OverScroller#getFinalY()", "methodReturn": "int", "isValid": true, "cleanReplacement": "OverScroller#getFinalY()", "fullMethod": "int getFinalY()", "method": "getFinalY()"}, "iccCloseLogicalChannel": {"methodClass": "com.android.internal.telephony.uicc.UiccCard", "methodName": "iccCloseLogicalChannel", "replacementComments": "/**\n* Exposes {@link CommandsInterface#iccCloseLogicalChannel}\n* @deprecated Please use\n* {@link UiccProfile#iccCloseLogicalChannel(int, Message)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "UiccProfile#iccCloseLogicalChannel(int, Message)", "methodReturn": "void", "isValid": true, "cleanReplacement": "iccCloseLogicalChannel(int, Message)", "fullMethod": "void iccCloseLogicalChannel(int,Message)", "method": "iccCloseLogicalChannel(int,Message)"}, "getDisplayLabel": {"methodClass": "android.provider.Contacts.ContactMethods", "methodName": "getDisplayLabel", "replacementComments": "/**\n* @deprecated see {@link android.provider.ContactsContract}\n*/\n", "isClassDeprecated": true, "dirtyReplacement": "android.provider.ContactsContract", "methodReturn": "CharSequence", "isValid": true, "cleanReplacement": "android.provider.ContactsContract", "fullMethod": "CharSequence getDisplayLabel(Context,int,int,CharSequence)", "method": "getDisplayLabel(Context,int,int,CharSequence)"}, "initWithRawContactsEntityUri": {"methodClass": "com.android.vcard.VCardComposer", "methodName": "initWithRawContactsEntityUri", "replacementComments": "/**\n* Special variant of init(), which accepts a Uri for obtaining {@link RawContactsEntity} from\n* {@link ContentResolver} with {@link Contacts#_ID}.\n* <code>\n* String selection = Data.CONTACT_ID + \"=?\";\n* String[] selectionArgs = new String[] {contactId};\n* Cursor cursor = mContentResolver.query(\n* contentUriForRawContactsEntity, null, selection, selectionArgs, null)\n* </code>\n*\n* You can call this method or a variant of this method just once. In other words, you cannot\n* reuse this object.\n*\n* @deprecated Use {@link #init(Uri, String[], String, String[], String, Uri)} if you really\n* need to change the default Uri.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "init(Uri, String[], String, String[], String, Uri)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "init(Uri, String[], String, String[], String, Uri)", "fullMethod": "boolean initWithRawContactsEntityUri(Uri)", "method": "initWithRawContactsEntityUri(Uri)"}, "onSupportContentChanged": {"methodClass": "androidx.appcompat.app.AppCompatActivity", "methodName": "onSupportContentChanged", "replacementComments": "/**\n* @deprecated Use {@link #onContentChanged()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "onContentChanged()", "methodReturn": "void", "isValid": true, "cleanReplacement": "onContentChanged()", "fullMethod": "void onSupportContentChanged()", "method": "onSupportContentChanged()"}, "getMatrix": {"methodClass": "android.graphics.Canvas", "methodName": "getMatrix", "replacementComments": "/**\n* Return, in ctm, the current transformation matrix. This does not alter\n* the matrix in the canvas, but just returns a copy of it.\n*\n* @deprecated {@link #isHardwareAccelerated() Hardware accelerated} canvases may have any\n* matrix when passed to a View or Drawable, as it is implementation defined where in the\n* hierarchy such canvases are created. It is recommended in such cases to either draw contents\n* irrespective of the current matrix, or to track relevant transform state outside of the\n* canvas.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "isHardwareAccelerated() Hardware accelerated", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void getMatrix(Matrix)", "method": "getMatrix(Matrix)"}, "setOperatorBrandOverride": {"methodClass": "com.android.internal.telephony.uicc.UiccCard", "methodName": "setOperatorBrandOverride", "replacementComments": "/**\n* @deprecated Please use {@link UiccProfile#setOperatorBrandOverride(String)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "UiccProfile#setOperatorBrandOverride(String)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "UiccProfile#setOperatorBrandOverride(String)", "fullMethod": "boolean setOperatorBrandOverride(String)", "method": "setOperatorBrandOverride(String)"}, "updateCallBarring": {"methodClass": "com.android.ims.ImsUt", "methodName": "updateCallBarring", "replacementComments": "/**\n* Modifies the configuration of the call barring.\n* @deprecated Use {@link #updateCallBarring(int, int, Message, String[], int)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "updateCallBarring(int, int, Message, String[], int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "updateCallBarring(int, int, Message, String[], int)", "fullMethod": "void updateCallBarring(int,int,Message,String[])", "method": "updateCallBarring(int,int,Message,String[])"}, "isLong": {"methodClass": "android.database.AbstractWindowedCursor", "methodName": "isLong", "replacementComments": "/**\n* @deprecated Use {@link #getType}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getType", "methodReturn": "boolean", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "boolean isLong(int)", "method": "isLong(int)"}, "finishUpdate": {"methodClass": "androidx.legacy.app.FragmentStatePagerAdapter", "methodName": "finishUpdate", "replacementComments": "/**\n* @deprecated Use {@link androidx.fragment.app.FragmentStatePagerAdapter} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "androidx.fragment.app.FragmentStatePagerAdapter", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void finishUpdate(ViewGroup)", "method": "finishUpdate(ViewGroup)"}, "dragViewToTop": {"methodClass": "android.test.TouchUtils", "methodName": "dragViewToTop", "replacementComments": "/**\n* Simulate touching the center of a view and dragging to the top of the screen.\n*\n* @param test The test case that is being run\n* @param v The view that should be dragged\n* @param stepCount How many move steps to include in the drag\n*\n* @deprecated {@link android.test.ActivityInstrumentationTestCase} is deprecated in favor of\n* {@link android.test.ActivityInstrumentationTestCase2}, which provides more options for\n* configuring the Activity under test\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "android.test.ActivityInstrumentationTestCase2", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void dragViewToTop(ActivityInstrumentationTestCase,View,int)", "method": "dragViewToTop(ActivityInstrumentationTestCase,View,int)"}, "openContactPhotoInputStream": {"methodClass": "android.provider.Contacts.People", "methodName": "openContactPhotoInputStream", "replacementComments": "/**\n* Opens an InputStream for the person's photo and returns the photo as a Bitmap.\n* If the person's photo isn't present returns the placeholderImageResource instead.\n* @param person the person whose photo should be used\n* @deprecated see {@link android.provider.ContactsContract}\n*/\n", "isClassDeprecated": true, "dirtyReplacement": "android.provider.ContactsContract", "methodReturn": "InputStream", "isValid": true, "cleanReplacement": "android.provider.ContactsContract", "fullMethod": "InputStream openContactPhotoInputStream(ContentResolver,Uri)", "method": "openContactPhotoInputStream(ContentResolver,Uri)"}, "isScreenOn": {"methodClass": "android.os.PowerManager", "methodName": "isScreenOn", "replacementComments": "/**\n* Returns true if the device is in an interactive state.\n* <p>\n* For historical reasons, the name of this method refers to the power state of\n* the screen but it actually describes the overall interactive state of\n* the device.  This method has been replaced by {@link #isInteractive}.\n* </p><p>\n* The value returned by this method only indicates whether the device is\n* in an interactive state which may have nothing to do with the screen being\n* on or off.  To determine the actual state of the screen,\n* use {@link android.view.Display#getState}.\n* </p>\n*\n* @return True if the device is in an interactive state.\n*\n* @deprecated Use {@link #isInteractive} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "isInteractive", "methodReturn": "boolean", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "boolean isScreenOn()", "method": "isScreenOn()"}, "queue": {"methodClass": "android.hardware.usb.UsbRequest", "methodName": "queue", "replacementComments": "/**\n* Queues the request to send or receive data on its endpoint.\n* <p>For OUT endpoints, the given buffer data will be sent on the endpoint. For IN endpoints,\n* the endpoint will attempt to read the given number of bytes into the specified buffer. If the\n* queueing operation is successful, return true. The result will be returned via\n* {@link UsbDeviceConnection#requestWait}</p>\n*\n* @param buffer the buffer containing the bytes to write, or location to store the results of a\n* read. Position and array offset will be ignored and assumed to be 0. Limit and\n* capacity will be ignored. Once the request\n* {@link UsbDeviceConnection#requestWait() is processed} the position will be set\n* to the number of bytes read/written.\n* @param length number of bytes to read or write. Before {@value Build.VERSION_CODES#P}, a\n* value larger than 16384 bytes would be truncated down to 16384. In API\n* {@value Build.VERSION_CODES#P} and after, any value of length is valid.\n*\n* @return true if the queueing operation succeeded\n*\n* @deprecated Use {@link #queue(ByteBuffer)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "queue(ByteBuffer)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "queue(ByteBuffer)", "fullMethod": "boolean queue(ByteBuffer,int)", "method": "queue(ByteBuffer,int)"}, "getApplicationByType": {"methodClass": "com.android.internal.telephony.uicc.UiccCard", "methodName": "getApplicationByType", "replacementComments": "/**\n* Returns the SIM application of the specified type.\n*\n* @param type ICC application type (@see com.android.internal.telephony.PhoneConstants#APPTYPE_xxx)\n* @return application corresponding to type or a null if no match found\n*\n* @deprecated Please use {@link UiccProfile#getApplicationByType(int)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "UiccProfile#getApplicationByType(int)", "methodReturn": "UiccCardApplication", "isValid": true, "cleanReplacement": "UiccProfile#getApplicationByType(int)", "fullMethod": "UiccCardApplication getApplicationByType(int)", "method": "getApplicationByType(int)"}, "action": {"methodClass": "com.android.settingslib.core.instrumentation.LogWriter", "methodName": "action", "replacementComments": "/**\n* Logs an user action.\n* @deprecated use {@link #action(int, boolean, Pair[])}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "action(int, boolean, Pair[])", "methodReturn": "void", "isValid": true, "cleanReplacement": "action(int, boolean, Pair[])", "fullMethod": "void action(Context,int,boolean)", "method": "action(Context,int,boolean)"}, "isTouchExplorationEnabled": {"methodClass": "androidx.core.view.accessibility.AccessibilityManagerCompat", "methodName": "isTouchExplorationEnabled", "replacementComments": "/**\n* Returns if the touch exploration in the system is enabled.\n*\n* @param manager The accessibility manager.\n* @return True if touch exploration is enabled, false otherwise.\n*\n* @deprecated Use {@link AccessibilityManager#isTouchExplorationEnabled()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityManager#isTouchExplorationEnabled()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "isTouchExplorationEnabled()", "fullMethod": "boolean isTouchExplorationEnabled(AccessibilityManager)", "method": "isTouchExplorationEnabled(AccessibilityManager)"}, "getLatLong": {"methodClass": "androidx.exifinterface.media.ExifInterface", "methodName": "getLatLong", "replacementComments": "/**\n* Stores the latitude and longitude value in a float array. The first element is the latitude,\n* and the second element is the longitude. Returns false if the Exif tags are not available.\n*\n* @deprecated Use {@link #getLatLong()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getLatLong()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "getLatLong()", "fullMethod": "boolean getLatLong(float[])", "method": "getLatLong(float[])"}, "dispatchChange": {"methodClass": "android.database.ContentObserver", "methodName": "dispatchChange", "replacementComments": "/**\n* Dispatches a change notification to the observer.\n* <p>\n* If a {@link Handler} was supplied to the {@link ContentObserver} constructor,\n* then a call to the {@link #onChange} method is posted to the handler's message queue.\n* Otherwise, the {@link #onChange} method is invoked immediately on this thread.\n* </p>\n*\n* @param selfChange True if this is a self-change notification.\n*\n* @deprecated Use {@link #dispatchChange(boolean, Uri)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "dispatchChange(boolean, Uri)", "methodReturn": "void", "isValid": true, "cleanReplacement": "dispatchChange(boolean, Uri)", "fullMethod": "void dispatchChange(boolean)", "method": "dispatchChange(boolean)"}, "onRequestChildFocus": {"methodClass": "androidx.recyclerview.widget.RecyclerView.LayoutManager", "methodName": "onRequestChildFocus", "replacementComments": "/**\n* @deprecated Use {@link #onRequestChildFocus(RecyclerView, State, View, View)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "onRequestChildFocus(RecyclerView, State, View, View)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "onRequestChildFocus(RecyclerView, State, View, View)", "fullMethod": "boolean onRequestChildFocus(RecyclerView,View,View)", "method": "onRequestChildFocus(RecyclerView,View,View)"}, "setTint": {"methodClass": "androidx.slice.widget.SliceView", "methodName": "setTint", "replacementComments": "/**\n* @deprecated TO BE REMOVED; use {@link #setAccentColor(int)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setAccentColor(int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setAccentColor(int)", "fullMethod": "void setTint(int)", "method": "setTint(int)"}, "invalidate": {"methodClass": "android.view.View", "methodName": "invalidate", "replacementComments": "/**\n* Mark the area defined by dirty as needing to be drawn. If the view is\n* visible, {@link #onDraw(android.graphics.Canvas)} will be called at some\n* point in the future.\n* <p>\n* This must be called from a UI thread. To call from a non-UI thread, call\n* {@link #postInvalidate()}.\n* <p>\n* <b>WARNING:</b> In API 19 and below, this method may be destructive to\n* {@code dirty}.\n*\n* @param dirty the rectangle representing the bounds of the dirty region\n*\n* @deprecated The switch to hardware accelerated rendering in API 14 reduced\n* the importance of the dirty rectangle. In API 21 the given rectangle is\n* ignored entirely in favor of an internally-calculated area instead.\n* Because of this, clients are encouraged to just call {@link #invalidate()}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "invalidate()", "methodReturn": "void", "isValid": true, "cleanReplacement": "invalidate()", "fullMethod": "void invalidate(Rect)", "method": "invalidate(Rect)"}, "getSupportLoaderManager": {"methodClass": "androidx.fragment.app.FragmentActivity", "methodName": "getSupportLoaderManager", "replacementComments": "/**\n* @deprecated Use\n* {@link LoaderManager#getInstance(LifecycleOwner) LoaderManager.getInstance(this)}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "LoaderManager#getInstance(LifecycleOwner) LoaderManager.getInstance(this)", "methodReturn": "LoaderManager", "isValid": true, "cleanReplacement": "getInstance(LifecycleOwner) LoaderManager.getInstance(this)", "fullMethod": "LoaderManager getSupportLoaderManager()", "method": "getSupportLoaderManager()"}, "startManagingCursor": {"methodClass": "android.app.Activity", "methodName": "startManagingCursor", "replacementComments": "/**\n* This method allows the activity to take care of managing the given\n* {@link Cursor}'s lifecycle for you based on the activity's lifecycle.\n* That is, when the activity is stopped it will automatically call\n* {@link Cursor#deactivate} on the given Cursor, and when it is later restarted\n* it will call {@link Cursor#requery} for you.  When the activity is\n* destroyed, all managed Cursors will be closed automatically.\n*\n* <em>If you are targeting {@link android.os.Build.VERSION_CODES#HONEYCOMB}\n* or later, consider instead using {@link LoaderManager} instead, available\n* via {@link #getLoaderManager()}.</em>\n*\n* <p><strong>Warning:</strong> Do not call {@link Cursor#close()} on cursor obtained from\n* {@link #managedQuery}, because the activity will do that for you at the appropriate time.\n* However, if you call {@link #stopManagingCursor} on a cursor from a managed query, the system\n* <em>will not</em> automatically close the cursor and, in that case, you must call\n* {@link Cursor#close()}.</p>\n*\n* @param c The Cursor to be managed.\n*\n* @see #managedQuery(android.net.Uri , String[], String, String[], String)\n* @see #stopManagingCursor\n*\n* @deprecated Use the new {@link android.content.CursorLoader} class with\n* {@link LoaderManager} instead; this is also\n* available on older platforms through the Android compatibility package.\n*/\n", "isClassDeprecated": true, "dirtyReplacement": "android.content.CursorLoader", "methodReturn": "void", "isValid": true, "cleanReplacement": "android.content.CursorLoader", "fullMethod": "void startManagingCursor(Cursor)", "method": "startManagingCursor(Cursor)"}, "getMetadata": {"methodClass": "android.app.StatsManager", "methodName": "getMetadata", "replacementComments": "/**\n* @deprecated Use {@link #getStatsMetadata()}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getStatsMetadata()", "methodReturn": "byte[]", "isValid": true, "cleanReplacement": "getStatsMetadata()", "fullMethod": "byte[] getMetadata()", "method": "getMetadata()"}, "destroyDrawingCache": {"methodClass": "android.view.View", "methodName": "destroyDrawingCache", "replacementComments": "/**\n* <p>Frees the resources used by the drawing cache. If you call\n* {@link #buildDrawingCache()} manually without calling\n* {@link #setDrawingCacheEnabled(boolean) setDrawingCacheEnabled(true)}, you\n* should cleanup the cache with this method afterwards.</p>\n*\n* @see #setDrawingCacheEnabled(boolean)\n* @see #buildDrawingCache()\n* @see #getDrawingCache()\n*\n* @deprecated The view drawing cache was largely made obsolete with the introduction of\n* hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache\n* layers are largely unnecessary and can easily result in a net loss in performance due to the\n* cost of creating and updating the layer. In the rare cases where caching layers are useful,\n* such as for alpha animations, {@link #setLayerType(int, Paint)} handles this with hardware\n* rendering. For software-rendered snapshots of a small part of the View hierarchy or\n* individual Views it is recommended to create a {@link Canvas} from either a {@link Bitmap} or\n* {@link android.graphics.Picture} and call {@link #draw(Canvas)} on the View. However these\n* software-rendered usages are discouraged and have compatibility issues with hardware-only\n* rendering features such as {@link android.graphics.Bitmap.Config#HARDWARE Config.HARDWARE}\n* bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback\n* reports or unit testing the {@link PixelCopy} API is recommended.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setLayerType(int, Paint)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setLayerType(int, Paint)", "fullMethod": "void destroyDrawingCache()", "method": "destroyDrawingCache()"}, "formatNumber": {"methodClass": "android.telephony.PhoneNumberUtils", "methodName": "formatNumber", "replacementComments": "/**\n* Formats a phone number in-place. Currently {@link #FORMAT_JAPAN} and {@link #FORMAT_NANP}\n* is supported as a second argument.\n*\n* @param text The number to be formatted, will be modified with the formatting\n* @param defaultFormattingType The default formatting rules to apply if the number does\n* not begin with +[country_code]\n*\n* @deprecated Use link #formatNumber(String phoneNumber, String defaultCountryIso) instead\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "link #formatNumber(String phoneNumber, String defaultCountryIso)", "methodReturn": "void", "isValid": true, "cleanReplacement": "formatNumber(String phoneNumber, String defaultCountryIso)", "fullMethod": "void formatNumber(Editable,int)", "method": "formatNumber(Editable,int)"}, "setCurrentTime": {"methodClass": "androidx.leanback.widget.PlaybackControlsRow", "methodName": "setCurrentTime", "replacementComments": "/**\n* Sets the current time in milliseconds for the playback controls row.\n* If this row is bound to a view, the view will automatically\n* be updated to reflect the new value.\n* @deprecated use {@link #setCurrentPosition(long)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setCurrentPosition(long)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setCurrentPosition(long)", "fullMethod": "void setCurrentTime(int)", "method": "setCurrentTime(int)"}, "getText": {"methodClass": "android.speech.tts.SynthesisRequest", "methodName": "getText", "replacementComments": "/**\n* Gets the text which should be synthesized.\n* @deprecated As of API level 21, replaced by {@link #getCharSequenceText}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getCharSequenceText", "methodReturn": "String", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "String getText()", "method": "getText()"}, "getInstalledAccessibilityServiceList": {"methodClass": "androidx.core.view.accessibility.AccessibilityManagerCompat", "methodName": "getInstalledAccessibilityServiceList", "replacementComments": "/**\n* Returns the {@link AccessibilityServiceInfo}s of the installed accessibility services.\n*\n* @param manager The accessibility manager.\n* @return An unmodifiable list with {@link AccessibilityServiceInfo}s.\n*\n* @deprecated Use {@link AccessibilityManager#getInstalledAccessibilityServiceList()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityManager#getInstalledAccessibilityServiceList()", "methodReturn": "List<AccessibilityServiceInfo>", "isValid": true, "cleanReplacement": "getInstalledAccessibilityServiceList()", "fullMethod": "List<AccessibilityServiceInfo> getInstalledAccessibilityServiceList(AccessibilityManager)", "method": "getInstalledAccessibilityServiceList(AccessibilityManager)"}, "getWidth": {"methodClass": "android.view.Display", "methodName": "getWidth", "replacementComments": "/**\n* @deprecated Use {@link #getSize(Point)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getSize(Point)", "methodReturn": "int", "isValid": true, "cleanReplacement": "getSize(Point)", "fullMethod": "int getWidth()", "method": "getWidth()"}, "setBroadcastSubscriber": {"methodClass": "android.app.StatsManager", "methodName": "setBroadcastSubscriber", "replacementComments": "/**\n* @deprecated Use {@link #setBroadcastSubscriber(PendingIntent, long, long)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setBroadcastSubscriber(PendingIntent, long, long)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "setBroadcastSubscriber(PendingIntent, long, long)", "fullMethod": "boolean setBroadcastSubscriber(long,long,PendingIntent)", "method": "setBroadcastSubscriber(long,long,PendingIntent)"}, "setPriority": {"methodClass": "android.app.Notification.Builder", "methodName": "setPriority", "replacementComments": "/**\n* Set the priority of this notification.\n*\n* @see Notification#priority\n* @deprecated use {@link NotificationChannel#setImportance(int)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "NotificationChannel#setImportance(int)", "methodReturn": "Builder", "isValid": true, "cleanReplacement": "setImportance(int)", "fullMethod": "Builder setPriority(int)", "method": "setPriority(int)"}, "setInput": {"methodClass": "android.renderscript.ScriptGroup", "methodName": "setInput", "replacementComments": "/**\n* Sets an input of the ScriptGroup. This specifies an\n* Allocation to be used for kernels that require an input\n* Allocation provided from outside of the ScriptGroup.\n*\n* @deprecated Set arguments to {@link #execute(Object...)} instead.\n*\n* @param s The ID of the kernel where the allocation should be\n* connected.\n* @param a The allocation to connect.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "execute(Object...)", "methodReturn": "void", "isValid": true, "cleanReplacement": "execute(Object...)", "fullMethod": "void setInput(KernelID,Allocation)", "method": "setInput(KernelID,Allocation)"}, "calledPartyBCDToString": {"methodClass": "android.telephony.PhoneNumberUtils", "methodName": "calledPartyBCDToString", "replacementComments": "/**\n* 3GPP TS 24.008 10.5.4.7\n* Called Party BCD Number\n*\n* See Also TS 51.011 10.5.1 \"dialing number/ssc string\"\n* and TS 11.11 \"10.3.1 EF adn (Abbreviated dialing numbers)\"\n*\n* @param bytes the data buffer\n* @param offset should point to the TOA (aka. TON/NPI) octet after the length byte\n* @param length is the number of bytes including TOA byte\n* and must be at least 2\n*\n* @return partial string on invalid decode\n*\n* @deprecated use {@link #calledPartyBCDToString(byte[], int, int, int)} instead. Calling this\n* method is equivalent to calling {@link #calledPartyBCDToString(byte[], int, int)} with\n* {@link #BCD_EXTENDED_TYPE_EF_ADN} as the extended type.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "calledPartyBCDToString(byte[], int, int, int)", "methodReturn": "String", "isValid": true, "cleanReplacement": "calledPartyBCDToString(byte[], int, int, int)", "fullMethod": "String calledPartyBCDToString(byte[],int,int)", "method": "calledPartyBCDToString(byte[],int,int)"}, "apply": {"methodClass": "androidx.core.content.SharedPreferencesCompat.EditorCompat", "methodName": "apply", "replacementComments": "/**\n* @deprecated This compatibility method is no longer required. Use\n* {@link SharedPreferences.Editor#apply()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "SharedPreferences.Editor#apply()", "methodReturn": "void", "isValid": true, "cleanReplacement": "apply()", "fullMethod": "void apply(Editor)", "method": "apply(Editor)"}, "isConnecting": {"methodClass": "androidx.mediarouter.media.MediaRouteDescriptor", "methodName": "isConnecting", "replacementComments": "/**\n* Gets whether the route is connecting.\n* @deprecated Use {@link #getConnectionState} instead\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getConnectionState", "methodReturn": "boolean", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "boolean isConnecting()", "method": "isConnecting()"}, "hideChild": {"methodClass": "android.animation.LayoutTransition", "methodName": "hideChild", "replacementComments": "/**\n* @deprecated Use {@link #hideChild(android.view.ViewGroup, android.view.View, int)}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "hideChild(android.view.ViewGroup, android.view.View, int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "hideChild(android.view.ViewGroup, android.view.View, int)", "fullMethod": "void hideChild(ViewGroup,View)", "method": "hideChild(ViewGroup,View)"}, "smoothSlideClosed": {"methodClass": "androidx.slidingpanelayout.widget.SlidingPaneLayout", "methodName": "smoothSlideClosed", "replacementComments": "/**\n* @deprecated Renamed to {@link #closePane()} - this method is going away soon!\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "closePane()", "methodReturn": "void", "isValid": true, "cleanReplacement": "closePane()", "fullMethod": "void smoothSlideClosed()", "method": "smoothSlideClosed()"}, "writePackedBool": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writePackedBool", "replacementComments": "/**\n* Write a list of packed proto \"bool\" type field value.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writePackedBool(long,boolean[])", "method": "writePackedBool(long,boolean[])"}, "getMinutes": {"methodClass": "java.sql.Date", "methodName": "getMinutes", "replacementComments": "/**\n* @deprecated This method is deprecated and should not be used because SQL Date\n* values do not have a time component.\n*\n* @exception java.lang.IllegalArgumentException if this method is invoked\n* @see #setMinutes\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setMinutes", "methodReturn": "int", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "int getMinutes()", "method": "getMinutes()"}, "syncFromRamToFlash": {"methodClass": "android.webkit.CookieSyncManager", "methodName": "syncFromRamToFlash", "replacementComments": "/**\n* @deprecated Use {@link CookieManager#flush} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "CookieManager#flush", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void syncFromRamToFlash()", "method": "syncFromRamToFlash()"}, "getOperatorBrandOverride": {"methodClass": "com.android.internal.telephony.uicc.UiccCard", "methodName": "getOperatorBrandOverride", "replacementComments": "/**\n* @deprecated Please use {@link UiccProfile#getOperatorBrandOverride()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "UiccProfile#getOperatorBrandOverride()", "methodReturn": "String", "isValid": true, "cleanReplacement": "UiccProfile#getOperatorBrandOverride()", "fullMethod": "String getOperatorBrandOverride()", "method": "getOperatorBrandOverride()"}, "from": {"methodClass": "android.telephony.SubscriptionManager", "methodName": "from", "replacementComments": "/**\n* @deprecated developers should always obtain references directly from\n* {@link Context#getSystemService(Class)}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "Context#getSystemService(Class)", "methodReturn": "SubscriptionManager", "isValid": true, "cleanReplacement": "getSystemService(Class)", "fullMethod": "SubscriptionManager from(Context)", "method": "from(Context)"}, "writePackedFloat": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writePackedFloat", "replacementComments": "/**\n* Write a list of packed proto \"float\" type field value.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writePackedFloat(long,float[])", "method": "writePackedFloat(long,float[])"}, "getLegacyListenerFromContext": {"methodClass": "com.android.setupwizardlib.span.LinkSpan", "methodName": "getLegacyListenerFromContext", "replacementComments": "/**\n* @deprecated Deprecated together with {@link OnClickListener}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "OnClickListener", "methodReturn": "OnClickListener", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "OnClickListener getLegacyListenerFromContext(Context)", "method": "getLegacyListenerFromContext(Context)"}, "getCarrierPhaseUncertainty": {"methodClass": "android.location.GnssMeasurement", "methodName": "getCarrierPhaseUncertainty", "replacementComments": "/**\n* Gets the carrier-phase's uncertainty (1-Sigma).\n*\n* <p>The uncertainty is represented as an absolute (single sided) value.\n*\n* <p>The value is only available if {@link #hasCarrierPhaseUncertainty()} is {@code true}.\n*\n* @deprecated use {@link #getAccumulatedDeltaRangeUncertaintyMeters()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getAccumulatedDeltaRangeUncertaintyMeters()", "methodReturn": "double", "isValid": true, "cleanReplacement": "getAccumulatedDeltaRangeUncertaintyMeters()", "fullMethod": "double getCarrierPhaseUncertainty()", "method": "getCarrierPhaseUncertainty()"}, "addGrid": {"methodClass": "androidx.slice.builders.ListBuilder", "methodName": "addGrid", "replacementComments": "/**\n* Add a grid row to the list builder.\n*\n* @deprecated TO BE REMOVED; use {@link #addGridRow(GridRowBuilder)} instead\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "addGridRow(GridRowBuilder)", "methodReturn": "ListBuilder", "isValid": true, "cleanReplacement": "addGridRow(GridRowBuilder)", "fullMethod": "ListBuilder addGrid(GridBuilder)", "method": "addGrid(GridBuilder)"}, "setPresenceIcon": {"methodClass": "android.provider.Contacts.Presence", "methodName": "setPresenceIcon", "replacementComments": "/**\n* Sets a presence icon to the proper graphic\n*\n* @param icon the icon to to set\n* @param serverStatus that status\n* @deprecated see {@link android.provider.ContactsContract}\n*/\n", "isClassDeprecated": true, "dirtyReplacement": "android.provider.ContactsContract", "methodReturn": "void", "isValid": true, "cleanReplacement": "android.provider.ContactsContract", "fullMethod": "void setPresenceIcon(ImageView,int)", "method": "setPresenceIcon(ImageView,int)"}, "startScroll": {"methodClass": "androidx.core.widget.ScrollerCompat", "methodName": "startScroll", "replacementComments": "/**\n* Start scrolling by providing a starting point and the distance to travel.\n*\n* @param startX Starting horizontal scroll offset in pixels. Positive\n* numbers will scroll the content to the left.\n* @param startY Starting vertical scroll offset in pixels. Positive numbers\n* will scroll the content up.\n* @param dx Horizontal distance to travel. Positive numbers will scroll the\n* content to the left.\n* @param dy Vertical distance to travel. Positive numbers will scroll the\n* content up.\n* @param duration Duration of the scroll in milliseconds.\n*\n* @deprecated Use {@link OverScroller#startScroll(int, int, int, int, int)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "OverScroller#startScroll(int, int, int, int, int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "startScroll(int, int, int, int, int)", "fullMethod": "void startScroll(int,int,int,int,int)", "method": "startScroll(int,int,int,int,int)"}, "setTTL": {"methodClass": "java.net.MulticastSocket", "methodName": "setTTL", "replacementComments": "/**\n* Set the default time-to-live for multicast packets sent out\n* on this {@code MulticastSocket} in order to control the\n* scope of the multicasts.\n*\n* <p>The ttl is an <b>unsigned</b> 8-bit quantity, and so <B>must</B> be\n* in the range {@code 0 <= ttl <= 0xFF }.\n*\n* @param ttl the time-to-live\n* @exception IOException if an I/O exception occurs\n* while setting the default time-to-live value\n* @deprecated use the setTimeToLive method instead, which uses\n* <b>int</b> instead of <b>byte</b> as the type for ttl.\n* @see #getTTL()\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "the setTimeToLive method", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void setTTL(byte)", "method": "setTTL(byte)"}, "showProgressBar": {"methodClass": "com.android.setupwizardlib.SetupWizardLayout", "methodName": "showProgressBar", "replacementComments": "/**\n* @deprecated Use {@link #setProgressBarShown(boolean)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setProgressBarShown(boolean)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setProgressBarShown(boolean)", "fullMethod": "void showProgressBar()", "method": "showProgressBar()"}, "onPasswordFailed": {"methodClass": "android.app.admin.DeviceAdminReceiver", "methodName": "onPasswordFailed", "replacementComments": "/**\n* Called after the user has failed at entering their device or profile challenge password,\n* as a result of receiving {@link #ACTION_PASSWORD_FAILED}.  At this point you can use\n* {@link DevicePolicyManager#getCurrentFailedPasswordAttempts()} to retrieve the number of\n* failed password attempts.\n* @param context The running context as per {@link #onReceive}.\n* @param intent The received intent as per {@link #onReceive}.\n*\n* @deprecated From {@link android.os.Build.VERSION_CODES#O}, use\n* {@link #onPasswordFailed(Context, Intent, UserHandle)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "onPasswordFailed(Context, Intent, UserHandle)", "methodReturn": "void", "isValid": true, "cleanReplacement": "onPasswordFailed(Context, Intent, UserHandle)", "fullMethod": "void onPasswordFailed(Context,Intent)", "method": "onPasswordFailed(Context,Intent)"}, "getControlsRowPresenter": {"methodClass": "androidx.leanback.media.PlaybackControlGlue", "methodName": "getControlsRowPresenter", "replacementComments": "/**\n* Returns the playback controls row Presenter managed by the glue layer.\n* @deprecated PlaybackControlGlue supports any PlaybackRowPresenter, use\n* {@link #getPlaybackRowPresenter()}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getPlaybackRowPresenter()", "methodReturn": "PlaybackControlsRowPresenter", "isValid": true, "cleanReplacement": "getPlaybackRowPresenter()", "fullMethod": "PlaybackControlsRowPresenter getControlsRowPresenter()", "method": "getControlsRowPresenter()"}, "writeRepeatedSFixed32": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writeRepeatedSFixed32", "replacementComments": "/**\n* Write a single repeated proto \"sfixed32\" type field value.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writeRepeatedSFixed32(long,int)", "method": "writeRepeatedSFixed32(long,int)"}, "managedQuery": {"methodClass": "android.app.Activity", "methodName": "managedQuery", "replacementComments": "/**\n* Wrapper around\n* {@link ContentResolver#query(android.net.Uri , String[], String, String[], String)}\n* that gives the resulting {@link Cursor} to call\n* {@link #startManagingCursor} so that the activity will manage its\n* lifecycle for you.\n*\n* <em>If you are targeting {@link android.os.Build.VERSION_CODES#HONEYCOMB}\n* or later, consider instead using {@link LoaderManager} instead, available\n* via {@link #getLoaderManager()}.</em>\n*\n* <p><strong>Warning:</strong> Do not call {@link Cursor#close()} on a cursor obtained using\n* this method, because the activity will do that for you at the appropriate time. However, if\n* you call {@link #stopManagingCursor} on a cursor from a managed query, the system <em>will\n* not</em> automatically close the cursor and, in that case, you must call\n* {@link Cursor#close()}.</p>\n*\n* @param uri The URI of the content provider to query.\n* @param projection List of columns to return.\n* @param selection SQL WHERE clause.\n* @param selectionArgs The arguments to selection, if any ?s are pesent\n* @param sortOrder SQL ORDER BY clause.\n*\n* @return The Cursor that was returned by query().\n*\n* @see ContentResolver#query(android.net.Uri , String[], String, String[], String)\n* @see #startManagingCursor\n*\n* @deprecated Use {@link CursorLoader} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "CursorLoader", "methodReturn": "Cursor", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "Cursor managedQuery(Uri,String[],String,String[],String)", "method": "managedQuery(Uri,String[],String,String[],String)"}, "dispatchPictureInPictureModeChanged": {"methodClass": "android.app.FragmentController", "methodName": "dispatchPictureInPictureModeChanged", "replacementComments": "/**\n* Lets all Fragments managed by the controller's FragmentManager know the picture-in-picture\n* mode of the activity changed.\n* <p>Call when the picture-in-picture mode of the activity changed.\n*\n* @see Fragment#onPictureInPictureModeChanged\n* @deprecated use {@link #dispatchPictureInPictureModeChanged(boolean, Configuration)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "dispatchPictureInPictureModeChanged(boolean, Configuration)", "methodReturn": "void", "isValid": true, "cleanReplacement": "dispatchPictureInPictureModeChanged(boolean, Configuration)", "fullMethod": "void dispatchPictureInPictureModeChanged(boolean)", "method": "dispatchPictureInPictureModeChanged(boolean)"}, "isVolteProvisionedOnDevice": {"methodClass": "com.android.ims.ImsManager", "methodName": "isVolteProvisionedOnDevice", "replacementComments": "/**\n* Indicates whether VoLTE is provisioned on device.\n*\n* @deprecated Does not support MSIM devices. Please use\n* {@link #isVolteProvisionedOnDevice()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "isVolteProvisionedOnDevice()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "isVolteProvisionedOnDevice()", "fullMethod": "boolean isVolteProvisionedOnDevice(Context)", "method": "isVolteProvisionedOnDevice(Context)"}, "setEnabled": {"methodClass": "androidx.core.view.accessibility.AccessibilityRecordCompat", "methodName": "setEnabled", "replacementComments": "/**\n* Sets if the source is enabled.\n*\n* @param isEnabled True if the view is enabled, false otherwise.\n*\n* @throws IllegalStateException If called from an AccessibilityService.\n*\n* @deprecated Use {@link AccessibilityRecord#isEnabled()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityRecord#isEnabled()", "methodReturn": "void", "isValid": true, "cleanReplacement": "isEnabled()", "fullMethod": "void setEnabled(boolean)", "method": "setEnabled(boolean)"}, "setCid": {"methodClass": "android.telephony.NeighboringCellInfo", "methodName": "setCid", "replacementComments": "/**\n* Set the cell id.\n*\n* NeighboringCellInfo is a one time shot for the neighboring cells based on\n* the radio network type at that moment. It shouldn't be changed after\n* creation.\n*\n* @deprecated cid value passed as in location parameter passed to constructor\n* {@link #NeighboringCellInfo(int, String, int)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "NeighboringCellInfo(int, String, int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "NeighboringCellInfo(int, String, int)", "fullMethod": "void setCid(int)", "method": "setCid(int)"}, "onAbsorb": {"methodClass": "androidx.core.widget.EdgeEffectCompat", "methodName": "onAbsorb", "replacementComments": "/**\n* Call when the effect absorbs an impact at the given velocity.\n* Used when a fling reaches the scroll boundary.\n*\n* <p>When using a {@link android.widget.Scroller} or {@link android.widget.OverScroller},\n* the method <code>getCurrVelocity</code> will provide a reasonable approximation\n* to use here.</p>\n*\n* @param velocity Velocity at impact in pixels per second.\n* @return true if the host view should invalidate, false if it should not.\n*\n* @deprecated Use {@link EdgeEffect#onAbsorb(int)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "EdgeEffect#onAbsorb(int)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "EdgeEffect#onAbsorb(int)", "fullMethod": "boolean onAbsorb(int)", "method": "onAbsorb(int)"}, "noteWakeupAlarm": {"methodClass": "android.app.ActivityManagerNative", "methodName": "noteWakeupAlarm", "replacementComments": "/**\n* @deprecated use ActivityManager.noteWakeupAlarm instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "ActivityManager.noteWakeupAlarm", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void noteWakeupAlarm(PendingIntent,int,String,String)", "method": "noteWakeupAlarm(PendingIntent,int,String,String)"}, "hasCarrierPhase": {"methodClass": "android.location.GnssMeasurement", "methodName": "hasCarrierPhase", "replacementComments": "/**\n* Returns {@code true} if {@link #getCarrierPhase()} is available, {@code false} otherwise.\n*\n* @deprecated use {@link #getAccumulatedDeltaRangeState()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getAccumulatedDeltaRangeState()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "getAccumulatedDeltaRangeState()", "fullMethod": "boolean hasCarrierPhase()", "method": "hasCarrierPhase()"}, "RecommendationInfo": {"methodClass": "android.printservice.recommendation.RecommendationInfo", "methodName": "RecommendationInfo", "replacementComments": "/**\n* Create a new recommendation.\n*\n* @param packageName                  Package name of the print service\n* @param name                         Display name of the print service\n* @param numDiscoveredPrinters        Number of printers the print service would discover if\n* installed\n* @param recommendsMultiVendorService If the service detects printer from multiple vendor\n*\n* @deprecated Use {@link RecommendationInfo(String, String, List<InetAddress>, boolean)}\n* instead\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "RecommendationInfo(String, String, List<InetAddress>, boolean)", "methodReturn": "void", "isValid": true, "cleanReplacement": "RecommendationInfo(String, String, List<InetAddress>, boolean)", "fullMethod": "void <init>(CharSequence,CharSequence,int,boolean)", "method": "<init>(CharSequence,CharSequence,int,boolean)"}, "writeInt64": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writeInt64", "replacementComments": "/**\n* Write a single proto \"int64\" type field value.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writeInt64(long,long)", "method": "writeInt64(long,long)"}, "hideStatusIcon": {"methodClass": "android.view.inputmethod.InputMethodManager", "methodName": "hideStatusIcon", "replacementComments": "/**\n* @deprecated Use {@link InputMethodService#hideStatusIcon()} instead. This method was\n* intended for IME developers who should be accessing APIs through the service. APIs in\n* this class are intended for app developers interacting with the IME.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "InputMethodService#hideStatusIcon()", "methodReturn": "void", "isValid": true, "cleanReplacement": "hideStatusIcon()", "fullMethod": "void hideStatusIcon(IBinder)", "method": "hideStatusIcon(IBinder)"}, "getPointerId": {"methodClass": "androidx.core.view.MotionEventCompat", "methodName": "getPointerId", "replacementComments": "/**\n* Call {@link MotionEvent#getPointerId(int)}.\n*\n* @deprecated Call {@link MotionEvent#getPointerId(int)} directly. This method will be\n* removed in a future release.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "MotionEvent#getPointerId(int)", "methodReturn": "int", "isValid": true, "cleanReplacement": "getPointerId(int)", "fullMethod": "int getPointerId(MotionEvent,int)", "method": "getPointerId(MotionEvent,int)"}, "getZoomFactor": {"methodClass": "androidx.leanback.widget.ListRowPresenter", "methodName": "getZoomFactor", "replacementComments": "/**\n* Returns the zoom factor used for focus highlighting.\n* @deprecated use {@link #getFocusZoomFactor} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getFocusZoomFactor", "methodReturn": "int", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "int getZoomFactor()", "method": "getZoomFactor()"}, "visibility": {"methodClass": "com.android.internal.logging.MetricsLogger", "methodName": "visibility", "replacementComments": "/**\n* @deprecated use {@link #visibility(int, boolean)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "visibility(int, boolean)", "methodReturn": "void", "isValid": true, "cleanReplacement": "visibility(int, boolean)", "fullMethod": "void visibility(Context,int,boolean)", "method": "visibility(Context,int,boolean)"}, "getChannel": {"methodClass": "android.hardware.radio.RadioManager.ProgramInfo", "methodName": "getChannel", "replacementComments": "/**\n* Main channel expressed in units according to band type.\n* Currently all defined band types express channels as frequency in kHz\n* @return the program channel\n* @deprecated Use {@link getSelector()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getSelector()", "methodReturn": "int", "isValid": true, "cleanReplacement": "getSelector()", "fullMethod": "int getChannel()", "method": "getChannel()"}, "writeRepeatedInt64": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writeRepeatedInt64", "replacementComments": "/**\n* Write a single repeated proto \"int64\" type field value.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writeRepeatedInt64(long,long)", "method": "writeRepeatedInt64(long,long)"}, "stopManagingCursor": {"methodClass": "android.app.Activity", "methodName": "stopManagingCursor", "replacementComments": "/**\n* Given a Cursor that was previously given to\n* {@link #startManagingCursor}, stop the activity's management of that\n* cursor.\n*\n* <p><strong>Warning:</strong> After calling this method on a cursor from a managed query,\n* the system <em>will not</em> automatically close the cursor and you must call\n* {@link Cursor#close()}.</p>\n*\n* @param c The Cursor that was being managed.\n*\n* @see #startManagingCursor\n*\n* @deprecated Use the new {@link android.content.CursorLoader} class with\n* {@link LoaderManager} instead; this is also\n* available on older platforms through the Android compatibility package.\n*/\n", "isClassDeprecated": true, "dirtyReplacement": "android.content.CursorLoader", "methodReturn": "void", "isValid": true, "cleanReplacement": "android.content.CursorLoader", "fullMethod": "void stopManagingCursor(Cursor)", "method": "stopManagingCursor(Cursor)"}, "setAction": {"methodClass": "androidx.slice.builders.ListBuilder.InputRangeBuilder", "methodName": "setAction", "replacementComments": "/**\n* Set the {@link PendingIntent} to send when the current value is updated.\n*\n* @deprecated TO BE REMOVED; use {@link InputRangeBuilder#setInputAction(PendingIntent)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "InputRangeBuilder#setInputAction(PendingIntent)", "methodReturn": "InputRangeBuilder", "isValid": true, "cleanReplacement": "setInputAction(PendingIntent)", "fullMethod": "InputRangeBuilder setAction(PendingIntent)", "method": "setAction(PendingIntent)"}, "getVersion": {"methodClass": "android.content.pm.SharedLibraryInfo", "methodName": "getVersion", "replacementComments": "/**\n* @deprecated Use {@link #getLongVersion()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getLongVersion()", "methodReturn": "int", "isValid": true, "cleanReplacement": "getLongVersion()", "fullMethod": "int getVersion()", "method": "getVersion()"}, "withExecutor": {"methodClass": "androidx.work.Configuration.Builder", "methodName": "withExecutor", "replacementComments": "/**\n* Specifies a custom {@link Executor} for WorkManager.\n*\n* @param executor An {@link Executor} for processing work\n* @return This {@link Builder} instance\n* @deprecated Use the {@link Configuration.Builder#setExecutor(Executor)} method instead\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "Configuration.Builder#setExecutor(Executor)", "methodReturn": "Builder", "isValid": true, "cleanReplacement": "setExecutor(Executor)", "fullMethod": "Builder withExecutor(Executor)", "method": "withExecutor(Executor)"}, "getPosition": {"methodClass": "com.android.internal.widget.RecyclerView.ViewHolder", "methodName": "getPosition", "replacementComments": "/**\n* @deprecated This method is deprecated because its meaning is ambiguous due to the async\n* handling of adapter updates. Please use {@link #getLayoutPosition()} or\n* {@link #getAdapterPosition()} depending on your use case.\n*\n* @see #getLayoutPosition()\n* @see #getAdapterPosition()\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getLayoutPosition()", "methodReturn": "int", "isValid": true, "cleanReplacement": "getLayoutPosition()", "fullMethod": "int getPosition()", "method": "getPosition()"}, "getCarrierPackageNamesForIntent": {"methodClass": "com.android.internal.telephony.uicc.UiccCard", "methodName": "getCarrierPackageNamesForIntent", "replacementComments": "/**\n* Exposes {@link UiccCarrierPrivilegeRules#getCarrierPackageNamesForIntent}.\n* @deprecated Please use\n* {@link UiccProfile#getCarrierPackageNamesForIntent(PackageManager, Intent)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "UiccProfile#getCarrierPackageNamesForIntent(PackageManager, Intent)", "methodReturn": "List<String>", "isValid": true, "cleanReplacement": "getCarrierPackageNamesForIntent(PackageManager, Intent)", "fullMethod": "List<String> getCarrierPackageNamesForIntent(PackageManager,Intent)", "method": "getCarrierPackageNamesForIntent(PackageManager,Intent)"}, "getAvailableBlocks": {"methodClass": "android.os.StatFs", "methodName": "getAvailableBlocks", "replacementComments": "/**\n* @deprecated Use {@link #getAvailableBlocksLong()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getAvailableBlocksLong()", "methodReturn": "int", "isValid": true, "cleanReplacement": "getAvailableBlocksLong()", "fullMethod": "int getAvailableBlocks()", "method": "getAvailableBlocks()"}, "removeStickyBroadcast": {"methodClass": "android.content.Context", "methodName": "removeStickyBroadcast", "replacementComments": "/**\n* <p>Remove the data previously sent with {@link #sendStickyBroadcast},\n* so that it is as if the sticky broadcast had never happened.\n*\n* @deprecated Sticky broadcasts should not be used.  They provide no security (anyone\n* can access them), no protection (anyone can modify them), and many other problems.\n* The recommended pattern is to use a non-sticky broadcast to report that <em>something</em>\n* has changed, with another mechanism for apps to retrieve the current value whenever\n* desired.\n*\n* @param intent The Intent that was previously broadcast.\n*\n* @see #sendStickyBroadcast\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "sendStickyBroadcast", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void removeStickyBroadcast(Intent)", "method": "removeStickyBroadcast(Intent)"}, "abandonAudioFocus": {"methodClass": "android.media.AudioManager", "methodName": "abandonAudioFocus", "replacementComments": "/**\n* Abandon audio focus. Causes the previous focus owner, if any, to receive focus.\n* @param l the listener with which focus was requested.\n* @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}\n* @deprecated use {@link #abandonAudioFocusRequest(AudioFocusRequest)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "abandonAudioFocusRequest(AudioFocusRequest)", "methodReturn": "int", "isValid": true, "cleanReplacement": "abandonAudioFocusRequest(AudioFocusRequest)", "fullMethod": "int abandonAudioFocus(OnAudioFocusChangeListener)", "method": "abandonAudioFocus(OnAudioFocusChangeListener)"}, "canSlide": {"methodClass": "androidx.slidingpanelayout.widget.SlidingPaneLayout", "methodName": "canSlide", "replacementComments": "/**\n* @return true if content in this layout can be slid open and closed\n* @deprecated Renamed to {@link #isSlideable()} - this method is going away soon!\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "isSlideable()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "isSlideable()", "fullMethod": "boolean canSlide()", "method": "canSlide()"}, "getY": {"methodClass": "androidx.core.view.MotionEventCompat", "methodName": "getY", "replacementComments": "/**\n* Call {@link MotionEvent#getY(int)}.\n*\n* @deprecated Call {@link MotionEvent#getY()} directly. This method will be\n* removed in a future release.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "MotionEvent#getY()", "methodReturn": "float", "isValid": true, "cleanReplacement": "getY()", "fullMethod": "float getY(MotionEvent,int)", "method": "getY(MotionEvent,int)"}, "setPhotoData": {"methodClass": "android.provider.Contacts.People", "methodName": "setPhotoData", "replacementComments": "/**\n* Set the photo for this person. data may be null\n* @param cr the ContentResolver to use\n* @param person the Uri of the person whose photo is to be updated\n* @param data the byte[] that represents the photo\n* @deprecated see {@link android.provider.ContactsContract}\n*/\n", "isClassDeprecated": true, "dirtyReplacement": "android.provider.ContactsContract", "methodReturn": "void", "isValid": true, "cleanReplacement": "android.provider.ContactsContract", "fullMethod": "void setPhotoData(ContentResolver,Uri,byte[])", "method": "setPhotoData(ContentResolver,Uri,byte[])"}, "addConfiguration": {"methodClass": "android.app.StatsManager", "methodName": "addConfiguration", "replacementComments": "/**\n* @deprecated Use {@link #addConfig(long, byte[])}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "addConfig(long, byte[])", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "addConfig(long, byte[])", "fullMethod": "boolean addConfiguration(long,byte[])", "method": "addConfiguration(long,byte[])"}, "setup": {"methodClass": "androidx.legacy.app.FragmentTabHost", "methodName": "setup", "replacementComments": "/**\n* @deprecated Use {@link androidx.fragment.app.FragmentTabHost} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "androidx.fragment.app.FragmentTabHost", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void setup(Context,FragmentManager,int)", "method": "setup(Context,FragmentManager,int)"}, "getProgramType": {"methodClass": "android.hardware.radio.ProgramSelector", "methodName": "getProgramType", "replacementComments": "/**\n* Type of a radio technology.\n*\n* @return program type.\n* @deprecated use {@link getPrimaryId} instead\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getPrimaryId", "methodReturn": "int", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "int getProgramType()", "method": "getProgramType()"}, "getFeatures": {"methodClass": "android.speech.tts.TextToSpeech", "methodName": "getFeatures", "replacementComments": "/**\n* Queries the engine for the set of features it supports for a given locale.\n* Features can either be framework defined, e.g.\n* {@link TextToSpeech.Engine#KEY_FEATURE_NETWORK_SYNTHESIS} or engine specific.\n* Engine specific keys must be prefixed by the name of the engine they\n* are intended for. These keys can be used as parameters to\n* {@link TextToSpeech#speak(String, int, java.util.HashMap)} and\n* {@link TextToSpeech#synthesizeToFile(String, java.util.HashMap, String)}.\n*\n* Features values are strings and their values must meet restrictions described in their\n* documentation.\n*\n* @param locale The locale to query features for.\n* @return Set instance. May return {@code null} on error.\n* @deprecated As of API level 21, please use voices. In order to query features of the voice,\n* call {@link #getVoices()} to retrieve the list of available voices and\n* {@link Voice#getFeatures()} to retrieve the set of features.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getVoices()", "methodReturn": "Set<String>", "isValid": true, "cleanReplacement": "getVoices()", "fullMethod": "Set<String> getFeatures(Locale)", "method": "getFeatures(Locale)"}, "unregisterRemoteController": {"methodClass": "android.media.AudioManager", "methodName": "unregisterRemoteController", "replacementComments": "/**\n* Unregisters a {@link RemoteController}, causing it to no longer receive\n* media metadata and playback state information, and no longer be capable\n* of controlling playback.\n*\n* @param rctlr the object to unregister.\n* @deprecated Use\n* {@link MediaSessionManager#removeOnActiveSessionsChangedListener(android.media.session.MediaSessionManager.OnActiveSessionsChangedListener)}\n* instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "MediaSessionManager#removeOnActiveSessionsChangedListener(android.media.session.MediaSessionManager.OnActiveSessionsChangedListener)", "methodReturn": "void", "isValid": true, "cleanReplacement": "removeOnActiveSessionsChangedListener(android.media.session.MediaSessionManager.OnActiveSessionsChangedListener)", "fullMethod": "void unregisterRemoteController(RemoteController)", "method": "unregisterRemoteController(RemoteController)"}, "setActivated": {"methodClass": "androidx.core.view.ViewCompat", "methodName": "setActivated", "replacementComments": "/**\n* Changes the activated state of this view. A view can be activated or not.\n* Note that activation is not the same as selection.  Selection is\n* a transient property, representing the view (hierarchy) the user is\n* currently interacting with.  Activation is a longer-term state that the\n* user can move views in and out of.\n*\n* @param activated true if the view must be activated, false otherwise\n*\n* @deprecated Use {@link View#setActivated(boolean)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "View#setActivated(boolean)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setActivated(boolean)", "fullMethod": "void setActivated(View,boolean)", "method": "setActivated(View,boolean)"}, "createSettingsIntent": {"methodClass": "android.media.tv.TvInputInfo", "methodName": "createSettingsIntent", "replacementComments": "/**\n* Returns an intent to start the settings activity for this TV input.\n*\n* @deprecated Use {@link #createSetupIntent()} instead. Settings activity is deprecated.\n* Use setup activity instead to provide settings.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "createSetupIntent()", "methodReturn": "Intent", "isValid": true, "cleanReplacement": "createSetupIntent()", "fullMethod": "Intent createSettingsIntent()", "method": "createSettingsIntent()"}, "fromHtml": {"methodClass": "android.text.Html", "methodName": "fromHtml", "replacementComments": "/**\n* Returns displayable styled text from the provided HTML string with the legacy flags\n* {@link #FROM_HTML_MODE_LEGACY}.\n*\n* @deprecated use {@link #fromHtml(String, int)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "fromHtml(String, int)", "methodReturn": "Spanned", "isValid": true, "cleanReplacement": "fromHtml(String, int)", "fullMethod": "Spanned fromHtml(String)", "method": "fromHtml(String)"}, "getPivotY": {"methodClass": "androidx.core.view.ViewCompat", "methodName": "getPivotY", "replacementComments": "/**\n* The y location of the point around which the view is {@link #setRotation(View,\n* float) rotated} and {@link #setScaleY(View, float) scaled}.\n*\n* @return The y location of the pivot point.\n*\n* @deprecated Use {@link View#getPivotY()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "View#getPivotY()", "methodReturn": "float", "isValid": true, "cleanReplacement": "getPivotY()", "fullMethod": "float getPivotY(View)", "method": "getPivotY(View)"}, "getPivotX": {"methodClass": "androidx.core.view.ViewCompat", "methodName": "getPivotX", "replacementComments": "/**\n* The x location of the point around which the view is\n* {@link #setRotation(View, float) rotated} and {@link #setScaleX(View, float) scaled}.\n*\n* @deprecated Use {@link View#getPivotX()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "View#getPivotX()", "methodReturn": "float", "isValid": true, "cleanReplacement": "getPivotX()", "fullMethod": "float getPivotX(View)", "method": "getPivotX(View)"}, "setScrollY": {"methodClass": "androidx.core.view.accessibility.AccessibilityRecordCompat", "methodName": "setScrollY", "replacementComments": "/**\n* Sets the scroll offset of the source top edge in pixels.\n*\n* @param scrollY The scroll.\n*\n* @deprecated Use {@link AccessibilityRecord#setScrollY(int)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityRecord#setScrollY(int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "AccessibilityRecord#setScrollY(int)", "fullMethod": "void setScrollY(int)", "method": "setScrollY(int)"}, "setScrollX": {"methodClass": "androidx.core.view.accessibility.AccessibilityRecordCompat", "methodName": "setScrollX", "replacementComments": "/**\n* Sets the scroll offset of the source left edge in pixels.\n*\n* @param scrollX The scroll.\n*\n* @deprecated Use {@link AccessibilityRecord#setScrollX(int)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityRecord#setScrollX(int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "AccessibilityRecord#setScrollX(int)", "fullMethod": "void setScrollX(int)", "method": "setScrollX(int)"}, "writeString": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writeString", "replacementComments": "/**\n* Write a single proto \"string\" type field value.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writeString(long,String)", "method": "writeString(long,String)"}, "getDrawableForDensity": {"methodClass": "android.content.res.Resources", "methodName": "getDrawableForDensity", "replacementComments": "/**\n* Return a drawable object associated with a particular resource ID for the\n* given screen density in DPI. This will set the drawable's density to be\n* the device's density multiplied by the ratio of actual drawable density\n* to requested density. This allows the drawable to be scaled up to the\n* correct size if needed. Various types of objects will be returned\n* depending on the underlying resource -- for example, a solid color, PNG\n* image, scalable image, etc. The Drawable API hides these implementation\n* details.\n*\n* <p class=\"note\"><strong>Note:</strong> To obtain a themed drawable, use\n* {@link android.content.Context#getDrawable(int) Context.getDrawable(int)}\n* or {@link #getDrawableForDensity(int, int, Theme)} passing the desired\n* theme.</p>\n*\n* @param id The desired resource identifier, as generated by the aapt tool.\n* This integer encodes the package, type, and resource entry.\n* The value 0 is an invalid identifier.\n* @param density the desired screen density indicated by the resource as\n* found in {@link DisplayMetrics}. A value of 0 means to use the\n* density returned from {@link #getConfiguration()}.\n* This is equivalent to calling {@link #getDrawable(int)}.\n* @return Drawable An object that can be used to draw this resource.\n* @throws NotFoundException Throws NotFoundException if the given ID does\n* not exist.\n* @see #getDrawableForDensity(int, int, Theme)\n* @deprecated Use {@link #getDrawableForDensity(int, int, Theme)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getDrawableForDensity(int, int, Theme)", "methodReturn": "Drawable", "isValid": true, "cleanReplacement": "getDrawableForDensity(int, int, Theme)", "fullMethod": "Drawable getDrawableForDensity(int,int)", "method": "getDrawableForDensity(int,int)"}, "requestSendAccessibilityEvent": {"methodClass": "androidx.core.view.ViewParentCompat", "methodName": "requestSendAccessibilityEvent", "replacementComments": "/**\n* Called by a child to request from its parent to send an {@link AccessibilityEvent}.\n* The child has already populated a record for itself in the event and is delegating\n* to its parent to send the event. The parent can optionally add a record for itself.\n* <p>\n* Note: An accessibility event is fired by an individual view which populates the\n* event with a record for its state and requests from its parent to perform\n* the sending. The parent can optionally add a record for itself before\n* dispatching the request to its parent. A parent can also choose not to\n* respect the request for sending the event. The accessibility event is sent\n* by the topmost view in the view tree.</p>\n*\n* @param parent The parent whose method to invoke.\n* @param child The child which requests sending the event.\n* @param event The event to be sent.\n* @return True if the event was sent.\n*\n* @deprecated Use {@link ViewParent#requestSendAccessibilityEvent(View, AccessibilityEvent)}\n* directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "ViewParent#requestSendAccessibilityEvent(View, AccessibilityEvent)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "requestSendAccessibilityEvent(View, AccessibilityEvent)", "fullMethod": "boolean requestSendAccessibilityEvent(ViewParent,View,AccessibilityEvent)", "method": "requestSendAccessibilityEvent(ViewParent,View,AccessibilityEvent)"}, "formatJapaneseNumber": {"methodClass": "android.telephony.PhoneNumberUtils", "methodName": "formatJapaneseNumber", "replacementComments": "/**\n* Formats a phone number in-place using the Japanese formatting rules.\n* Numbers will be formatted as:\n*\n* <p><code>\n* 03-xxxx-xxxx\n* 090-xxxx-xxxx\n* 0120-xxx-xxx\n* +81-3-xxxx-xxxx\n* +81-90-xxxx-xxxx\n* </code></p>\n*\n* @param text the number to be formatted, will be modified with\n* the formatting\n*\n* @deprecated Use link #formatNumber(String phoneNumber, String defaultCountryIso) instead\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "link #formatNumber(String phoneNumber, String defaultCountryIso)", "methodReturn": "void", "isValid": true, "cleanReplacement": "formatNumber(String phoneNumber, String defaultCountryIso)", "fullMethod": "void formatJapaneseNumber(Editable)", "method": "formatJapaneseNumber(Editable)"}, "setSubjectMatch": {"methodClass": "android.net.wifi.WifiEnterpriseConfig", "methodName": "setSubjectMatch", "replacementComments": "/**\n* Set subject match (deprecated). This is the substring to be matched against the subject of\n* the authentication server certificate.\n* @param subjectMatch substring to be matched\n* @deprecated in favor of altSubjectMatch\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "altSubjectMatch", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void setSubjectMatch(String)", "method": "setSubjectMatch(String)"}, "toHtml": {"methodClass": "android.text.Html", "methodName": "toHtml", "replacementComments": "/**\n* @deprecated use {@link #toHtml(Spanned, int)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "toHtml(Spanned, int)", "methodReturn": "String", "isValid": true, "cleanReplacement": "toHtml(Spanned, int)", "fullMethod": "String toHtml(Spanned)", "method": "toHtml(Spanned)"}, "setPermissionCompatDelegate": {"methodClass": "androidx.legacy.app.FragmentCompat", "methodName": "setPermissionCompatDelegate", "replacementComments": "/**\n* Sets the permission delegate for {@code FragmentCompat}. Replaces the previously set\n* delegate.\n*\n* @param delegate The delegate to be set. {@code null} to clear the set delegate.\n*\n* @deprecated Use {@link androidx.fragment.app.Fragment} instead of the framework\n* {@link Fragment}.\n*/\n", "isClassDeprecated": true, "dirtyReplacement": "androidx.fragment.app.Fragment", "methodReturn": "void", "isValid": true, "cleanReplacement": "androidx.fragment.app.Fragment", "fullMethod": "void setPermissionCompatDelegate(PermissionCompatDelegate)", "method": "setPermissionCompatDelegate(PermissionCompatDelegate)"}, "defineClass": {"methodClass": "java.lang.ClassLoader", "methodName": "defineClass", "replacementComments": "/**\n* Converts an array of bytes into an instance of class <tt>Class</tt>.\n* Before the <tt>Class</tt> can be used it must be resolved.  This method\n* is deprecated in favor of the version that takes a <a\n* href=\"#name\">binary name</a> as its first argument, and is more secure.\n*\n* @param  b\n* The bytes that make up the class data.  The bytes in positions\n* <tt>off</tt> through <tt>off+len-1</tt> should have the format\n* of a valid class file as defined by\n* <cite>The Java&trade; Virtual Machine Specification</cite>.\n*\n* @param  off\n* The start offset in <tt>b</tt> of the class data\n*\n* @param  len\n* The length of the class data\n*\n* @return  The <tt>Class</tt> object that was created from the specified\n* class data\n*\n* @throws  ClassFormatError\n* If the data did not contain a valid class\n*\n* @throws  IndexOutOfBoundsException\n* If either <tt>off</tt> or <tt>len</tt> is negative, or if\n* <tt>off+len</tt> is greater than <tt>b.length</tt>.\n*\n* @throws  SecurityException\n* If an attempt is made to add this class to a package that\n* contains classes that were signed by a different set of\n* certificates than this class, or if an attempt is made\n* to define a class in a package with a fully-qualified name\n* that starts with \"{@code java.}\".\n*\n* @see  #loadClass(String, boolean)\n* @see  #resolveClass(Class)\n*\n* @deprecated  Replaced by {@link #defineClass(String, byte[], int, int)\n* defineClass(String, byte[], int, int)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "defineClass(String, byte[], int, int)  defineClass(String, byte[], int, int)", "methodReturn": "Class<?>", "isValid": true, "cleanReplacement": "defineClass(String, byte[], int, int)  defineClass(String, byte[], int, int)", "fullMethod": "Class<?> defineClass(byte[],int,int)", "method": "defineClass(byte[],int,int)"}, "getFormatTypeForLocale": {"methodClass": "android.telephony.PhoneNumberUtils", "methodName": "getFormatTypeForLocale", "replacementComments": "/**\n* Returns the phone number formatting type for the given locale.\n*\n* @param locale The locale of interest, usually {@link Locale#getDefault()}\n* @return The formatting type for the given locale, or FORMAT_UNKNOWN if the formatting\n* rules are not known for the given locale\n*\n* @deprecated Use link #formatNumber(String phoneNumber, String defaultCountryIso) instead\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "link #formatNumber(String phoneNumber, String defaultCountryIso)", "methodReturn": "int", "isValid": true, "cleanReplacement": "formatNumber(String phoneNumber, String defaultCountryIso)", "fullMethod": "int getFormatTypeForLocale(Locale)", "method": "getFormatTypeForLocale(Locale)"}, "writeEnum": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writeEnum", "replacementComments": "/**\n* Write a single proto enum type field value.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writeEnum(long,int)", "method": "writeEnum(long,int)"}, "onRequestPermissionsResult": {"methodClass": "androidx.legacy.app.FragmentCompat.OnRequestPermissionsResultCallback", "methodName": "onRequestPermissionsResult", "replacementComments": "/**\n* Callback for the result from requesting permissions. This method\n* is invoked for every call on {@link #requestPermissions(android.app.Fragment,\n* String[], int)}\n*\n* @param requestCode The request code passed in {@link #requestPermissions(\n* android.app.Fragment, String[], int)}\n* @param permissions The requested permissions. Never null.\n* @param grantResults The grant results for the corresponding permissions\n* which is either {@link android.content.pm.PackageManager#PERMISSION_GRANTED}\n* or {@link android.content.pm.PackageManager#PERMISSION_DENIED}. Never null.\n*\n* @see #requestPermissions(android.app.Fragment, String[], int)\n*\n* @deprecated Use {@link androidx.fragment.app.Fragment} instead of the framework\n* {@link Fragment}.\n*/\n", "isClassDeprecated": true, "dirtyReplacement": "androidx.fragment.app.Fragment", "methodReturn": "void", "isValid": true, "cleanReplacement": "androidx.fragment.app.Fragment", "fullMethod": "void onRequestPermissionsResult(int,String[],int[])", "method": "onRequestPermissionsResult(int,String[],int[])"}, "setProgressBackgroundColor": {"methodClass": "androidx.swiperefreshlayout.widget.SwipeRefreshLayout", "methodName": "setProgressBackgroundColor", "replacementComments": "/**\n* @deprecated Use {@link #setProgressBackgroundColorSchemeResource(int)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setProgressBackgroundColorSchemeResource(int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setProgressBackgroundColorSchemeResource(int)", "fullMethod": "void setProgressBackgroundColor(int)", "method": "setProgressBackgroundColor(int)"}, "endRepeatedObject": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "endRepeatedObject", "replacementComments": "/**\n* End a child object. Pass in the token from the correspoinding startRepeatedObject call.\n*\n* @deprecated Use #end() instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "end()", "methodReturn": "void", "isValid": true, "cleanReplacement": "end()", "fullMethod": "void endRepeatedObject(long)", "method": "endRepeatedObject(long)"}, "writeRepeatedBytes": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writeRepeatedBytes", "replacementComments": "/**\n* Write a single repeated proto \"bytes\" type field value.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writeRepeatedBytes(long,byte[])", "method": "writeRepeatedBytes(long,byte[])"}, "untagSocket": {"methodClass": "androidx.core.net.TrafficStatsCompat", "methodName": "untagSocket", "replacementComments": "/**\n* Remove any statistics parameters from the given {@link Socket}.\n*\n* @deprecated Use {@link TrafficStats#untagSocket(Socket)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "TrafficStats#untagSocket(Socket)", "methodReturn": "void", "isValid": true, "cleanReplacement": "TrafficStats#untagSocket(Socket)", "fullMethod": "void untagSocket(Socket)", "method": "untagSocket(Socket)"}, "getUniversalPinState": {"methodClass": "com.android.internal.telephony.uicc.UiccCard", "methodName": "getUniversalPinState", "replacementComments": "/**\n* @deprecated Please use {@link UiccProfile#getUniversalPinState()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "UiccProfile#getUniversalPinState()", "methodReturn": "PinState", "isValid": true, "cleanReplacement": "UiccProfile#getUniversalPinState()", "fullMethod": "PinState getUniversalPinState()", "method": "getUniversalPinState()"}, "getRecord": {"methodClass": "androidx.core.view.accessibility.AccessibilityEventCompat", "methodName": "getRecord", "replacementComments": "/**\n* Gets the record at a given index.\n*\n* @param index The index.\n* @return The record at the specified index.\n*\n* @deprecated Use {@link AccessibilityEvent#getRecord(int)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityEvent#getRecord(int)", "methodReturn": "AccessibilityRecordCompat", "isValid": true, "cleanReplacement": "getRecord(int)", "fullMethod": "AccessibilityRecordCompat getRecord(AccessibilityEvent,int)", "method": "getRecord(AccessibilityEvent,int)"}, "onNestedPreScroll": {"methodClass": "androidx.coordinatorlayout.widget.CoordinatorLayout.Behavior", "methodName": "onNestedPreScroll", "replacementComments": "/**\n* @deprecated You should now override\n* {@link #onNestedPreScroll(CoordinatorLayout, View, View, int, int, int[], int)}.\n* This method will still continue to be called if the type is\n* {@link ViewCompat#TYPE_TOUCH}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "onNestedPreScroll(CoordinatorLayout, View, View, int, int, int[], int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "onNestedPreScroll(CoordinatorLayout, View, View, int, int, int[], int)", "fullMethod": "void onNestedPreScroll(CoordinatorLayout,V,View,int,int,int[])", "method": "onNestedPreScroll(CoordinatorLayout,V,View,int,int,int[])"}, "getItemOffsets": {"methodClass": "androidx.recyclerview.widget.RecyclerView.ItemDecoration", "methodName": "getItemOffsets", "replacementComments": "/**\n* @deprecated\n* Use {@link #getItemOffsets(Rect, View, RecyclerView, State)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getItemOffsets(Rect, View, RecyclerView, State)", "methodReturn": "void", "isValid": true, "cleanReplacement": "getItemOffsets(Rect, View, RecyclerView, State)", "fullMethod": "void getItemOffsets(Rect,int,RecyclerView)", "method": "getItemOffsets(Rect,int,RecyclerView)"}, "getUidTcpRxBytes": {"methodClass": "android.net.TrafficStats", "methodName": "getUidTcpRxBytes", "replacementComments": "/**\n* @deprecated Starting in {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2},\n* transport layer statistics are no longer available, and will\n* always return {@link #UNSUPPORTED}.\n* @see #getUidRxBytes(int)\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getUidRxBytes(int)", "methodReturn": "long", "isValid": true, "cleanReplacement": "getUidRxBytes(int)", "fullMethod": "long getUidTcpRxBytes(int)", "method": "getUidTcpRxBytes(int)"}, "write": {"methodClass": "java.io.ObjectOutputStream.PutField", "methodName": "write", "replacementComments": "/**\n* Write the data and fields to the specified ObjectOutput stream,\n* which must be the same stream that produced this\n* <code>PutField</code> object.\n*\n* @param  out the stream to write the data and fields to\n* @throws IOException if I/O errors occur while writing to the\n* underlying stream\n* @throws IllegalArgumentException if the specified stream is not\n* the same stream that produced this <code>PutField</code>\n* object\n* @deprecated This method does not write the values contained by this\n* <code>PutField</code> object in a proper format, and may\n* result in corruption of the serialization stream.  The\n* correct way to write <code>PutField</code> data is by\n* calling the {@link java.io.ObjectOutputStream#writeFields()}\n* method.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "java.io.ObjectOutputStream#writeFields()", "methodReturn": "void", "isValid": true, "cleanReplacement": "writeFields()", "fullMethod": "void write(ObjectOutput)", "method": "write(ObjectOutput)"}, "getFragmentManager": {"methodClass": "android.app.Activity", "methodName": "getFragmentManager", "replacementComments": "/**\n* Return the FragmentManager for interacting with fragments associated\n* with this activity.\n*\n* @deprecated Use {@link android.support.v4.app.FragmentActivity#getSupportFragmentManager()}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "android.support.v4.app.FragmentActivity#getSupportFragmentManager()", "methodReturn": "FragmentManager", "isValid": true, "cleanReplacement": "getSupportFragmentManager()", "fullMethod": "FragmentManager getFragmentManager()", "method": "getFragmentManager()"}, "shouldClearTask": {"methodClass": "androidx.navigation.NavOptions", "methodName": "shouldClearTask", "replacementComments": "/**\n* Whether this navigation action should clear the entire back stack\n* <p>\n* This functions similarly to how {@link android.content.Intent#FLAG_ACTIVITY_CLEAR_TASK}\n* works with activites.\n* @deprecated This is synonymous with {@link #getPopUpTo()} with the root of the graph and\n* using {@link #isPopUpToInclusive()}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getPopUpTo()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "getPopUpTo()", "fullMethod": "boolean shouldClearTask()", "method": "shouldClearTask()"}, "getColorStateList": {"methodClass": "android.content.res.Resources", "methodName": "getColorStateList", "replacementComments": "/**\n* Returns a color state list associated with a particular resource ID. The\n* resource may contain either a single raw color value or a complex\n* {@link ColorStateList} holding multiple possible colors.\n*\n* @param id The desired resource identifier of a {@link ColorStateList},\n* as generated by the aapt tool. This integer encodes the\n* package, type, and resource entry. The value 0 is an invalid\n* identifier.\n*\n* @throws NotFoundException Throws NotFoundException if the given ID does\n* not exist.\n*\n* @return A ColorStateList object containing either a single solid color\n* or multiple colors that can be selected based on a state.\n* @deprecated Use {@link #getColorStateList(int, Theme)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getColorStateList(int, Theme)", "methodReturn": "ColorStateList", "isValid": true, "cleanReplacement": "getColorStateList(int, Theme)", "fullMethod": "ColorStateList getColorStateList(int)", "method": "getColorStateList(int)"}, "inflateTitle": {"methodClass": "androidx.leanback.app.DetailsSupportFragment", "methodName": "inflateTitle", "replacementComments": "/**\n* @deprecated override {@link #onInflateTitleView(LayoutInflater,ViewGroup,Bundle)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "onInflateTitleView(LayoutInflater,ViewGroup,Bundle)", "methodReturn": "View", "isValid": true, "cleanReplacement": "onInflateTitleView(LayoutInflater,ViewGroup,Bundle)", "fullMethod": "View inflateTitle(LayoutInflater,ViewGroup,Bundle)", "method": "inflateTitle(LayoutInflater,ViewGroup,Bundle)"}, "getData": {"methodClass": "android.app.StatsManager", "methodName": "getData", "replacementComments": "/**\n* @deprecated Use {@link #getReports(long)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getReports(long)", "methodReturn": "byte[]", "isValid": true, "cleanReplacement": "getReports(long)", "fullMethod": "byte[] getData(long)", "method": "getData(long)"}, "isTtyModeSupported": {"methodClass": "android.telephony.TelephonyManager", "methodName": "isTtyModeSupported", "replacementComments": "/**\n* @deprecated Use {@link TelecomManager#isTtySupported()} instead\n* Whether the phone supports TTY mode.\n*\n* @return {@code true} if the device supports TTY mode, and {@code false} otherwise.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "TelecomManager#isTtySupported()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "isTtySupported()", "fullMethod": "boolean isTtyModeSupported()", "method": "isTtyModeSupported()"}, "queryGroups": {"methodClass": "android.provider.Contacts.People", "methodName": "queryGroups", "replacementComments": "/**\n* @deprecated see {@link android.provider.ContactsContract}\n*/\n", "isClassDeprecated": true, "dirtyReplacement": "android.provider.ContactsContract", "methodReturn": "Cursor", "isValid": true, "cleanReplacement": "android.provider.ContactsContract", "fullMethod": "Cursor queryGroups(ContentResolver,long)", "method": "queryGroups(ContentResolver,long)"}, "iccExchangeSimIO": {"methodClass": "com.android.internal.telephony.uicc.UiccCard", "methodName": "iccExchangeSimIO", "replacementComments": "/**\n* Exposes {@link CommandsInterface#iccIO}\n* @deprecated Please use\n* {@link UiccProfile#iccExchangeSimIO(int, int, int, int, int, String, Message)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "UiccProfile#iccExchangeSimIO(int, int, int, int, int, String, Message)", "methodReturn": "void", "isValid": true, "cleanReplacement": "iccExchangeSimIO(int, int, int, int, int, String, Message)", "fullMethod": "void iccExchangeSimIO(int,int,int,int,int,String,Message)", "method": "iccExchangeSimIO(int,int,int,int,int,String,Message)"}, "setStreamSolo": {"methodClass": "android.media.AudioManager", "methodName": "setStreamSolo", "replacementComments": "/**\n* Solo or unsolo a particular stream.\n* <p>\n* Do not use. This method has been deprecated and is now a no-op.\n* {@link #requestAudioFocus} should be used for exclusive audio playback.\n*\n* @param streamType The stream to be soloed/unsoloed.\n* @param state The required solo state: true for solo ON, false for solo\n* OFF\n* @see #isVolumeFixed()\n* @deprecated Do not use. If you need exclusive audio playback use\n* {@link #requestAudioFocus}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "requestAudioFocus", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void setStreamSolo(int,boolean)", "method": "setStreamSolo(int,boolean)"}, "updateConfiguration": {"methodClass": "android.content.res.Resources", "methodName": "updateConfiguration", "replacementComments": "/**\n* Store the newly updated configuration.\n*\n* @deprecated See {@link android.content.Context#createConfigurationContext(Configuration)}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "android.content.Context#createConfigurationContext(Configuration)", "methodReturn": "void", "isValid": true, "cleanReplacement": "createConfigurationContext(Configuration)", "fullMethod": "void updateConfiguration(Configuration,DisplayMetrics)", "method": "updateConfiguration(Configuration,DisplayMetrics)"}, "getContentDescription": {"methodClass": "androidx.core.view.accessibility.AccessibilityRecordCompat", "methodName": "getContentDescription", "replacementComments": "/**\n* Gets the description of the source.\n*\n* @return The description.\n*\n* @deprecated Use {@link AccessibilityRecord#getContentDescription()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityRecord#getContentDescription()", "methodReturn": "CharSequence", "isValid": true, "cleanReplacement": "AccessibilityRecord#getContentDescription()", "fullMethod": "CharSequence getContentDescription()", "method": "getContentDescription()"}, "showStatusIcon": {"methodClass": "android.view.inputmethod.InputMethodManager", "methodName": "showStatusIcon", "replacementComments": "/**\n* @deprecated Use {@link InputMethodService#showStatusIcon(int)} instead. This method was\n* intended for IME developers who should be accessing APIs through the service. APIs in this\n* class are intended for app developers interacting with the IME.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "InputMethodService#showStatusIcon(int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "showStatusIcon(int)", "fullMethod": "void showStatusIcon(IBinder,String,int)", "method": "showStatusIcon(IBinder,String,int)"}, "exitKeyguardSecurely": {"methodClass": "android.app.KeyguardManager", "methodName": "exitKeyguardSecurely", "replacementComments": "/**\n* @deprecated Use {@link LayoutParams#FLAG_DISMISS_KEYGUARD}\n* and/or {@link LayoutParams#FLAG_SHOW_WHEN_LOCKED}\n* instead; this allows you to seamlessly hide the keyguard as your application\n* moves in and out of the foreground and does not require that any special\n* permissions be requested.\n*\n* Exit the keyguard securely.  The use case for this api is that, after\n* disabling the keyguard, your app, which was granted permission to\n* disable the keyguard and show a limited amount of information deemed\n* safe without the user getting past the keyguard, needs to navigate to\n* something that is not safe to view without getting past the keyguard.\n*\n* This will, if the keyguard is secure, bring up the unlock screen of\n* the keyguard.\n*\n* @param callback Let's you know whether the operation was succesful and\n* it is safe to launch anything that would normally be considered safe\n* once the user has gotten past the keyguard.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "LayoutParams#FLAG_DISMISS_KEYGUARD", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void exitKeyguardSecurely(OnKeyguardExitResult)", "method": "exitKeyguardSecurely(OnKeyguardExitResult)"}, "isAvailable": {"methodClass": "android.net.NetworkInfo", "methodName": "isAvailable", "replacementComments": "/**\n* Indicates whether network connectivity is possible. A network is unavailable\n* when a persistent or semi-persistent condition prevents the possibility\n* of connecting to that network. Examples include\n* <ul>\n* <li>The device is out of the coverage area for any network of this type.</li>\n* <li>The device is on a network other than the home network (i.e., roaming), and\n* data roaming has been disabled.</li>\n* <li>The device's radio is turned off, e.g., because airplane mode is enabled.</li>\n* </ul>\n* Since Android L, this always returns {@code true}, because the system only\n* returns info for available networks.\n* @return {@code true} if the network is available, {@code false} otherwise\n* @deprecated Apps should instead use the\n* {@link android.net.ConnectivityManager.NetworkCallback} API to\n* learn about connectivity changes.\n* {@link ConnectivityManager#registerDefaultNetworkCallback} and\n* {@link ConnectivityManager#registerNetworkCallback}. These will\n* give a more accurate picture of the connectivity state of\n* the device and let apps react more easily and quickly to changes.\n*/\n", "isClassDeprecated": true, "dirtyReplacement": "android.net.ConnectivityManager.NetworkCallback", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "android.net.ConnectivityManager.NetworkCallback", "fullMethod": "boolean isAvailable()", "method": "isAvailable()"}, "getItemClickListener": {"methodClass": "android.widget.AutoCompleteTextView", "methodName": "getItemClickListener", "replacementComments": "/**\n* <p>Returns the listener that is notified whenever the user clicks an item\n* in the drop down list.</p>\n*\n* @return the item click listener\n*\n* @deprecated Use {@link #getOnItemClickListener()} intead\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getOnItemClickListener()", "methodReturn": "OnItemClickListener", "isValid": true, "cleanReplacement": "getOnItemClickListener()", "fullMethod": "OnItemClickListener getItemClickListener()", "method": "getItemClickListener()"}, "getMeasuredHeightAndState": {"methodClass": "androidx.core.view.ViewCompat", "methodName": "getMeasuredHeightAndState", "replacementComments": "/**\n* Return the full height measurement information for this view as computed\n* by the most recent call to {@link android.view.View#measure(int, int)}.\n* This result is a bit mask as defined by {@link #MEASURED_SIZE_MASK} and\n* {@link #MEASURED_STATE_TOO_SMALL}.\n* This should be used during measurement and layout calculations only. Use\n* {@link android.view.View#getHeight()} to see how wide a view is after layout.\n*\n* @return The measured width of this view as a bit mask.\n*\n* @deprecated Use {@link View#getMeasuredHeightAndState()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "View#getMeasuredHeightAndState()", "methodReturn": "int", "isValid": true, "cleanReplacement": "getMeasuredHeightAndState()", "fullMethod": "int getMeasuredHeightAndState(View)", "method": "getMeasuredHeightAndState(View)"}, "writePackedFixed64": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writePackedFixed64", "replacementComments": "/**\n* Write a list of packed proto \"fixed64\" type field value.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writePackedFixed64(long,long[])", "method": "writePackedFixed64(long,long[])"}, "showChild": {"methodClass": "android.animation.LayoutTransition", "methodName": "showChild", "replacementComments": "/**\n* @deprecated Use {@link #showChild(android.view.ViewGroup, android.view.View, int)}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "showChild(android.view.ViewGroup, android.view.View, int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "showChild(android.view.ViewGroup, android.view.View, int)", "fullMethod": "void showChild(ViewGroup,View)", "method": "showChild(ViewGroup,View)"}, "setTotalTimeLong": {"methodClass": "androidx.leanback.widget.PlaybackControlsRow", "methodName": "setTotalTimeLong", "replacementComments": "/**\n* Sets the total time in milliseconds (long type) for the playback controls row.\n* @param ms Total time in milliseconds of long type.\n* @deprecated Use {@link #setDuration(long)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setDuration(long)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setDuration(long)", "fullMethod": "void setTotalTimeLong(long)", "method": "setTotalTimeLong(long)"}, "setSupplementalIcon": {"methodClass": "androidx.car.widget.SeekbarListItem", "methodName": "setSupplementalIcon", "replacementComments": "/**\n* Sets {@code Supplemental Action} to be represented by an {@code Supplemental Icon}.\n*\n* @deprecated use either {@link #setSupplementalIcon(Drawable, boolean)} or\n* {@link #setSupplementalIcon(int, boolean)} and\n* {@link #setSupplementalIconListener(android.view.View.OnClickListener)}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setSupplementalIcon(Drawable, boolean)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setSupplementalIcon(Drawable, boolean)", "fullMethod": "void setSupplementalIcon(Drawable,boolean,OnClickListener)", "method": "setSupplementalIcon(Drawable,boolean,OnClickListener)"}, "startUpdate": {"methodClass": "androidx.viewpager.widget.PagerAdapter", "methodName": "startUpdate", "replacementComments": "/**\n* Called when a change in the shown pages is going to start being made.\n* @param container The containing View which is displaying this adapter's\n* page views.\n*\n* @deprecated Use {@link #startUpdate(ViewGroup)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "startUpdate(ViewGroup)", "methodReturn": "void", "isValid": true, "cleanReplacement": "startUpdate(ViewGroup)", "fullMethod": "void startUpdate(View)", "method": "startUpdate(View)"}, "isGraphic": {"methodClass": "android.text.TextUtils", "methodName": "isGraphic", "replacementComments": "/**\n* Returns whether this character is a printable character.\n*\n* This does not support non-BMP characters and should not be used.\n*\n* @deprecated Use {@link #isGraphic(CharSequence)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "isGraphic(CharSequence)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "isGraphic(CharSequence)", "fullMethod": "boolean isGraphic(char)", "method": "isGraphic(char)"}, "getMaximumDrawingCacheSize": {"methodClass": "android.view.ViewConfiguration", "methodName": "getMaximumDrawingCacheSize", "replacementComments": "/**\n* The maximum drawing cache size expressed in bytes.\n*\n* @return the maximum size of View's drawing cache expressed in bytes\n*\n* @deprecated Use {@link #getScaledMaximumDrawingCacheSize()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getScaledMaximumDrawingCacheSize()", "methodReturn": "int", "isValid": true, "cleanReplacement": "getScaledMaximumDrawingCacheSize()", "fullMethod": "int getMaximumDrawingCacheSize()", "method": "getMaximumDrawingCacheSize()"}, "getCertificates": {"methodClass": "android.util.jar.StrictJarFile", "methodName": "getCertificates", "replacementComments": "/**\n* Return all certificates for a given {@link ZipEntry} belonging to this jar.\n* This method MUST be called only after fully exhausting the InputStream belonging\n* to this entry.\n*\n* Returns {@code null} if this jar file isn't signed or if this method is\n* called before the stream is processed.\n*\n* @deprecated Switch callers to use getCertificateChains instead\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getCertificateChains", "methodReturn": "Certificate[]", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "Certificate[] getCertificates(ZipEntry)", "method": "getCertificates(ZipEntry)"}, "getButtonState": {"methodClass": "androidx.core.view.MotionEventCompat", "methodName": "getButtonState", "replacementComments": "/**\n* @deprecated Call {@link MotionEvent#getButtonState()} directly. This method will be\n* removed in a future release.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "MotionEvent#getButtonState()", "methodReturn": "int", "isValid": true, "cleanReplacement": "getButtonState()", "fullMethod": "int getButtonState(MotionEvent)", "method": "getButtonState(MotionEvent)"}, "getLocale": {"methodClass": "android.text.style.SuggestionSpan", "methodName": "getLocale", "replacementComments": "/**\n* @deprecated use {@link #getLocaleObject()} instead.\n* @return the locale of the suggestions. An empty string is returned if no locale is specified.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getLocaleObject()", "methodReturn": "String", "isValid": true, "cleanReplacement": "getLocaleObject()", "fullMethod": "String getLocale()", "method": "getLocale()"}, "setVtSetting": {"methodClass": "com.android.ims.ImsManager", "methodName": "setVtSetting", "replacementComments": "/**\n* Change persistent VT enabled setting\n*\n* @deprecated Does not support MSIM devices. Please use {@link #setVtSetting(boolean)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setVtSetting(boolean)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setVtSetting(boolean)", "fullMethod": "void setVtSetting(Context,boolean)", "method": "setVtSetting(Context,boolean)"}, "hideProgressBar": {"methodClass": "com.android.setupwizardlib.SetupWizardLayout", "methodName": "hideProgressBar", "replacementComments": "/**\n* @deprecated Use {@link #setProgressBarShown(boolean)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setProgressBarShown(boolean)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setProgressBarShown(boolean)", "fullMethod": "void hideProgressBar()", "method": "hideProgressBar()"}, "setOnUtteranceCompletedListener": {"methodClass": "android.speech.tts.TextToSpeech", "methodName": "setOnUtteranceCompletedListener", "replacementComments": "/**\n* Sets the listener that will be notified when synthesis of an utterance completes.\n*\n* @param listener The listener to use.\n*\n* @return {@link #ERROR} or {@link #SUCCESS}.\n*\n* @deprecated Use {@link #setOnUtteranceProgressListener(UtteranceProgressListener)}\n* instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setOnUtteranceProgressListener(UtteranceProgressListener)", "methodReturn": "int", "isValid": true, "cleanReplacement": "setOnUtteranceProgressListener(UtteranceProgressListener)", "fullMethod": "int setOnUtteranceCompletedListener(OnUtteranceCompletedListener)", "method": "setOnUtteranceCompletedListener(OnUtteranceCompletedListener)"}, "sendStickyOrderedBroadcastAsUser": {"methodClass": "android.content.Context", "methodName": "sendStickyOrderedBroadcastAsUser", "replacementComments": "/**\n* <p>Version of\n* {@link #sendStickyOrderedBroadcast(Intent, BroadcastReceiver, Handler, int, String, Bundle)}\n* that allows you to specify the\n* user the broadcast will be sent to.  This is not available to applications\n* that are not pre-installed on the system image.\n*\n* <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.\n*\n* @deprecated Sticky broadcasts should not be used.  They provide no security (anyone\n* can access them), no protection (anyone can modify them), and many other problems.\n* The recommended pattern is to use a non-sticky broadcast to report that <em>something</em>\n* has changed, with another mechanism for apps to retrieve the current value whenever\n* desired.\n*\n* @param intent The Intent to broadcast; all receivers matching this\n* Intent will receive the broadcast.\n* @param user UserHandle to send the intent to.\n* @param resultReceiver Your own BroadcastReceiver to treat as the final\n* receiver of the broadcast.\n* @param scheduler A custom Handler with which to schedule the\n* resultReceiver callback; if null it will be\n* scheduled in the Context's main thread.\n* @param initialCode An initial value for the result code.  Often\n* Activity.RESULT_OK.\n* @param initialData An initial value for the result data.  Often\n* null.\n* @param initialExtras An initial value for the result extras.  Often\n* null.\n*\n* @see #sendStickyOrderedBroadcast(Intent, BroadcastReceiver, Handler, int, String, Bundle)\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "sendStickyOrderedBroadcast(Intent,", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void sendStickyOrderedBroadcastAsUser(Intent,UserHandle,BroadcastReceiver,Handler,int,String,Bundle)", "method": "sendStickyOrderedBroadcastAsUser(Intent,UserHandle,BroadcastReceiver,Handler,int,String,Bundle)"}, "onAttachedToWindow": {"methodClass": "androidx.legacy.app.FragmentTabHost", "methodName": "onAttachedToWindow", "replacementComments": "/**\n* @deprecated Use {@link androidx.fragment.app.FragmentTabHost} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "androidx.fragment.app.FragmentTabHost", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void onAttachedToWindow()", "method": "onAttachedToWindow()"}, "hasDrawnLw": {"methodClass": "com.android.server.policy.WindowManagerPolicy.WindowState", "methodName": "hasDrawnLw", "replacementComments": "/**\n* Returns true if this window has been shown on screen at some time in\n* the past.  Must be called with the window manager lock held.\n*\n* @deprecated Use {@link #isDrawnLw} or any of the other drawn/visibility methods.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "isDrawnLw", "methodReturn": "boolean", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "boolean hasDrawnLw()", "method": "hasDrawnLw()"}, "getEdgeSlop": {"methodClass": "android.view.ViewConfiguration", "methodName": "getEdgeSlop", "replacementComments": "/**\n* @return Inset in dips to look for touchable content when the user touches the edge of the\n* screen\n*\n* @deprecated Use {@link #getScaledEdgeSlop()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getScaledEdgeSlop()", "methodReturn": "int", "isValid": true, "cleanReplacement": "getScaledEdgeSlop()", "fullMethod": "int getEdgeSlop()", "method": "getEdgeSlop()"}, "setStereoVolume": {"methodClass": "android.media.AudioTrack", "methodName": "setStereoVolume", "replacementComments": "/**\n* Sets the specified left and right output gain values on the AudioTrack.\n* <p>Gain values are clamped to the closed interval [0.0, max] where\n* max is the value of {@link #getMaxVolume}.\n* A value of 0.0 results in zero gain (silence), and\n* a value of 1.0 means unity gain (signal unchanged).\n* The default value is 1.0 meaning unity gain.\n* <p>The word \"volume\" in the API name is historical; this is actually a linear gain.\n* @param leftGain output gain for the left channel.\n* @param rightGain output gain for the right channel\n* @return error code or success, see {@link #SUCCESS},\n* {@link #ERROR_INVALID_OPERATION}\n* @deprecated Applications should use {@link #setVolume} instead, as it\n* more gracefully scales down to mono, and up to multi-channel content beyond stereo.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setVolume", "methodReturn": "int", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "int setStereoVolume(float,float)", "method": "setStereoVolume(float,float)"}, "setClearTask": {"methodClass": "androidx.navigation.NavOptions.Builder", "methodName": "setClearTask", "replacementComments": "/**\n* Clear the entire task before launching this target. If you are launching as a\n* {@link #setLaunchDocument(boolean) document}, this will clear the document task.\n* Otherwise it will clear the current task.\n*\n* @param clearTask\n* @return\n* @deprecated Use {@link #setPopUpTo(int, boolean)} with the\n* {@link NavDestination#getId() id} of the\n* {@link androidx.navigation.NavController#getGraph() NavController's graph}\n* and set inclusive to true.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setPopUpTo(int, boolean)", "methodReturn": "Builder", "isValid": true, "cleanReplacement": "setPopUpTo(int, boolean)", "fullMethod": "Builder setClearTask(boolean)", "method": "setClearTask(boolean)"}, "writeSFixed64": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writeSFixed64", "replacementComments": "/**\n* Write a single proto \"sfixed64\" type field value.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writeSFixed64(long,long)", "method": "writeSFixed64(long,long)"}, "startObject": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "startObject", "replacementComments": "/**\n* Start a child object.\n*\n* Returns a token which should be passed to endObject.  Calls to endObject must be\n* nested properly.\n*\n* @deprecated Use #start() instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "start()", "methodReturn": "long", "isValid": true, "cleanReplacement": "start()", "fullMethod": "long startObject(long)", "method": "startObject(long)"}, "getUidTcpTxSegments": {"methodClass": "android.net.TrafficStats", "methodName": "getUidTcpTxSegments", "replacementComments": "/**\n* @deprecated Starting in {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2},\n* transport layer statistics are no longer available, and will\n* always return {@link #UNSUPPORTED}.\n* @see #getUidTxPackets(int)\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getUidTxPackets(int)", "methodReturn": "long", "isValid": true, "cleanReplacement": "getUidTxPackets(int)", "fullMethod": "long getUidTcpTxSegments(int)", "method": "getUidTcpTxSegments(int)"}, "resizeBitmapSize": {"methodClass": "com.android.internal.graphics.palette.Palette.Builder", "methodName": "resizeBitmapSize", "replacementComments": "/**\n* Set the resize value when using a {@link android.graphics.Bitmap} as the source.\n* If the bitmap's largest dimension is greater than the value specified, then the bitmap\n* will be resized so that its largest dimension matches {@code maxDimension}. If the\n* bitmap is smaller or equal, the original is used as-is.\n*\n* @deprecated Using {@link #resizeBitmapArea(int)} is preferred since it can handle\n* abnormal aspect ratios more gracefully.\n*\n* @param maxDimension the number of pixels that the max dimension should be scaled down to,\n* or any value <= 0 to disable resizing.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "resizeBitmapArea(int)", "methodReturn": "Builder", "isValid": true, "cleanReplacement": "resizeBitmapArea(int)", "fullMethod": "Builder resizeBitmapSize(int)", "method": "resizeBitmapSize(int)"}, "setOemUnlockEnabled": {"methodClass": "android.service.persistentdata.PersistentDataBlockManager", "methodName": "setOemUnlockEnabled", "replacementComments": "/**\n* Writes a byte enabling or disabling the ability to \"OEM unlock\" the device.\n*\n* @deprecated use {@link OemLockManager#setOemUnlockAllowedByUser(boolean)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "OemLockManager#setOemUnlockAllowedByUser(boolean)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setOemUnlockAllowedByUser(boolean)", "fullMethod": "void setOemUnlockEnabled(boolean)", "method": "setOemUnlockEnabled(boolean)"}, "playEarcon": {"methodClass": "android.speech.tts.TextToSpeech", "methodName": "playEarcon", "replacementComments": "/**\n* Plays the earcon using the specified queueing mode and parameters.\n* The earcon must already have been added with {@link #addEarcon(String, String)} or\n* {@link #addEarcon(String, String, int)}.\n* This method is asynchronous, i.e. the method just adds the request to the queue of TTS\n* requests and then returns. The synthesis might not have finished (or even started!) at the\n* time when this method returns. In order to reliably detect errors during synthesis,\n* we recommend setting an utterance progress listener (see\n* {@link #setOnUtteranceProgressListener}) and using the\n* {@link Engine#KEY_PARAM_UTTERANCE_ID} parameter.\n*\n* @param earcon The earcon that should be played\n* @param queueMode {@link #QUEUE_ADD} or {@link #QUEUE_FLUSH}.\n* @param params Parameters for the request. Can be null.\n* Supported parameter names:\n* {@link Engine#KEY_PARAM_STREAM},\n* {@link Engine#KEY_PARAM_UTTERANCE_ID}.\n* Engine specific parameters may be passed in but the parameter keys\n* must be prefixed by the name of the engine they are intended for. For example\n* the keys \"com.svox.pico_foo\" and \"com.svox.pico:bar\" will be passed to the\n* engine named \"com.svox.pico\" if it is being used.\n*\n* @return {@link #ERROR} or {@link #SUCCESS} of <b>queuing</b> the playEarcon operation.\n* @deprecated As of API level 21, replaced by\n* {@link #playEarcon(String, int, Bundle, String)}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "playEarcon(String, int, Bundle, String)", "methodReturn": "int", "isValid": true, "cleanReplacement": "playEarcon(String, int, Bundle, String)", "fullMethod": "int playEarcon(String,int,HashMap<String, String>)", "method": "playEarcon(String,int,HashMap<String,"}, "isChecked": {"methodClass": "androidx.core.view.accessibility.AccessibilityRecordCompat", "methodName": "isChecked", "replacementComments": "/**\n* Gets if the source is checked.\n*\n* @return True if the view is checked, false otherwise.\n*\n* @deprecated Use {@link AccessibilityRecord#isChecked()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityRecord#isChecked()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "AccessibilityRecord#isChecked()", "fullMethod": "boolean isChecked()", "method": "isChecked()"}, "injectInsrumentation": {"methodClass": "android.test.InstrumentationTestCase", "methodName": "injectInsrumentation", "replacementComments": "/**\n* Injects instrumentation into this test case. This method is\n* called by the test runner during test setup.\n*\n* @param instrumentation the instrumentation to use with this instance\n*\n* @deprecated Incorrect spelling,\n* use {@link #injectInstrumentation(android.app.Instrumentation)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "injectInstrumentation(android.app.Instrumentation)", "methodReturn": "void", "isValid": true, "cleanReplacement": "injectInstrumentation(android.app.Instrumentation)", "fullMethod": "void injectInsrumentation(Instrumentation)", "method": "injectInsrumentation(Instrumentation)"}, "registerMediaButtonEventReceiver": {"methodClass": "android.media.AudioManager", "methodName": "registerMediaButtonEventReceiver", "replacementComments": "/**\n* Register a component to be the sole receiver of MEDIA_BUTTON intents.\n* @param eventReceiver identifier of a {@link android.content.BroadcastReceiver}\n* that will receive the media button intent. This broadcast receiver must be declared\n* in the application manifest. The package of the component must match that of\n* the context you're registering from.\n* @deprecated Use {@link MediaSession#setMediaButtonReceiver(PendingIntent)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "MediaSession#setMediaButtonReceiver(PendingIntent)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setMediaButtonReceiver(PendingIntent)", "fullMethod": "void registerMediaButtonEventReceiver(ComponentName)", "method": "registerMediaButtonEventReceiver(ComponentName)"}, "runFinalizersOnExit": {"methodClass": "java.lang.System", "methodName": "runFinalizersOnExit", "replacementComments": "/**\n* Enable or disable finalization on exit; doing so specifies that the\n* finalizers of all objects that have finalizers that have not yet been\n* automatically invoked are to be run before the Java runtime exits.\n* By default, finalization on exit is disabled.\n*\n* <p>If there is a security manager,\n* its <code>checkExit</code> method is first called\n* with 0 as its argument to ensure the exit is allowed.\n* This could result in a SecurityException.\n*\n* @deprecated  This method is inherently unsafe.  It may result in\n* finalizers being called on live objects while other threads are\n* concurrently manipulating those objects, resulting in erratic\n* behavior or deadlock.\n* @param value indicating enabling or disabling of finalization\n* @throws  SecurityException\n* if a security manager exists and its <code>checkExit</code>\n* method doesn't allow the exit.\n*\n* @see     java.lang.Runtime#exit(int)\n* @see     java.lang.Runtime#gc()\n* @see     java.lang.SecurityManager#checkExit(int)\n* @since   JDK1.1\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "java.lang.Runtime#exit(int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "exit(int)", "fullMethod": "void runFinalizersOnExit(boolean)", "method": "runFinalizersOnExit(boolean)"}, "getMeasuredState": {"methodClass": "androidx.core.view.ViewCompat", "methodName": "getMeasuredState", "replacementComments": "/**\n* Return only the state bits of {@link #getMeasuredWidthAndState}\n* and {@link #getMeasuredHeightAndState}, combined into one integer.\n* The width component is in the regular bits {@link #MEASURED_STATE_MASK}\n* and the height component is at the shifted bits\n* {@link #MEASURED_HEIGHT_STATE_SHIFT}>>{@link #MEASURED_STATE_MASK}.\n*\n* @deprecated Use {@link View#getMeasuredState()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "View#getMeasuredState()", "methodReturn": "int", "isValid": true, "cleanReplacement": "getMeasuredState()", "fullMethod": "int getMeasuredState(View)", "method": "getMeasuredState(View)"}, "getProvisionedValue": {"methodClass": "com.android.ims.ImsConfig", "methodName": "getProvisionedValue", "replacementComments": "/**\n* @deprecated see {@link #getConfigInt(int)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getConfigInt(int)", "methodReturn": "int", "isValid": true, "cleanReplacement": "getConfigInt(int)", "fullMethod": "int getProvisionedValue(int)", "method": "getProvisionedValue(int)"}, "create": {"methodClass": "androidx.core.widget.ScrollerCompat", "methodName": "create", "replacementComments": "/**\n* @deprecated Use {@link OverScroller} constructor directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "OverScroller", "methodReturn": "ScrollerCompat", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "ScrollerCompat create(Context,Interpolator)", "method": "create(Context,Interpolator)"}, "requestAudioFocus": {"methodClass": "android.media.AudioManager", "methodName": "requestAudioFocus", "replacementComments": "/**\n* Request audio focus.\n* Send a request to obtain the audio focus\n* @param l the listener to be notified of audio focus changes\n* @param streamType the main audio stream type affected by the focus request\n* @param durationHint use {@link #AUDIOFOCUS_GAIN_TRANSIENT} to indicate this focus request\n* is temporary, and focus will be abandonned shortly. Examples of transient requests are\n* for the playback of driving directions, or notifications sounds.\n* Use {@link #AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK} to indicate also that it's ok for\n* the previous focus owner to keep playing if it ducks its audio output.\n* Alternatively use {@link #AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE} for a temporary request\n* that benefits from the system not playing disruptive sounds like notifications, for\n* usecases such as voice memo recording, or speech recognition.\n* Use {@link #AUDIOFOCUS_GAIN} for a focus request of unknown duration such\n* as the playback of a song or a video.\n* @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}\n* @deprecated use {@link #requestAudioFocus(AudioFocusRequest)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "requestAudioFocus(AudioFocusRequest)", "methodReturn": "int", "isValid": true, "cleanReplacement": "requestAudioFocus(AudioFocusRequest)", "fullMethod": "int requestAudioFocus(OnAudioFocusChangeListener,int,int)", "method": "requestAudioFocus(OnAudioFocusChangeListener,int,int)"}, "getCapabilities": {"methodClass": "android.net.wifi.RttManager", "methodName": "getCapabilities", "replacementComments": "/**\n* @deprecated Use the new {@link android.net.wifi.RttManager#getRttCapabilities()} API.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "android.net.wifi.RttManager#getRttCapabilities()", "methodReturn": "Capabilities", "isValid": true, "cleanReplacement": "getRttCapabilities()", "fullMethod": "Capabilities getCapabilities()", "method": "getCapabilities()"}, "setDrawingCacheBackgroundColor": {"methodClass": "android.view.View", "methodName": "setDrawingCacheBackgroundColor", "replacementComments": "/**\n* Setting a solid background color for the drawing cache's bitmaps will improve\n* performance and memory usage. Note, though that this should only be used if this\n* view will always be drawn on top of a solid color.\n*\n* @param color The background color to use for the drawing cache's bitmap\n*\n* @see #setDrawingCacheEnabled(boolean)\n* @see #buildDrawingCache()\n* @see #getDrawingCache()\n*\n* @deprecated The view drawing cache was largely made obsolete with the introduction of\n* hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache\n* layers are largely unnecessary and can easily result in a net loss in performance due to the\n* cost of creating and updating the layer. In the rare cases where caching layers are useful,\n* such as for alpha animations, {@link #setLayerType(int, Paint)} handles this with hardware\n* rendering. For software-rendered snapshots of a small part of the View hierarchy or\n* individual Views it is recommended to create a {@link Canvas} from either a {@link Bitmap} or\n* {@link android.graphics.Picture} and call {@link #draw(Canvas)} on the View. However these\n* software-rendered usages are discouraged and have compatibility issues with hardware-only\n* rendering features such as {@link android.graphics.Bitmap.Config#HARDWARE Config.HARDWARE}\n* bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback\n* reports or unit testing the {@link PixelCopy} API is recommended.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setLayerType(int, Paint)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setLayerType(int, Paint)", "fullMethod": "void setDrawingCacheBackgroundColor(int)", "method": "setDrawingCacheBackgroundColor(int)"}, "getWindowId": {"methodClass": "androidx.core.view.accessibility.AccessibilityRecordCompat", "methodName": "getWindowId", "replacementComments": "/**\n* Gets the id of the window from which the event comes from.\n*\n* @return The window id.\n*\n* @deprecated Use {@link AccessibilityRecord#getWindowId()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityRecord#getWindowId()", "methodReturn": "int", "isValid": true, "cleanReplacement": "AccessibilityRecord#getWindowId()", "fullMethod": "int getWindowId()", "method": "getWindowId()"}, "dragQuarterScreenDown": {"methodClass": "android.test.TouchUtils", "methodName": "dragQuarterScreenDown", "replacementComments": "/**\n* Simulate touching in the center of the screen and dragging one quarter of the way down\n* @param test The test case that is being run\n*\n* @deprecated {@link android.test.ActivityInstrumentationTestCase} is deprecated in favor of\n* {@link android.test.ActivityInstrumentationTestCase2}, which provides more options for\n* configuring the Activity under test\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "android.test.ActivityInstrumentationTestCase2", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void dragQuarterScreenDown(ActivityInstrumentationTestCase)", "method": "dragQuarterScreenDown(ActivityInstrumentationTestCase)"}, "getInputBuffers": {"methodClass": "android.media.MediaCodec", "methodName": "getInputBuffers", "replacementComments": "/**\n* Retrieve the set of input buffers.  Call this after start()\n* returns. After calling this method, any ByteBuffers\n* previously returned by an earlier call to this method MUST no\n* longer be used.\n*\n* @deprecated Use the new {@link #getInputBuffer} method instead\n* each time an input buffer is dequeued.\n*\n* <b>Note:</b> As of API 21, dequeued input buffers are\n* automatically {@link java.nio.Buffer#clear cleared}.\n*\n* <em>Do not use this method if using an input surface.</em>\n*\n* @throws IllegalStateException if not in the Executing state,\n* or codec is configured in asynchronous mode.\n* @throws MediaCodec.CodecException upon codec error.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getInputBuffer", "methodReturn": "ByteBuffer[]", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "ByteBuffer[] getInputBuffers()", "method": "getInputBuffers()"}, "fling": {"methodClass": "androidx.core.widget.ScrollerCompat", "methodName": "fling", "replacementComments": "/**\n* Start scrolling based on a fling gesture. The distance travelled will\n* depend on the initial velocity of the fling.\n*\n* @param startX Starting point of the scroll (X)\n* @param startY Starting point of the scroll (Y)\n* @param velocityX Initial velocity of the fling (X) measured in pixels per\n* second.\n* @param velocityY Initial velocity of the fling (Y) measured in pixels per\n* second\n* @param minX Minimum X value. The scroller will not scroll past this\n* point.\n* @param maxX Maximum X value. The scroller will not scroll past this\n* point.\n* @param minY Minimum Y value. The scroller will not scroll past this\n* point.\n* @param maxY Maximum Y value. The scroller will not scroll past this\n* point.\n* @param overX Overfling range. If > 0, horizontal overfling in either\n* direction will be possible.\n* @param overY Overfling range. If > 0, vertical overfling in either\n* direction will be possible.\n*\n* @deprecated Use {@link OverScroller#fling(int, int, int, int, int, int, int, int, int, int)}\n* directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "OverScroller#fling(int, int, int, int, int, int, int, int, int, int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "fling(int, int, int, int, int, int, int, int, int, int)", "fullMethod": "void fling(int,int,int,int,int,int,int,int,int,int)", "method": "fling(int,int,int,int,int,int,int,int,int,int)"}, "dragViewBy": {"methodClass": "android.test.TouchUtils", "methodName": "dragViewBy", "replacementComments": "/**\n* Simulate touching a view and dragging it by the specified amount.\n*\n* @param test The test case that is being run\n* @param v The view that should be dragged\n* @param gravity Which part of the view to use for the initial down event. A combination of\n* (TOP, CENTER_VERTICAL, BOTTOM) and (LEFT, CENTER_HORIZONTAL, RIGHT)\n* @param deltaX Amount to drag horizontally in pixels\n* @param deltaY Amount to drag vertically in pixels\n*\n* @return distance in pixels covered by the drag\n*\n* @deprecated {@link android.test.ActivityInstrumentationTestCase} is deprecated in favor of\n* {@link android.test.ActivityInstrumentationTestCase2}, which provides more options for\n* configuring the Activity under test\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "android.test.ActivityInstrumentationTestCase2", "methodReturn": "int", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "int dragViewBy(ActivityInstrumentationTestCase,View,int,int,int)", "method": "dragViewBy(ActivityInstrumentationTestCase,View,int,int,int)"}, "setDividerInset": {"methodClass": "com.android.setupwizardlib.template.RecyclerMixin", "methodName": "setDividerInset", "replacementComments": "/**\n* @deprecated Use {@link #setDividerInsets(int, int)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setDividerInsets(int, int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setDividerInsets(int, int)", "fullMethod": "void setDividerInset(int)", "method": "setDividerInset(int)"}, "createPersonInMyContactsGroup": {"methodClass": "android.provider.Contacts.People", "methodName": "createPersonInMyContactsGroup", "replacementComments": "/**\n* Creates a new contacts and adds it to the \"My Contacts\" group.\n*\n* @param resolver the ContentResolver to use\n* @param values the values to use when creating the contact\n* @return the URI of the contact, or null if the operation fails\n* @deprecated see {@link android.provider.ContactsContract}\n*/\n", "isClassDeprecated": true, "dirtyReplacement": "android.provider.ContactsContract", "methodReturn": "Uri", "isValid": true, "cleanReplacement": "android.provider.ContactsContract", "fullMethod": "Uri createPersonInMyContactsGroup(ContentResolver,ContentValues)", "method": "createPersonInMyContactsGroup(ContentResolver,ContentValues)"}, "getUserId": {"methodClass": "android.service.notification.StatusBarNotification", "methodName": "getUserId", "replacementComments": "/**\n* Returns a userid for whom this notification is intended.\n*\n* @deprecated Use {@link #getUser()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getUser()", "methodReturn": "int", "isValid": true, "cleanReplacement": "getUser()", "fullMethod": "int getUserId()", "method": "getUserId()"}, "dismissDialog": {"methodClass": "android.app.Activity", "methodName": "dismissDialog", "replacementComments": "/**\n* Dismiss a dialog that was previously shown via {@link #showDialog(int)}.\n*\n* @param id The id of the managed dialog.\n*\n* @throws IllegalArgumentException if the id was not previously shown via\n* {@link #showDialog(int)}.\n*\n* @see #onCreateDialog(int, Bundle)\n* @see #onPrepareDialog(int, Dialog, Bundle)\n* @see #showDialog(int)\n* @see #removeDialog(int)\n*\n* @deprecated Use the new {@link DialogFragment} class with\n* {@link FragmentManager} instead; this is also\n* available on older platforms through the Android compatibility package.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "DialogFragment", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void dismissDialog(int)", "method": "dismissDialog(int)"}, "getVersionCode": {"methodClass": "android.content.pm.VersionedPackage", "methodName": "getVersionCode", "replacementComments": "/**\n* @deprecated use {@link #getLongVersionCode()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getLongVersionCode()", "methodReturn": "int", "isValid": true, "cleanReplacement": "getLongVersionCode()", "fullMethod": "int getVersionCode()", "method": "getVersionCode()"}, "longClickView": {"methodClass": "android.test.TouchUtils", "methodName": "longClickView", "replacementComments": "/**\n* Simulate touching the center of a view, holding until it is a long press, and then releasing.\n*\n* @param test The test case that is being run\n* @param v The view that should be clicked\n*\n* @deprecated {@link android.test.ActivityInstrumentationTestCase} is deprecated in favor of\n* {@link android.test.ActivityInstrumentationTestCase2}, which provides more options for\n* configuring the Activity under test\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "android.test.ActivityInstrumentationTestCase2", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void longClickView(ActivityInstrumentationTestCase,View)", "method": "longClickView(ActivityInstrumentationTestCase,View)"}, "setFullScreen": {"methodClass": "androidx.core.view.accessibility.AccessibilityRecordCompat", "methodName": "setFullScreen", "replacementComments": "/**\n* Sets if the source is taking the entire screen.\n*\n* @param isFullScreen True if the source is full screen, false otherwise.\n*\n* @throws IllegalStateException If called from an AccessibilityService.\n*\n* @deprecated Use {@link AccessibilityRecord#setFullScreen(boolean)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityRecord#setFullScreen(boolean)", "methodReturn": "void", "isValid": true, "cleanReplacement": "AccessibilityRecord#setFullScreen(boolean)", "fullMethod": "void setFullScreen(boolean)", "method": "setFullScreen(boolean)"}, "getPreviewFrameRate": {"methodClass": "android.hardware.Camera.Parameters", "methodName": "getPreviewFrameRate", "replacementComments": "/**\n* Returns the setting for the rate at which preview frames are\n* received. This is the target frame rate. The actual frame rate\n* depends on the driver.\n*\n* @return the frame rate setting (frames per second)\n* @deprecated replaced by {@link #getPreviewFpsRange(int[])}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getPreviewFpsRange(int[])", "methodReturn": "int", "isValid": true, "cleanReplacement": "getPreviewFpsRange(int[])", "fullMethod": "int getPreviewFrameRate()", "method": "getPreviewFrameRate()"}, "reportBadNetwork": {"methodClass": "android.net.ConnectivityManager", "methodName": "reportBadNetwork", "replacementComments": "/**\n* Report a problem network to the framework.  This provides a hint to the system\n* that there might be connectivity problems on this network and may cause\n* the framework to re-evaluate network connectivity and/or switch to another\n* network.\n*\n* @param network The {@link Network} the application was attempting to use\n* or {@code null} to indicate the current default network.\n* @deprecated Use {@link #reportNetworkConnectivity} which allows reporting both\n* working and non-working connectivity.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "reportNetworkConnectivity", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void reportBadNetwork(Network)", "method": "reportBadNetwork(Network)"}, "execute": {"methodClass": "android.renderscript.ScriptGroup", "methodName": "execute", "replacementComments": "/**\n* Execute the ScriptGroup.  This will run all the kernels in\n* the ScriptGroup.  No internal connection results will be visible\n* after execution of the ScriptGroup.\n*\n* @deprecated Use {@link #execute} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "execute", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void execute()", "method": "execute()"}, "writeRepeatedUInt32": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writeRepeatedUInt32", "replacementComments": "/**\n* Write a single repeated proto \"uint32\" type field value.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writeRepeatedUInt32(long,int)", "method": "writeRepeatedUInt32(long,int)"}, "getFreeBlocks": {"methodClass": "android.os.StatFs", "methodName": "getFreeBlocks", "replacementComments": "/**\n* @deprecated Use {@link #getFreeBlocksLong()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getFreeBlocksLong()", "methodReturn": "int", "isValid": true, "cleanReplacement": "getFreeBlocksLong()", "fullMethod": "int getFreeBlocks()", "method": "getFreeBlocks()"}, "inClass": {"methodClass": "java.lang.SecurityManager", "methodName": "inClass", "replacementComments": "/**\n* @deprecated Use {@link #checkPermission} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "checkPermission", "methodReturn": "boolean", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "boolean inClass(String)", "method": "inClass(String)"}, "getDrawingCacheQuality": {"methodClass": "android.view.View", "methodName": "getDrawingCacheQuality", "replacementComments": "/**\n* Returns the quality of the drawing cache.\n*\n* @return One of {@link #DRAWING_CACHE_QUALITY_AUTO},\n* {@link #DRAWING_CACHE_QUALITY_LOW}, or {@link #DRAWING_CACHE_QUALITY_HIGH}\n*\n* @see #setDrawingCacheQuality(int)\n* @see #setDrawingCacheEnabled(boolean)\n* @see #isDrawingCacheEnabled()\n*\n* @attr ref android.R.styleable#View_drawingCacheQuality\n*\n* @deprecated The view drawing cache was largely made obsolete with the introduction of\n* hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache\n* layers are largely unnecessary and can easily result in a net loss in performance due to the\n* cost of creating and updating the layer. In the rare cases where caching layers are useful,\n* such as for alpha animations, {@link #setLayerType(int, Paint)} handles this with hardware\n* rendering. For software-rendered snapshots of a small part of the View hierarchy or\n* individual Views it is recommended to create a {@link Canvas} from either a {@link Bitmap} or\n* {@link android.graphics.Picture} and call {@link #draw(Canvas)} on the View. However these\n* software-rendered usages are discouraged and have compatibility issues with hardware-only\n* rendering features such as {@link android.graphics.Bitmap.Config#HARDWARE Config.HARDWARE}\n* bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback\n* reports or unit testing the {@link PixelCopy} API is recommended.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setLayerType(int, Paint)", "methodReturn": "int", "isValid": true, "cleanReplacement": "setLayerType(int, Paint)", "fullMethod": "int getDrawingCacheQuality()", "method": "getDrawingCacheQuality()"}, "getNotification": {"methodClass": "androidx.core.app.NotificationCompat.Builder", "methodName": "getNotification", "replacementComments": "/**\n* @deprecated Use {@link #build()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "build()", "methodReturn": "Notification", "isValid": true, "cleanReplacement": "build()", "fullMethod": "Notification getNotification()", "method": "getNotification()"}, "writeObject": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writeObject", "replacementComments": "/**\n* Write an object that has already been flattend.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writeObject(long,byte[])", "method": "writeObject(long,byte[])"}, "addWord": {"methodClass": "android.provider.UserDictionary.Words", "methodName": "addWord", "replacementComments": "/**\n* Adds a word to the dictionary, with the given frequency and the specified\n* specified locale type.\n*\n* @deprecated Please use\n* {@link #addWord(Context, String, int, String, Locale)} instead.\n*\n* @param context the current application context\n* @param word the word to add to the dictionary. This should not be null or\n* empty.\n* @param localeType the locale type for this word. It should be one of\n* {@link #LOCALE_TYPE_ALL} or {@link #LOCALE_TYPE_CURRENT}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "addWord(Context, String, int, String, Locale)", "methodReturn": "void", "isValid": true, "cleanReplacement": "addWord(Context, String, int, String, Locale)", "fullMethod": "void addWord(Context,String,int,int)", "method": "addWord(Context,String,int,int)"}, "setOnScrollListener": {"methodClass": "androidx.recyclerview.widget.RecyclerView", "methodName": "setOnScrollListener", "replacementComments": "/**\n* Set a listener that will be notified of any changes in scroll state or position.\n*\n* @param listener Listener to set or null to clear\n*\n* @deprecated Use {@link #addOnScrollListener(OnScrollListener)} and\n* {@link #removeOnScrollListener(OnScrollListener)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "addOnScrollListener(OnScrollListener)", "methodReturn": "void", "isValid": true, "cleanReplacement": "addOnScrollListener(OnScrollListener)", "fullMethod": "void setOnScrollListener(OnScrollListener)", "method": "setOnScrollListener(OnScrollListener)"}, "sendMessage": {"methodClass": "android.hardware.location.ContextHubManager", "methodName": "sendMessage", "replacementComments": "/**\n* Send a message to a specific nano app instance on a context hub.\n*\n* Note that the return value of this method only speaks of success\n* up to the point of sending this to the Context Hub.  It is not\n* an assurance that the Context Hub successfully sent this message\n* on to the nanoapp.  If assurance is desired, a protocol should be\n* established between your code and the nanoapp, with the nanoapp\n* sending a confirmation message (which will be reported via\n* Callback.onMessageReceipt).\n*\n* @param hubHandle handle of the hub to send the message to\n* @param nanoAppHandle  handle of the nano app to send to\n* @param message Message to be sent\n*\n* @see ContextHubMessage\n*\n* @return int 0 on success, -1 otherwise\n*\n* @deprecated Use {@link android.hardware.location.ContextHubClient#sendMessageToNanoApp(\n* NanoAppMessage)} instead, after creating a\n* {@link android.hardware.location.ContextHubClient} with\n* {@link #createClient(ContextHubInfo, ContextHubClientCallback, Executor)}\n* or {@link #createClient(ContextHubInfo, ContextHubClientCallback)}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "android.hardware.location.ContextHubClient#sendMessageToNanoApp(  NanoAppMessage)", "methodReturn": "int", "isValid": true, "cleanReplacement": "sendMessageToNanoApp(  NanoAppMessage)", "fullMethod": "int sendMessage(int,int,ContextHubMessage)", "method": "sendMessage(int,int,ContextHubMessage)"}, "setShadowResource": {"methodClass": "androidx.slidingpanelayout.widget.SlidingPaneLayout", "methodName": "setShadowResource", "replacementComments": "/**\n* Set a drawable to use as a shadow cast by the right pane onto the left pane\n* during opening/closing.\n*\n* @param resId Resource ID of a drawable to use\n* @deprecated Renamed to {@link #setShadowResourceLeft(int)} to support LTR (left to\n* right language) and {@link #setShadowResourceRight(int)} to support RTL (right to left\n* language) during opening/closing.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setShadowResourceLeft(int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setShadowResourceLeft(int)", "fullMethod": "void setShadowResource(int)", "method": "setShadowResource(int)"}, "readLine": {"methodClass": "java.io.DataInputStream", "methodName": "readLine", "replacementComments": "/**\n* See the general contract of the <code>readLine</code>\n* method of <code>DataInput</code>.\n* <p>\n* Bytes\n* for this operation are read from the contained\n* input stream.\n*\n* @deprecated This method does not properly convert bytes to characters.\n* As of JDK&nbsp;1.1, the preferred way to read lines of text is via the\n* <code>BufferedReader.readLine()</code> method.  Programs that use the\n* <code>DataInputStream</code> class to read lines can be converted to use\n* the <code>BufferedReader</code> class by replacing code of the form:\n* <blockquote><pre>\n* DataInputStream d =&nbsp;new&nbsp;DataInputStream(in);\n* </pre></blockquote>\n* with:\n* <blockquote><pre>\n* BufferedReader d\n* =&nbsp;new&nbsp;BufferedReader(new&nbsp;InputStreamReader(in));\n* </pre></blockquote>\n*\n* @return     the next line of text from this input stream.\n* @exception  IOException  if an I/O error occurs.\n* @see        java.io.BufferedReader#readLine()\n* @see        java.io.FilterInputStream#in\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "java.io.BufferedReader#readLine()", "methodReturn": "String", "isValid": true, "cleanReplacement": "java.io.BufferedReader#readLine()", "fullMethod": "String readLine()", "method": "readLine()"}, "getAxisValue": {"methodClass": "androidx.core.view.MotionEventCompat", "methodName": "getAxisValue", "replacementComments": "/**\n* Get axis value for the first pointer index (may be an\n* arbitrary pointer identifier).\n*\n* @param axis The axis identifier for the axis value to retrieve.\n*\n* @see #AXIS_X\n* @see #AXIS_Y\n*\n* @deprecated Call {@link MotionEvent#getAxisValue(int)} directly. This method will be\n* removed in a future release.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "MotionEvent#getAxisValue(int)", "methodReturn": "float", "isValid": true, "cleanReplacement": "getAxisValue(int)", "fullMethod": "float getAxisValue(MotionEvent,int)", "method": "getAxisValue(MotionEvent,int)"}, "getAMPMString": {"methodClass": "android.text.format.DateUtils", "methodName": "getAMPMString", "replacementComments": "/**\n* Return a localized string for AM or PM.\n* @param ampm Either {@link Calendar#AM Calendar.AM} or {@link Calendar#PM Calendar.PM}.\n* @throws IndexOutOfBoundsException if the ampm is out of bounds.\n* @return Localized version of \"AM\" or \"PM\".\n* @deprecated Use {@link java.text.SimpleDateFormat} instead.\n*/\n", "isClassDeprecated": true, "dirtyReplacement": "java.text.SimpleDateFormat", "methodReturn": "String", "isValid": true, "cleanReplacement": "java.text.SimpleDateFormat", "fullMethod": "String getAMPMString(int)", "method": "getAMPMString(int)"}, "notifyVerticalEdgeReached": {"methodClass": "androidx.core.widget.ScrollerCompat", "methodName": "notifyVerticalEdgeReached", "replacementComments": "/**\n* Notify the scroller that we've reached a vertical boundary.\n* Normally the information to handle this will already be known\n* when the animation is started, such as in a call to one of the\n* fling functions. However there are cases where this cannot be known\n* in advance. This function will animate a parabolic motion from\n* startY to finalY.\n*\n* @param startY Starting/current Y position\n* @param finalY Desired final Y position\n* @param overY Magnitude of overscroll allowed. This should be the maximum\n* desired distance from finalY. Absolute value - must be positive.\n*\n* @deprecated Use {@link OverScroller#notifyVerticalEdgeReached(int, int, int)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "OverScroller#notifyVerticalEdgeReached(int, int, int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "notifyVerticalEdgeReached(int, int, int)", "fullMethod": "void notifyVerticalEdgeReached(int,int,int)", "method": "notifyVerticalEdgeReached(int,int,int)"}, "writeRepeatedBool": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writeRepeatedBool", "replacementComments": "/**\n* Write a single repeated proto \"bool\" type field value.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writeRepeatedBool(long,boolean)", "method": "writeRepeatedBool(long,boolean)"}, "setVibrate": {"methodClass": "android.app.Notification.Builder", "methodName": "setVibrate", "replacementComments": "/**\n* Set the vibration pattern to use.\n*\n* See {@link android.os.Vibrator#vibrate(long[], int)} for a discussion of the\n* <code>pattern</code> parameter.\n*\n* <p>\n* A notification that vibrates is more likely to be presented as a heads-up notification.\n* </p>\n*\n* @deprecated use {@link NotificationChannel#setVibrationPattern(long[])} instead.\n* @see Notification#vibrate\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "NotificationChannel#setVibrationPattern(long[])", "methodReturn": "Builder", "isValid": true, "cleanReplacement": "setVibrationPattern(long[])", "fullMethod": "Builder setVibrate(long[])", "method": "setVibrate(long[])"}, "onGuidedActionEdited": {"methodClass": "androidx.leanback.app.GuidedStepSupportFragment", "methodName": "onGuidedActionEdited", "replacementComments": "/**\n* Callback invoked when an action's title or description has been edited, this happens either\n* when user clicks confirm button in IME or user closes IME window by BACK key.\n* @deprecated Override {@link #onGuidedActionEditedAndProceed(GuidedAction)} and/or\n* {@link #onGuidedActionEditCanceled(GuidedAction)}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "onGuidedActionEditedAndProceed(GuidedAction)", "methodReturn": "void", "isValid": true, "cleanReplacement": "onGuidedActionEditedAndProceed(GuidedAction)", "fullMethod": "void onGuidedActionEdited(GuidedAction)", "method": "onGuidedActionEdited(GuidedAction)"}, "loadContactPhoto": {"methodClass": "android.provider.Contacts.People", "methodName": "loadContactPhoto", "replacementComments": "/**\n* Opens an InputStream for the person's photo and returns the photo as a Bitmap.\n* If the person's photo isn't present returns the placeholderImageResource instead.\n* @param context the Context\n* @param person the person whose photo should be used\n* @param placeholderImageResource the image resource to use if the person doesn't\n* have a photo\n* @param options the decoding options, can be set to null\n* @deprecated see {@link android.provider.ContactsContract}\n*/\n", "isClassDeprecated": true, "dirtyReplacement": "android.provider.ContactsContract", "methodReturn": "Bitmap", "isValid": true, "cleanReplacement": "android.provider.ContactsContract", "fullMethod": "Bitmap loadContactPhoto(Context,Uri,int,Options)", "method": "loadContactPhoto(Context,Uri,int,Options)"}, "writeRepeatedInt32": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writeRepeatedInt32", "replacementComments": "/**\n* Write a single repeated proto \"int32\" type field value.\n*\n* Note that these are stored in memory as signed values and written as unsigned\n* varints, which if negative, are 10 bytes long. If you know the data is likely\n* to be negative, use \"sint32\".\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writeRepeatedInt32(long,int)", "method": "writeRepeatedInt32(long,int)"}, "closeFileDescriptor": {"methodClass": "android.os.Parcel", "methodName": "closeFileDescriptor", "replacementComments": "/**\n* @deprecated use {@link android.system.Os#close(FileDescriptor)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "android.system.Os#close(FileDescriptor)", "methodReturn": "void", "isValid": true, "cleanReplacement": "close(FileDescriptor)", "fullMethod": "void closeFileDescriptor(FileDescriptor)", "method": "closeFileDescriptor(FileDescriptor)"}, "isWfcProvisionedOnDevice": {"methodClass": "com.android.ims.ImsManager", "methodName": "isWfcProvisionedOnDevice", "replacementComments": "/**\n* Indicates whether VoWifi is provisioned on device.\n*\n* When CarrierConfig KEY_CARRIER_VOLTE_OVERRIDE_WFC_PROVISIONING_BOOL is true, and VoLTE is not\n* provisioned on device, this method returns false.\n*\n* @deprecated Does not support MSIM devices. Please use\n* {@link #isWfcProvisionedOnDevice()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "isWfcProvisionedOnDevice()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "isWfcProvisionedOnDevice()", "fullMethod": "boolean isWfcProvisionedOnDevice(Context)", "method": "isWfcProvisionedOnDevice(Context)"}, "finish": {"methodClass": "androidx.core.widget.EdgeEffectCompat", "methodName": "finish", "replacementComments": "/**\n* Immediately finish the current animation.\n* After this call {@link #isFinished()} will return true.\n*\n* @deprecated Use {@link EdgeEffect#finish()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "EdgeEffect#finish()", "methodReturn": "void", "isValid": true, "cleanReplacement": "EdgeEffect#finish()", "fullMethod": "void finish()", "method": "finish()"}, "getTextSize": {"methodClass": "android.webkit.WebSettings", "methodName": "getTextSize", "replacementComments": "/**\n* Gets the text size of the page. If the text size was previously specified\n* in percent using {@link #setTextZoom}, this will return the closest\n* matching {@link TextSize}.\n*\n* @return the text size as a {@link TextSize} value\n* @see #setTextSize\n* @deprecated Use {@link #getTextZoom} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getTextZoom", "methodReturn": "TextSize", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "TextSize getTextSize()", "method": "getTextSize()"}, "isAntennaConnected": {"methodClass": "android.hardware.radio.RadioTuner", "methodName": "isAntennaConnected", "replacementComments": "/**\n* Get current antenna connection state for current configuration.\n* Only valid if a configuration has been applied.\n* @return {@code true} if the antenna is connected, {@code false} otherwise.\n*\n* @deprecated Use {@link onAntennaState} callback instead\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "onAntennaState", "methodReturn": "boolean", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "boolean isAntennaConnected()", "method": "isAntennaConnected()"}, "removeAccessibilityStateChangeListener": {"methodClass": "androidx.core.view.accessibility.AccessibilityManagerCompat", "methodName": "removeAccessibilityStateChangeListener", "replacementComments": "/**\n* Unregisters an {@link AccessibilityManager.AccessibilityStateChangeListener}.\n*\n* @param manager The accessibility manager.\n* @param listener The listener.\n* @return True if successfully unregistered.\n*\n* @deprecated Use {@link AccessibilityManager#removeAccessibilityStateChangeListener(\n* AccessibilityManager.AccessibilityStateChangeListener)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityManager#removeAccessibilityStateChangeListener(  AccessibilityManager.AccessibilityStateChangeListener)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "removeAccessibilityStateChangeListener(  AccessibilityManager.AccessibilityStateChangeListener)", "fullMethod": "boolean removeAccessibilityStateChangeListener(AccessibilityManager,AccessibilityStateChangeListener)", "method": "removeAccessibilityStateChangeListener(AccessibilityManager,AccessibilityStateChangeListener)"}, "getTTL": {"methodClass": "java.net.MulticastSocket", "methodName": "getTTL", "replacementComments": "/**\n* Get the default time-to-live for multicast packets sent out on\n* the socket.\n*\n* @exception IOException if an I/O exception occurs\n* while getting the default time-to-live value\n* @return the default time-to-live value\n* @deprecated use the getTimeToLive method instead, which returns\n* an <b>int</b> instead of a <b>byte</b>.\n* @see #setTTL(byte)\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "the getTimeToLive method", "methodReturn": "byte", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "byte getTTL()", "method": "getTTL()"}, "clearWallpaper": {"methodClass": "android.content.Context", "methodName": "clearWallpaper", "replacementComments": "/**\n* @deprecated Use {@link android.app.WallpaperManager#clear\n* WallpaperManager.clear()} instead.\n* <p>This method requires the caller to hold the permission\n* {@link android.Manifest.permission#SET_WALLPAPER}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "android.app.WallpaperManager#clear  WallpaperManager.clear()", "methodReturn": "void", "isValid": true, "cleanReplacement": "clear  WallpaperManager.clear()", "fullMethod": "void clearWallpaper()", "method": "clearWallpaper()"}, "onMultiWindowModeChanged": {"methodClass": "android.app.Fragment", "methodName": "onMultiWindowModeChanged", "replacementComments": "/**\n* Called when the Fragment's activity changes from fullscreen mode to multi-window mode and\n* visa-versa. This is generally tied to {@link Activity#onMultiWindowModeChanged} of the\n* containing Activity.\n*\n* @param isInMultiWindowMode True if the activity is in multi-window mode.\n*\n* @deprecated Use {@link #onMultiWindowModeChanged(boolean, Configuration)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "onMultiWindowModeChanged(boolean, Configuration)", "methodReturn": "void", "isValid": true, "cleanReplacement": "onMultiWindowModeChanged(boolean, Configuration)", "fullMethod": "void onMultiWindowModeChanged(boolean)", "method": "onMultiWindowModeChanged(boolean)"}, "showSoftInputFromInputMethod": {"methodClass": "android.view.inputmethod.InputMethodManager", "methodName": "showSoftInputFromInputMethod", "replacementComments": "/**\n* Show the input method's soft input area, so the user\n* sees the input method window and can interact with it.\n* This can only be called from the currently active input method,\n* as validated by the given token.\n*\n* @param token Supplies the identifying token given to an input method\n* when it was started, which allows it to perform this operation on\n* itself.\n* @param flags Provides additional operating flags.  Currently may be\n* 0 or have the {@link #SHOW_IMPLICIT} or\n* {@link #SHOW_FORCED} bit set.\n* @deprecated Use {@link InputMethodService#requestShowSelf(int)} instead. This method was\n* intended for IME developers who should be accessing APIs through the service. APIs in this\n* class are intended for app developers interacting with the IME.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "InputMethodService#requestShowSelf(int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "requestShowSelf(int)", "fullMethod": "void showSoftInputFromInputMethod(IBinder,int)", "method": "showSoftInputFromInputMethod(IBinder,int)"}, "hasCarrierCycles": {"methodClass": "android.location.GnssMeasurement", "methodName": "hasCarrierCycles", "replacementComments": "/**\n* Returns {@code true} if {@link #getCarrierCycles()} is available, {@code false} otherwise.\n*\n* @deprecated use {@link #getAccumulatedDeltaRangeState()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getAccumulatedDeltaRangeState()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "getAccumulatedDeltaRangeState()", "fullMethod": "boolean hasCarrierCycles()", "method": "hasCarrierCycles()"}, "setInstrumentaiton": {"methodClass": "android.test.AndroidTestRunner", "methodName": "setInstrumentaiton", "replacementComments": "/**\n* @deprecated Incorrect spelling,\n* use {@link #setInstrumentation(android.app.Instrumentation)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setInstrumentation(android.app.Instrumentation)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setInstrumentation(android.app.Instrumentation)", "fullMethod": "void setInstrumentaiton(Instrumentation)", "method": "setInstrumentaiton(Instrumentation)"}, "saveLayerAlpha": {"methodClass": "android.graphics.Canvas", "methodName": "saveLayerAlpha", "replacementComments": "/**\n* Helper for saveLayerAlpha() that takes 4 values instead of a RectF.\n*\n* As of API Level API level {@value Build.VERSION_CODES#P} the only valid\n* {@code saveFlags} is {@link #ALL_SAVE_FLAG}.  All other flags are ignored.\n*\n* @deprecated Use {@link #saveLayerAlpha(float, float, float, float, int)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "saveLayerAlpha(float, float, float, float, int)", "methodReturn": "int", "isValid": true, "cleanReplacement": "saveLayerAlpha(float, float, float, float, int)", "fullMethod": "int saveLayerAlpha(float,float,float,float,int,int)", "method": "saveLayerAlpha(float,float,float,float,int,int)"}, "synthesizeToFile": {"methodClass": "android.speech.tts.TextToSpeech", "methodName": "synthesizeToFile", "replacementComments": "/**\n* Synthesizes the given text to a file using the specified parameters.\n* This method is asynchronous, i.e. the method just adds the request to the queue of TTS\n* requests and then returns. The synthesis might not have finished (or even started!) at the\n* time when this method returns. In order to reliably detect errors during synthesis,\n* we recommend setting an utterance progress listener (see\n* {@link #setOnUtteranceProgressListener}) and using the\n* {@link Engine#KEY_PARAM_UTTERANCE_ID} parameter.\n*\n* @param text The text that should be synthesized. No longer than\n* {@link #getMaxSpeechInputLength()} characters.\n* @param params Parameters for the request. Can be null.\n* Supported parameter names:\n* {@link Engine#KEY_PARAM_UTTERANCE_ID}.\n* Engine specific parameters may be passed in but the parameter keys\n* must be prefixed by the name of the engine they are intended for. For example\n* the keys \"com.svox.pico_foo\" and \"com.svox.pico:bar\" will be passed to the\n* engine named \"com.svox.pico\" if it is being used.\n* @param filename Absolute file filename to write the generated audio data to.It should be\n* something like \"/sdcard/myappsounds/mysound.wav\".\n*\n* @return {@link #ERROR} or {@link #SUCCESS} of <b>queuing</b> the synthesizeToFile operation.\n* @deprecated As of API level 21, replaced by\n* {@link #synthesizeToFile(CharSequence, Bundle, File, String)}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "synthesizeToFile(CharSequence, Bundle, File, String)", "methodReturn": "int", "isValid": true, "cleanReplacement": "synthesizeToFile(CharSequence, Bundle, File, String)", "fullMethod": "int synthesizeToFile(String,HashMap<String, String>,String)", "method": "synthesizeToFile(String,HashMap<String,"}, "hashCode": {"methodClass": "androidx.core.view.accessibility.AccessibilityRecordCompat", "methodName": "hashCode", "replacementComments": "/**\n* @deprecated Use {@link AccessibilityRecord#hashCode()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityRecord#hashCode()", "methodReturn": "int", "isValid": true, "cleanReplacement": "AccessibilityRecord#hashCode()", "fullMethod": "int hashCode()", "method": "hashCode()"}, "getSliceKeywords": {"methodClass": "androidx.slice.SliceUtils", "methodName": "getSliceKeywords", "replacementComments": "/**\n* @return the list of keywords associated with the provided slice, null if no keywords were\n* specified or an empty list if the slice was specified to have no keywords.\n*\n* @deprecated TO BE REMOVED; use {@link SliceMetadata#getSliceKeywords()}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "SliceMetadata#getSliceKeywords()", "methodReturn": "List<String>", "isValid": true, "cleanReplacement": "getSliceKeywords()", "fullMethod": "List<String> getSliceKeywords(Slice)", "method": "getSliceKeywords(Slice)"}, "findNanoAppOnHub": {"methodClass": "android.hardware.location.ContextHubManager", "methodName": "findNanoAppOnHub", "replacementComments": "/**\n* Find a specified nano app on the system\n*\n* @param hubHandle handle of hub to search for nano app\n* @param filter filter specifying the search criteria for app\n*\n* @see NanoAppFilter\n*\n* @return int[] Array of handles to any found nano apps\n*\n* @deprecated Use {@link #queryNanoApps(ContextHubInfo)} instead to explicitly query the hub\n* for loaded nanoapps.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "queryNanoApps(ContextHubInfo)", "methodReturn": "int[]", "isValid": true, "cleanReplacement": "queryNanoApps(ContextHubInfo)", "fullMethod": "int[] findNanoAppOnHub(int,NanoAppFilter)", "method": "findNanoAppOnHub(int,NanoAppFilter)"}, "getCarrierPhase": {"methodClass": "android.location.GnssMeasurement", "methodName": "getCarrierPhase", "replacementComments": "/**\n* Gets the RF phase detected by the receiver.\n*\n* <p>Range: [0.0, 1.0].\n*\n* <p>This is the fractional part of the complete carrier phase measurement.\n*\n* <p>The reference frequency is given by the value of {@link #getCarrierFrequencyHz()}.\n*\n* <p>The error estimate for this value is {@link #getCarrierPhaseUncertainty()}.\n*\n* <p>The value is only available if {@link #hasCarrierPhase()} is {@code true}.\n*\n* @deprecated use {@link #getAccumulatedDeltaRangeMeters()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getAccumulatedDeltaRangeMeters()", "methodReturn": "double", "isValid": true, "cleanReplacement": "getAccumulatedDeltaRangeMeters()", "fullMethod": "double getCarrierPhase()", "method": "getCarrierPhase()"}, "clone": {"methodClass": "android.widget.RemoteViews", "methodName": "clone", "replacementComments": "/**\n* Returns a deep copy of the RemoteViews object. The RemoteView may not be\n* attached to another RemoteView -- it must be the root of a hierarchy.\n*\n* @deprecated use {@link #RemoteViews(RemoteViews)} instead.\n* @throws IllegalStateException if this is not the root of a RemoteView\n* hierarchy\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "RemoteViews(RemoteViews)", "methodReturn": "RemoteViews", "isValid": true, "cleanReplacement": "RemoteViews(RemoteViews)", "fullMethod": "RemoteViews clone()", "method": "clone()"}, "registerCallback": {"methodClass": "android.hardware.location.ContextHubManager", "methodName": "registerCallback", "replacementComments": "/**\n* Set a callback to receive messages from the context hub\n*\n* @param callback Callback object\n*\n* @see Callback\n*\n* @return int 0 on success, -1 otherwise\n*\n* @deprecated Use {@link #createClient(ContextHubInfo, ContextHubClientCallback, Executor)}\n* or {@link #createClient(ContextHubInfo, ContextHubClientCallback)} instead to\n* register a {@link android.hardware.location.ContextHubClientCallback}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "createClient(ContextHubInfo, ContextHubClientCallback)", "methodReturn": "int", "isValid": true, "cleanReplacement": "createClient(ContextHubInfo, ContextHubClientCallback)", "fullMethod": "int registerCallback(Callback)", "method": "registerCallback(Callback)"}, "writePackedInt32": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writePackedInt32", "replacementComments": "/**\n* Write a list of packed proto \"int32\" type field value.\n*\n* Note that these are stored in memory as signed values and written as unsigned\n* varints, which if negative, are 10 bytes long. If you know the data is likely\n* to be negative, use \"sint32\".\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writePackedInt32(long,int[])", "method": "writePackedInt32(long,int[])"}, "isOverScrolled": {"methodClass": "androidx.core.widget.ScrollerCompat", "methodName": "isOverScrolled", "replacementComments": "/**\n* Returns whether the current Scroller is currently returning to a valid position.\n* Valid bounds were provided by the\n* {@link #fling(int, int, int, int, int, int, int, int, int, int)} method.\n*\n* One should check this value before calling\n* {@link #startScroll(int, int, int, int)} as the interpolation currently in progress\n* to restore a valid position will then be stopped. The caller has to take into account\n* the fact that the started scroll will start from an overscrolled position.\n*\n* @return true when the current position is overscrolled and in the process of\n* interpolating back to a valid value.\n*\n* @deprecated Use {@link OverScroller#isOverScrolled()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "OverScroller#isOverScrolled()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "OverScroller#isOverScrolled()", "fullMethod": "boolean isOverScrolled()", "method": "isOverScrolled()"}, "clearProfileOwner": {"methodClass": "android.app.admin.DevicePolicyManager", "methodName": "clearProfileOwner", "replacementComments": "/**\n* Clears the active profile owner. The caller must be the profile owner of this user, otherwise\n* a SecurityException will be thrown. This method is not available to managed profile owners.\n* <p>\n* While some policies previously set by the profile owner will be cleared by this method, it is\n* a best-effort process and some other policies will still remain in place after the profile\n* owner is cleared.\n*\n* @param admin The component to remove as the profile owner.\n* @throws SecurityException if {@code admin} is not an active profile owner, or the method is\n* being called from a managed profile.\n*\n* @deprecated This method is expected to be used for testing purposes only. The profile owner\n* will lose control of the user and its data after calling it. In order to protect any\n* sensitive data that remains on this user, it is advised that the profile owner deletes it\n* instead of calling this method. See {@link #wipeData(int)}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "wipeData(int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "wipeData(int)", "fullMethod": "void clearProfileOwner(ComponentName)", "method": "clearProfileOwner(ComponentName)"}, "resume": {"methodClass": "java.lang.ThreadGroup", "methodName": "resume", "replacementComments": "/**\n* Resumes all threads in this thread group.\n* <p>\n* First, the <code>checkAccess</code> method of this thread group is\n* called with no arguments; this may result in a security exception.\n* <p>\n* This method then calls the <code>resume</code> method on all the\n* threads in this thread group and in all of its sub groups.\n*\n* @exception  SecurityException  if the current thread is not allowed to\n* access this thread group or any of the threads in the\n* thread group.\n* @see        java.lang.SecurityException\n* @see        java.lang.Thread#resume()\n* @see        java.lang.ThreadGroup#checkAccess()\n* @since      JDK1.0\n* @deprecated    This method is used solely in conjunction with\n* <tt>Thread.suspend</tt> and <tt>ThreadGroup.suspend</tt>,\n* both of which have been deprecated, as they are inherently\n* deadlock-prone.  See {@link Thread#suspend} for details.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "Thread#suspend", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void resume()", "method": "resume()"}, "getActionIndex": {"methodClass": "androidx.core.view.MotionEventCompat", "methodName": "getActionIndex", "replacementComments": "/**\n* Call {@link MotionEvent#getAction}, returning only the pointer index\n* portion.\n*\n* @deprecated Call {@link MotionEvent#getActionIndex()} directly. This method will be\n* removed in a future release.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "MotionEvent#getActionIndex()", "methodReturn": "int", "isValid": true, "cleanReplacement": "getActionIndex()", "fullMethod": "int getActionIndex(MotionEvent)", "method": "getActionIndex(MotionEvent)"}, "registerListener": {"methodClass": "android.hardware.SensorManager", "methodName": "registerListener", "replacementComments": "/**\n* Registers a listener for given sensors.\n*\n* @deprecated This method is deprecated, use\n* {@link SensorManager#registerListener(SensorEventListener, Sensor, int)}\n* instead.\n*\n* @param listener\n* sensor listener object\n*\n* @param sensors\n* a bit masks of the sensors to register to\n*\n* @return <code>true</code> if the sensor is supported and successfully\n* enabled\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "SensorManager#registerListener(SensorEventListener, Sensor, int)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "registerListener(SensorEventListener, Sensor, int)", "fullMethod": "boolean registerListener(SensorListener,int)", "method": "registerListener(SensorListener,int)"}, "onAttach": {"methodClass": "androidx.fragment.app.Fragment", "methodName": "onAttach", "replacementComments": "/**\n* Called when a fragment is first attached to its activity.\n* {@link #onCreate(Bundle)} will be called after this.\n*\n* @deprecated See {@link #onAttach(Context)}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "onAttach(Context)", "methodReturn": "void", "isValid": true, "cleanReplacement": "onAttach(Context)", "fullMethod": "void onAttach(Activity)", "method": "onAttach(Activity)"}, "writeInt32": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writeInt32", "replacementComments": "/**\n* Write a single proto \"int32\" type field value.\n*\n* Note that these are stored in memory as signed values and written as unsigned\n* varints, which if negative, are 10 bytes long. If you know the data is likely\n* to be negative, use \"sint32\".\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writeInt32(long,int)", "method": "writeInt32(long,int)"}, "getX": {"methodClass": "androidx.core.view.MotionEventCompat", "methodName": "getX", "replacementComments": "/**\n* Call {@link MotionEvent#getX(int)}.\n*\n* @deprecated Call {@link MotionEvent#getX()} directly. This method will be\n* removed in a future release.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "MotionEvent#getX()", "methodReturn": "float", "isValid": true, "cleanReplacement": "getX()", "fullMethod": "float getX(MotionEvent,int)", "method": "getX(MotionEvent,int)"}, "shouldLaunchDocument": {"methodClass": "androidx.navigation.NavOptions", "methodName": "shouldLaunchDocument", "replacementComments": "/**\n* Whether this navigation action should launch the destination in a new document.\n* <p>\n* This functions similarly to how {@link android.content.Intent#FLAG_ACTIVITY_NEW_DOCUMENT}\n* works with activites.\n* @deprecated As per the {@link android.content.Intent#FLAG_ACTIVITY_NEW_DOCUMENT}\n* documentation, it is recommended to use {@link android.R.attr#documentLaunchMode} on an\n* Activity you wish to launch as a new document.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "android.content.Intent#FLAG_ACTIVITY_NEW_DOCUMENT", "methodReturn": "boolean", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "boolean shouldLaunchDocument()", "method": "shouldLaunchDocument()"}, "initialize": {"methodClass": "androidx.leanback.widget.ShadowOverlayContainer", "methodName": "initialize", "replacementComments": "/**\n* Initialize shadows, color overlay.\n* @deprecated use {@link ShadowOverlayHelper#createShadowOverlayContainer(Context)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "ShadowOverlayHelper#createShadowOverlayContainer(Context)", "methodReturn": "void", "isValid": true, "cleanReplacement": "createShadowOverlayContainer(Context)", "fullMethod": "void initialize(boolean,boolean)", "method": "initialize(boolean,boolean)"}, "getNanoAppInstanceInfo": {"methodClass": "android.hardware.location.ContextHubManager", "methodName": "getNanoAppInstanceInfo", "replacementComments": "/**\n* get information about the nano app instance\n*\n* NOTE: The returned NanoAppInstanceInfo does _not_ contain correct\n* information for several fields, specifically:\n* - getName()\n* - getPublisher()\n* - getNeededExecMemBytes()\n* - getNeededReadMemBytes()\n* - getNeededWriteMemBytes()\n*\n* For example, say you call loadNanoApp() with a NanoApp that has\n* getName() returning \"My Name\".  Later, if you call getNanoAppInstanceInfo\n* for that nanoapp, the returned NanoAppInstanceInfo's getName()\n* method will claim \"Preloaded app, unknown\", even though you would\n* have expected \"My Name\".  For now, as the user, you'll need to\n* separately track the above fields if they are of interest to you.\n*\n* TODO(b/30943489): Have the returned NanoAppInstanceInfo contain the\n* correct information.\n*\n* @param nanoAppHandle handle of the nanoapp instance\n* @return NanoAppInstanceInfo the NanoAppInstanceInfo of the nanoapp, or null if the nanoapp\n* does not exist\n*\n* @see NanoAppInstanceInfo\n*\n* @deprecated Use {@link #queryNanoApps(ContextHubInfo)} instead to explicitly query the hub\n* for loaded nanoapps.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "queryNanoApps(ContextHubInfo)", "methodReturn": "NanoAppInstanceInfo", "isValid": true, "cleanReplacement": "queryNanoApps(ContextHubInfo)", "fullMethod": "NanoAppInstanceInfo getNanoAppInstanceInfo(int)", "method": "getNanoAppInstanceInfo(int)"}, "generate": {"methodClass": "androidx.palette.graphics.Palette", "methodName": "generate", "replacementComments": "/**\n* @deprecated Use {@link Builder} to generate the Palette.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "Builder", "methodReturn": "Palette", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "Palette generate(Bitmap)", "method": "generate(Bitmap)"}, "removeAccount": {"methodClass": "android.accounts.AccountManager", "methodName": "removeAccount", "replacementComments": "/**\n* Removes an account from the AccountManager.  Does nothing if the account\n* does not exist.  Does not delete the account from the server.\n* The authenticator may have its own policies preventing account\n* deletion, in which case the account will not be deleted.\n*\n* <p>This method requires the caller to have a signature match with the\n* authenticator that manages the specified account.\n*\n* <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,\n* MANAGE_ACCOUNTS permission is needed for those platforms. See docs for\n* this function in API level 22.\n*\n* @param account The {@link Account} to remove\n* @param callback Callback to invoke when the request completes,\n* null for no callback\n* @param handler {@link Handler} identifying the callback thread,\n* null for the main thread\n* @return An {@link AccountManagerFuture} which resolves to a Boolean,\n* true if the account has been successfully removed\n* @deprecated use\n* {@link #removeAccount(Account, Activity, AccountManagerCallback, Handler)}\n* instead\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "removeAccount(Account, Activity, AccountManagerCallback, Handler)", "methodReturn": "AccountManagerFuture<Boolean>", "isValid": true, "cleanReplacement": "removeAccount(Account, Activity, AccountManagerCallback, Handler)", "fullMethod": "AccountManagerFuture<Boolean> removeAccount(Account,AccountManagerCallback<Boolean>,Handler)", "method": "removeAccount(Account,AccountManagerCallback<Boolean>,Handler)"}, "getToIndex": {"methodClass": "androidx.core.view.accessibility.AccessibilityRecordCompat", "methodName": "getToIndex", "replacementComments": "/**\n* Gets the index of text selection end or the index of the last\n* visible item when scrolling.\n*\n* @return The index of selection end or last item index.\n*\n* @deprecated Use {@link AccessibilityRecord#getToIndex()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityRecord#getToIndex()", "methodReturn": "int", "isValid": true, "cleanReplacement": "AccessibilityRecord#getToIndex()", "fullMethod": "int getToIndex()", "method": "getToIndex()"}, "switchToLastInputMethod": {"methodClass": "android.view.inputmethod.InputMethodManager", "methodName": "switchToLastInputMethod", "replacementComments": "/**\n* Force switch to the last used input method and subtype. If the last input method didn't have\n* any subtypes, the framework will simply switch to the last input method with no subtype\n* specified.\n* @param imeToken Supplies the identifying token given to an input method when it was started,\n* which allows it to perform this operation on itself.\n* @return true if the current input method and subtype was successfully switched to the last\n* used input method and subtype.\n* @deprecated Use {@link InputMethodService#switchToPreviousInputMethod()} instead. This method\n* was intended for IME developers who should be accessing APIs through the service. APIs in\n* this class are intended for app developers interacting with the IME.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "InputMethodService#switchToPreviousInputMethod()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "switchToPreviousInputMethod()", "fullMethod": "boolean switchToLastInputMethod(IBinder)", "method": "switchToLastInputMethod(IBinder)"}, "onInitializeAccessibilityEvent": {"methodClass": "androidx.core.view.ViewCompat", "methodName": "onInitializeAccessibilityEvent", "replacementComments": "/**\n* Initializes an {@link AccessibilityEvent} with information about\n* this View which is the event source. In other words, the source of\n* an accessibility event is the view whose state change triggered firing\n* the event.\n* <p>\n* Example: Setting the password property of an event in addition\n* to properties set by the super implementation:\n* <pre> public void onInitializeAccessibilityEvent(AccessibilityEvent event) {\n* super.onInitializeAccessibilityEvent(event);\n* event.setPassword(true);\n* }</pre>\n* <p>\n* If an {@link AccessibilityDelegateCompat} has been specified via calling\n* {@link ViewCompat#setAccessibilityDelegate(View, AccessibilityDelegateCompat)}, its\n* {@link AccessibilityDelegateCompat#onInitializeAccessibilityEvent(View, AccessibilityEvent)}\n* is responsible for handling this call.\n*\n* @param v The View against which to invoke the method.\n* @param event The event to initialize.\n*\n* @see View#sendAccessibilityEvent(int)\n* @see View#dispatchPopulateAccessibilityEvent(AccessibilityEvent)\n*\n* @deprecated Call {@link View#onInitializeAccessibilityEvent(AccessibilityEvent)} directly.\n* This method will be removed in a future release.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "View#onInitializeAccessibilityEvent(AccessibilityEvent)", "methodReturn": "void", "isValid": true, "cleanReplacement": "onInitializeAccessibilityEvent(AccessibilityEvent)", "fullMethod": "void onInitializeAccessibilityEvent(View,AccessibilityEvent)", "method": "onInitializeAccessibilityEvent(View,AccessibilityEvent)"}, "isFadingEnabled": {"methodClass": "androidx.leanback.app.PlaybackFragment", "methodName": "isFadingEnabled", "replacementComments": "/**\n* @deprecated Uses {@link #isControlsOverlayAutoHideEnabled()}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "isControlsOverlayAutoHideEnabled()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "isControlsOverlayAutoHideEnabled()", "fullMethod": "boolean isFadingEnabled()", "method": "isFadingEnabled()"}, "setTitleItem": {"methodClass": "androidx.slice.builders.ListBuilder.RowBuilder", "methodName": "setTitleItem", "replacementComments": "/**\n* Sets the title item to be the provided icon. There can only be one title item, this\n* will replace any other title items that may have been set.\n*\n* @deprecated TO BE REMOVED; use ListBuilder{@link #setTitleItem(Icon, int, boolean)}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setTitleItem(Icon, int, boolean)", "methodReturn": "RowBuilder", "isValid": true, "cleanReplacement": "setTitleItem(Icon, int, boolean)", "fullMethod": "RowBuilder setTitleItem(IconCompat)", "method": "setTitleItem(IconCompat)"}, "writeRepeatedDouble": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writeRepeatedDouble", "replacementComments": "/**\n* Write a single repeated proto \"double\" type field value.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writeRepeatedDouble(long,double)", "method": "writeRepeatedDouble(long,double)"}, "getVerticalMargin": {"methodClass": "androidx.leanback.widget.BaseGridView", "methodName": "getVerticalMargin", "replacementComments": "/**\n* Returns the spacing in pixels between two child items vertically.\n* @deprecated Use {@link #getVerticalSpacing()}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getVerticalSpacing()", "methodReturn": "int", "isValid": true, "cleanReplacement": "getVerticalSpacing()", "fullMethod": "int getVerticalMargin()", "method": "getVerticalMargin()"}, "setFitsSystemWindows": {"methodClass": "androidx.core.view.ViewCompat", "methodName": "setFitsSystemWindows", "replacementComments": "/**\n* Sets whether or not this view should account for system screen decorations\n* such as the status bar and inset its content; that is, controlling whether\n* the default implementation of {@link View#fitSystemWindows(Rect)} will be\n* executed. See that method for more details.\n*\n* @deprecated Use {@link View#setFitsSystemWindows(boolean)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "View#setFitsSystemWindows(boolean)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setFitsSystemWindows(boolean)", "fullMethod": "void setFitsSystemWindows(View,boolean)", "method": "setFitsSystemWindows(View,boolean)"}, "pingSupplicant": {"methodClass": "android.net.wifi.WifiManager", "methodName": "pingSupplicant", "replacementComments": "/**\n* Check that the supplicant daemon is responding to requests.\n* @return {@code true} if we were able to communicate with the supplicant and\n* it returned the expected response to the PING message.\n* @deprecated Will return the output of {@link #isWifiEnabled()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "isWifiEnabled()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "isWifiEnabled()", "fullMethod": "boolean pingSupplicant()", "method": "pingSupplicant()"}, "writeRepeatedUInt64": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writeRepeatedUInt64", "replacementComments": "/**\n* Write a single proto \"uint64\" type field value.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writeRepeatedUInt64(long,long)", "method": "writeRepeatedUInt64(long,long)"}, "getClientState": {"methodClass": "android.service.autofill.FillEventHistory", "methodName": "getClientState", "replacementComments": "/**\n* Returns the client state set in the previous {@link FillResponse}.\n*\n* <p><b>Note: </b>the state is associated with the app that was autofilled in the previous\n* {@link AutofillService#onFillRequest(FillRequest, android.os.CancellationSignal, FillCallback)}\n* , which is not necessary the same app being autofilled now.\n*\n* @deprecated use {@link #getEvents()} then {@link Event#getClientState()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getEvents()", "methodReturn": "Bundle", "isValid": true, "cleanReplacement": "getEvents()", "fullMethod": "Bundle getClientState()", "method": "getClientState()"}, "getFromIndex": {"methodClass": "androidx.core.view.accessibility.AccessibilityRecordCompat", "methodName": "getFromIndex", "replacementComments": "/**\n* Gets the index of the first character of the changed sequence,\n* or the beginning of a text selection or the index of the first\n* visible item when scrolling.\n*\n* @return The index of the first character or selection\n* start or the first visible item.\n*\n* @deprecated Use {@link AccessibilityRecord#getFromIndex()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityRecord#getFromIndex()", "methodReturn": "int", "isValid": true, "cleanReplacement": "AccessibilityRecord#getFromIndex()", "fullMethod": "int getFromIndex()", "method": "getFromIndex()"}, "getBeforeText": {"methodClass": "androidx.core.view.accessibility.AccessibilityRecordCompat", "methodName": "getBeforeText", "replacementComments": "/**\n* Sets the text before a change.\n*\n* @return The text before the change.\n*\n* @deprecated Use {@link AccessibilityRecord#getBeforeText()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityRecord#getBeforeText()", "methodReturn": "CharSequence", "isValid": true, "cleanReplacement": "AccessibilityRecord#getBeforeText()", "fullMethod": "CharSequence getBeforeText()", "method": "getBeforeText()"}, "getUidTcpTxBytes": {"methodClass": "android.net.TrafficStats", "methodName": "getUidTcpTxBytes", "replacementComments": "/**\n* @deprecated Starting in {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2},\n* transport layer statistics are no longer available, and will\n* always return {@link #UNSUPPORTED}.\n* @see #getUidTxBytes(int)\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getUidTxBytes(int)", "methodReturn": "long", "isValid": true, "cleanReplacement": "getUidTxBytes(int)", "fullMethod": "long getUidTcpTxBytes(int)", "method": "getUidTcpTxBytes(int)"}, "addAction": {"methodClass": "android.app.Notification.Builder", "methodName": "addAction", "replacementComments": "/**\n* Add an action to this notification. Actions are typically displayed by\n* the system as a button adjacent to the notification content.\n* <p>\n* Every action must have an icon (32dp square and matching the\n* <a href=\"{@docRoot}design/style/iconography.html#action-bar\">Holo\n* Dark action bar</a> visual style), a textual label, and a {@link PendingIntent}.\n* <p>\n* A notification in its expanded form can display up to 3 actions, from left to right in\n* the order they were added. Actions will not be displayed when the notification is\n* collapsed, however, so be sure that any essential functions may be accessed by the user\n* in some other way (for example, in the Activity pointed to by {@link #contentIntent}).\n*\n* @param icon Resource ID of a drawable that represents the action.\n* @param title Text describing the action.\n* @param intent PendingIntent to be fired when the action is invoked.\n*\n* @deprecated Use {@link #addAction(Action)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "addAction(Action)", "methodReturn": "Builder", "isValid": true, "cleanReplacement": "addAction(Action)", "fullMethod": "Builder addAction(int,CharSequence,PendingIntent)", "method": "addAction(int,CharSequence,PendingIntent)"}, "suspend": {"methodClass": "java.lang.ThreadGroup", "methodName": "suspend", "replacementComments": "/**\n* Suspends all threads in this thread group.\n* <p>\n* First, the <code>checkAccess</code> method of this thread group is\n* called with no arguments; this may result in a security exception.\n* <p>\n* This method then calls the <code>suspend</code> method on all the\n* threads in this thread group and in all of its subgroups.\n*\n* @exception  SecurityException  if the current thread is not allowed\n* to access this thread group or any of the threads in\n* the thread group.\n* @see        java.lang.Thread#suspend()\n* @see        java.lang.SecurityException\n* @see        java.lang.ThreadGroup#checkAccess()\n* @since      JDK1.0\n* @deprecated    This method is inherently deadlock-prone.  See\n* {@link Thread#suspend} for details.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "Thread#suspend", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void suspend()", "method": "suspend()"}, "invalidateChild": {"methodClass": "android.view.ViewParent", "methodName": "invalidateChild", "replacementComments": "/**\n* All or part of a child is dirty and needs to be redrawn.\n*\n* @param child The child which is dirty\n* @param r The area within the child that is invalid\n*\n* @deprecated Use {@link #onDescendantInvalidated(View, View)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "onDescendantInvalidated(View, View)", "methodReturn": "void", "isValid": true, "cleanReplacement": "onDescendantInvalidated(View, View)", "fullMethod": "void invalidateChild(View,Rect)", "method": "invalidateChild(View,Rect)"}, "setSource": {"methodClass": "androidx.core.view.accessibility.AccessibilityRecordCompat", "methodName": "setSource", "replacementComments": "/**\n* Sets the source to be a virtual descendant of the given <code>root</code>.\n* If <code>virtualDescendantId</code> equals to {@link View#NO_ID} the root\n* is set as the source.\n* <p>\n* A virtual descendant is an imaginary View that is reported as a part of the view\n* hierarchy for accessibility purposes. This enables custom views that draw complex\n* content to report them selves as a tree of virtual views, thus conveying their\n* logical structure.\n* </p>\n*\n* @param root The root of the virtual subtree.\n* @param virtualDescendantId The id of the virtual descendant.\n*\n* @deprecated Use {@link #setSource(AccessibilityRecord, View, int)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setSource(AccessibilityRecord, View, int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setSource(AccessibilityRecord, View, int)", "fullMethod": "void setSource(View,int)", "method": "setSource(View,int)"}, "incrementOperationCount": {"methodClass": "androidx.core.net.TrafficStatsCompat", "methodName": "incrementOperationCount", "replacementComments": "/**\n* Increment count of network operations performed under the given\n* accounting tag. This can be used to derive bytes-per-operation.\n*\n* @param tag Accounting tag used in {@link #setThreadStatsTag(int)}.\n* @param operationCount Number of operations to increment count by.\n*\n* @deprecated Use {@link TrafficStats#incrementOperationCount(int, int)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "TrafficStats#incrementOperationCount(int, int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "incrementOperationCount(int, int)", "fullMethod": "void incrementOperationCount(int,int)", "method": "incrementOperationCount(int,int)"}, "getTargetPackage": {"methodClass": "android.app.PendingIntent", "methodName": "getTargetPackage", "replacementComments": "/**\n* @deprecated Renamed to {@link #getCreatorPackage()}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getCreatorPackage()", "methodReturn": "String", "isValid": true, "cleanReplacement": "getCreatorPackage()", "fullMethod": "String getTargetPackage()", "method": "getTargetPackage()"}, "onAccessibilityStateChanged": {"methodClass": "androidx.core.view.accessibility.AccessibilityManagerCompat.AccessibilityStateChangeListener", "methodName": "onAccessibilityStateChanged", "replacementComments": "/**\n* Called back on change in the accessibility state.\n*\n* @param enabled Whether accessibility is enabled.\n*\n* @deprecated Use {@link AccessibilityManager.AccessibilityStateChangeListener} directly.\n*/\n", "isClassDeprecated": true, "dirtyReplacement": "AccessibilityManager.AccessibilityStateChangeListener", "methodReturn": "void", "isValid": true, "cleanReplacement": "AccessibilityManager.AccessibilityStateChangeListener", "fullMethod": "void onAccessibilityStateChanged(boolean)", "method": "onAccessibilityStateChanged(boolean)"}, "newKeyguardLock": {"methodClass": "android.app.KeyguardManager", "methodName": "newKeyguardLock", "replacementComments": "/**\n* @deprecated Use {@link LayoutParams#FLAG_DISMISS_KEYGUARD}\n* and/or {@link LayoutParams#FLAG_SHOW_WHEN_LOCKED}\n* instead; this allows you to seamlessly hide the keyguard as your application\n* moves in and out of the foreground and does not require that any special\n* permissions be requested.\n*\n* Enables you to lock or unlock the keyboard. Get an instance of this class by\n* calling {@link android.content.Context#getSystemService(java.lang.String) Context.getSystemService()}.\n* This class is wrapped by {@link android.app.KeyguardManager KeyguardManager}.\n* @param tag A tag that informally identifies who you are (for debugging who\n* is disabling he keyguard).\n*\n* @return A {@link KeyguardLock} handle to use to disable and reenable the\n* keyguard.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "LayoutParams#FLAG_DISMISS_KEYGUARD", "methodReturn": "KeyguardLock", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "KeyguardLock newKeyguardLock(String)", "method": "newKeyguardLock(String)"}, "allowPurging": {"methodClass": "android.os.MemoryFile", "methodName": "allowPurging", "replacementComments": "/**\n* Enables or disables purging of the memory file.\n*\n* @param allowPurging true if the operating system can purge the contents\n* of the file in low memory situations\n* @return previous value of allowPurging\n*\n* @deprecated Purgable is considered generally fragile and hard to use safely. Applications\n* are recommend to instead use {@link android.content.ComponentCallbacks2#onTrimMemory(int)}\n* to react to memory events and release shared memory regions as appropriate.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "android.content.ComponentCallbacks2#onTrimMemory(int)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "onTrimMemory(int)", "fullMethod": "boolean allowPurging(boolean)", "method": "allowPurging(boolean)"}, "setOrbColor": {"methodClass": "androidx.leanback.widget.SearchOrbView", "methodName": "setOrbColor", "replacementComments": "/**\n* Sets the search orb colors.\n* Other colors are provided by the framework.\n* @deprecated Use {@link #setOrbColors(Colors)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setOrbColors(Colors)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setOrbColors(Colors)", "fullMethod": "void setOrbColor(int,int)", "method": "setOrbColor(int,int)"}, "fitSystemWindows": {"methodClass": "android.view.View", "methodName": "fitSystemWindows", "replacementComments": "/**\n* Called by the view hierarchy when the content insets for a window have\n* changed, to allow it to adjust its content to fit within those windows.\n* The content insets tell you the space that the status bar, input method,\n* and other system windows infringe on the application's window.\n*\n* <p>You do not normally need to deal with this function, since the default\n* window decoration given to applications takes care of applying it to the\n* content of the window.  If you use {@link #SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN}\n* or {@link #SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION} this will not be the case,\n* and your content can be placed under those system elements.  You can then\n* use this method within your view hierarchy if you have parts of your UI\n* which you would like to ensure are not being covered.\n*\n* <p>The default implementation of this method simply applies the content\n* insets to the view's padding, consuming that content (modifying the\n* insets to be 0), and returning true.  This behavior is off by default, but can\n* be enabled through {@link #setFitsSystemWindows(boolean)}.\n*\n* <p>This function's traversal down the hierarchy is depth-first.  The same content\n* insets object is propagated down the hierarchy, so any changes made to it will\n* be seen by all following views (including potentially ones above in\n* the hierarchy since this is a depth-first traversal).  The first view\n* that returns true will abort the entire traversal.\n*\n* <p>The default implementation works well for a situation where it is\n* used with a container that covers the entire window, allowing it to\n* apply the appropriate insets to its content on all edges.  If you need\n* a more complicated layout (such as two different views fitting system\n* windows, one on the top of the window, and one on the bottom),\n* you can override the method and handle the insets however you would like.\n* Note that the insets provided by the framework are always relative to the\n* far edges of the window, not accounting for the location of the called view\n* within that window.  (In fact when this method is called you do not yet know\n* where the layout will place the view, as it is done before layout happens.)\n*\n* <p>Note: unlike many View methods, there is no dispatch phase to this\n* call.  If you are overriding it in a ViewGroup and want to allow the\n* call to continue to your children, you must be sure to call the super\n* implementation.\n*\n* <p>Here is a sample layout that makes use of fitting system windows\n* to have controls for a video view placed inside of the window decorations\n* that it hides and shows.  This can be used with code like the second\n* sample (video player) shown in {@link #setSystemUiVisibility(int)}.\n*\n* {@sample development/samples/ApiDemos/res/layout/video_player.xml complete}\n*\n* @param insets Current content insets of the window.  Prior to\n* {@link android.os.Build.VERSION_CODES#JELLY_BEAN} you must not modify\n* the insets or else you and Android will be unhappy.\n*\n* @return {@code true} if this view applied the insets and it should not\n* continue propagating further down the hierarchy, {@code false} otherwise.\n* @see #getFitsSystemWindows()\n* @see #setFitsSystemWindows(boolean)\n* @see #setSystemUiVisibility(int)\n*\n* @deprecated As of API 20 use {@link #dispatchApplyWindowInsets(WindowInsets)} to apply\n* insets to views. Views should override {@link #onApplyWindowInsets(WindowInsets)} or use\n* {@link #setOnApplyWindowInsetsListener(android.view.View.OnApplyWindowInsetsListener)}\n* to implement handling their own insets.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "dispatchApplyWindowInsets(WindowInsets)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "dispatchApplyWindowInsets(WindowInsets)", "fullMethod": "boolean fitSystemWindows(Rect)", "method": "fitSystemWindows(Rect)"}, "copyToFileOrThrow": {"methodClass": "android.os.FileUtils", "methodName": "copyToFileOrThrow", "replacementComments": "/**\n* @deprecated use {@link #copy(InputStream, OutputStream)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "copy(InputStream, OutputStream)", "methodReturn": "void", "isValid": true, "cleanReplacement": "copy(InputStream, OutputStream)", "fullMethod": "void copyToFileOrThrow(InputStream,File)", "method": "copyToFileOrThrow(InputStream,File)"}, "getCurrentTime": {"methodClass": "androidx.leanback.widget.PlaybackControlsRow", "methodName": "getCurrentTime", "replacementComments": "/**\n* Returns the current time in milliseconds for the playback controls row.\n* @throws ArithmeticException If current time in milliseconds overflows int.\n* @deprecated Use {@link #getCurrentPosition()}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getCurrentPosition()", "methodReturn": "int", "isValid": true, "cleanReplacement": "getCurrentPosition()", "fullMethod": "int getCurrentTime()", "method": "getCurrentTime()"}, "onFilterSms": {"methodClass": "android.service.carrier.CarrierMessagingService", "methodName": "onFilterSms", "replacementComments": "/**\n* Override this method to filter inbound SMS messages.\n*\n* @param pdu the PDUs of the message\n* @param format the format of the PDUs, typically \"3gpp\" or \"3gpp2\"\n* @param destPort the destination port of a binary SMS, this will be -1 for text SMS\n* @param subId SMS subscription ID of the SIM\n* @param callback result callback. Call with {@code true} to keep an inbound SMS message and\n* deliver to SMS apps, and {@code false} to drop the message.\n* @deprecated Use {@link #onReceiveTextSms} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "onReceiveTextSms", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void onFilterSms(MessagePdu,String,int,int,ResultCallback<Boolean>)", "method": "onFilterSms(MessagePdu,String,int,int,ResultCallback<Boolean>)"}, "tagSocket": {"methodClass": "androidx.core.net.TrafficStatsCompat", "methodName": "tagSocket", "replacementComments": "/**\n* Tag the given {@link Socket} with any statistics parameters active for\n* the current thread. Subsequent calls always replace any existing\n* parameters. When finished, call {@link #untagSocket(Socket)} to remove\n* statistics parameters.\n*\n* @see #setThreadStatsTag(int)\n*\n* @deprecated Use {@link TrafficStats#tagSocket(Socket)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "TrafficStats#tagSocket(Socket)", "methodReturn": "void", "isValid": true, "cleanReplacement": "TrafficStats#tagSocket(Socket)", "fullMethod": "void tagSocket(Socket)", "method": "tagSocket(Socket)"}, "setTitleColor": {"methodClass": "android.app.Activity", "methodName": "setTitleColor", "replacementComments": "/**\n* Change the color of the title associated with this activity.\n* <p>\n* This method is deprecated starting in API Level 11 and replaced by action\n* bar styles. For information on styling the Action Bar, read the <a\n* href=\"{@docRoot} guide/topics/ui/actionbar.html\">Action Bar</a> developer\n* guide.\n*\n* @deprecated Use action bar styles instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "action bar styles", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void setTitleColor(int)", "method": "setTitleColor(int)"}, "sendStickyOrderedBroadcast": {"methodClass": "android.content.Context", "methodName": "sendStickyOrderedBroadcast", "replacementComments": "/**\n* <p>Version of {@link #sendStickyBroadcast} that allows you to\n* receive data back from the broadcast.  This is accomplished by\n* supplying your own BroadcastReceiver when calling, which will be\n* treated as a final receiver at the end of the broadcast -- its\n* {@link BroadcastReceiver#onReceive} method will be called with\n* the result values collected from the other receivers.  The broadcast will\n* be serialized in the same way as calling\n* {@link #sendOrderedBroadcast(Intent, String)}.\n*\n* <p>Like {@link #sendBroadcast(Intent)}, this method is\n* asynchronous; it will return before\n* resultReceiver.onReceive() is called.  Note that the sticky data\n* stored is only the data you initially supply to the broadcast, not\n* the result of any changes made by the receivers.\n*\n* <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.\n*\n* @deprecated Sticky broadcasts should not be used.  They provide no security (anyone\n* can access them), no protection (anyone can modify them), and many other problems.\n* The recommended pattern is to use a non-sticky broadcast to report that <em>something</em>\n* has changed, with another mechanism for apps to retrieve the current value whenever\n* desired.\n*\n* @param intent The Intent to broadcast; all receivers matching this\n* Intent will receive the broadcast.\n* @param resultReceiver Your own BroadcastReceiver to treat as the final\n* receiver of the broadcast.\n* @param scheduler A custom Handler with which to schedule the\n* resultReceiver callback; if null it will be\n* scheduled in the Context's main thread.\n* @param initialCode An initial value for the result code.  Often\n* Activity.RESULT_OK.\n* @param initialData An initial value for the result data.  Often\n* null.\n* @param initialExtras An initial value for the result extras.  Often\n* null.\n*\n* @see #sendBroadcast(Intent)\n* @see #sendBroadcast(Intent, String)\n* @see #sendOrderedBroadcast(Intent, String)\n* @see #sendStickyBroadcast(Intent)\n* @see android.content.BroadcastReceiver\n* @see #registerReceiver\n* @see android.app.Activity#RESULT_OK\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "sendBroadcast(Intent)", "methodReturn": "void", "isValid": true, "cleanReplacement": "sendBroadcast(Intent)", "fullMethod": "void sendStickyOrderedBroadcast(Intent,BroadcastReceiver,Handler,int,String,Bundle)", "method": "sendStickyOrderedBroadcast(Intent,BroadcastReceiver,Handler,int,String,Bundle)"}, "hasPermanentMenuKey": {"methodClass": "androidx.core.view.ViewConfigurationCompat", "methodName": "hasPermanentMenuKey", "replacementComments": "/**\n* Report if the device has a permanent menu key available to the user, in a backwards\n* compatible way.\n*\n* @deprecated Use {@link ViewConfiguration#hasPermanentMenuKey()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "ViewConfiguration#hasPermanentMenuKey()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "hasPermanentMenuKey()", "fullMethod": "boolean hasPermanentMenuKey(ViewConfiguration)", "method": "hasPermanentMenuKey(ViewConfiguration)"}, "getAudioState": {"methodClass": "android.telecom.Phone", "methodName": "getAudioState", "replacementComments": "/**\n* Obtains the current phone call audio state of the {@code Phone}.\n*\n* @return An object encapsulating the audio state.\n* @deprecated Use {@link #getCallAudioState()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getCallAudioState()", "methodReturn": "AudioState", "isValid": true, "cleanReplacement": "getCallAudioState()", "fullMethod": "AudioState getAudioState()", "method": "getAudioState()"}, "onRestoreInstanceState": {"methodClass": "androidx.legacy.app.FragmentTabHost", "methodName": "onRestoreInstanceState", "replacementComments": "/**\n* @deprecated Use {@link androidx.fragment.app.FragmentTabHost} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "androidx.fragment.app.FragmentTabHost", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void onRestoreInstanceState(Parcelable)", "method": "onRestoreInstanceState(Parcelable)"}, "getTotalTime": {"methodClass": "androidx.leanback.widget.PlaybackControlsRow", "methodName": "getTotalTime", "replacementComments": "/**\n* Returns the total time in milliseconds for the playback controls row.\n* @throws ArithmeticException If total time in milliseconds overflows int.\n* @deprecated use {@link #getDuration()}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getDuration()", "methodReturn": "int", "isValid": true, "cleanReplacement": "getDuration()", "fullMethod": "int getTotalTime()", "method": "getTotalTime()"}, "setX": {"methodClass": "androidx.core.view.ViewCompat", "methodName": "setX", "replacementComments": "/**\n* Sets the visual x position of this view, in pixels. This is equivalent to setting the\n* {@link #setTranslationX(View, float) translationX} property to be the difference between\n* the x value passed in and the current left property of the view as determined\n* by the layout bounds.\n*\n* @param value The visual x position of this view, in pixels.\n*\n* @deprecated Use {@link View#setX(float)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "View#setX(float)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setX(float)", "fullMethod": "void setX(View,float)", "method": "setX(View,float)"}, "getFadingEdgeLength": {"methodClass": "android.view.ViewConfiguration", "methodName": "getFadingEdgeLength", "replacementComments": "/**\n* @return the length of the fading edges in dips\n*\n* @deprecated Use {@link #getScaledFadingEdgeLength()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getScaledFadingEdgeLength()", "methodReturn": "int", "isValid": true, "cleanReplacement": "getScaledFadingEdgeLength()", "fullMethod": "int getFadingEdgeLength()", "method": "getFadingEdgeLength()"}, "vibrate": {"methodClass": "android.os.Vibrator", "methodName": "vibrate", "replacementComments": "/**\n* Vibrate with a given pattern.\n*\n* <p>\n* Pass in an array of ints that are the durations for which to turn on or off\n* the vibrator in milliseconds.  The first value indicates the number of milliseconds\n* to wait before turning the vibrator on.  The next value indicates the number of milliseconds\n* for which to keep the vibrator on before turning it off.  Subsequent values alternate\n* between durations in milliseconds to turn the vibrator off or to turn the vibrator on.\n* </p><p>\n* To cause the pattern to repeat, pass the index into the pattern array at which\n* to start the repeat, or -1 to disable repeating.\n* </p>\n*\n* @param pattern an array of longs of times for which to turn the vibrator on or off.\n* @param repeat the index into pattern at which to repeat, or -1 if\n* you don't want to repeat.\n*\n* @deprecated Use {@link #vibrate(VibrationEffect)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "vibrate(VibrationEffect)", "methodReturn": "void", "isValid": true, "cleanReplacement": "vibrate(VibrationEffect)", "fullMethod": "void vibrate(long[],int)", "method": "vibrate(long[],int)"}, "invalidateOptionsMenu": {"methodClass": "androidx.core.app.ActivityCompat", "methodName": "invalidateOptionsMenu", "replacementComments": "/**\n* Invalidate the activity's options menu, if able.\n*\n* <p>Before API level 11 (Android 3.0/Honeycomb) the lifecycle of the\n* options menu was controlled primarily by the user's operation of\n* the hardware menu key. When the user presses down on the menu key\n* for the first time the menu was created and prepared by calls\n* to {@link Activity#onCreateOptionsMenu(android.view.Menu)} and\n* {@link Activity#onPrepareOptionsMenu(android.view.Menu)} respectively.\n* Subsequent presses of the menu key kept the existing instance of the\n* Menu itself and called {@link Activity#onPrepareOptionsMenu(android.view.Menu)}\n* to give the activity an opportunity to contextually alter the menu\n* before the menu panel was shown.</p>\n*\n* <p>In Android 3.0+ the Action Bar forces the options menu to be built early\n* so that items chosen to show as actions may be displayed when the activity\n* first becomes visible. The Activity method invalidateOptionsMenu forces\n* the entire menu to be destroyed and recreated from\n* {@link Activity#onCreateOptionsMenu(android.view.Menu)}, offering a similar\n* though heavier-weight opportunity to change the menu's contents. Normally\n* this functionality is used to support a changing configuration of Fragments.</p>\n*\n* <p>Applications may use this support helper to signal a significant change in\n* activity state that should cause the options menu to be rebuilt. If the app\n* is running on an older platform version that does not support menu invalidation\n* the app will still receive {@link Activity#onPrepareOptionsMenu(android.view.Menu)}\n* the next time the user presses the menu key and this method will return false.\n* If this method returns true the options menu was successfully invalidated.</p>\n*\n* @param activity Invalidate the options menu of this activity\n* @return true if this operation was supported and it completed; false if it was not available.\n* @deprecated Use {@link Activity#invalidateOptionsMenu()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "Activity#invalidateOptionsMenu()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "invalidateOptionsMenu()", "fullMethod": "boolean invalidateOptionsMenu(Activity)", "method": "invalidateOptionsMenu(Activity)"}, "getSetting": {"methodClass": "android.provider.Contacts.Settings", "methodName": "getSetting", "replacementComments": "/**\n* @deprecated see {@link android.provider.ContactsContract}\n*/\n", "isClassDeprecated": true, "dirtyReplacement": "android.provider.ContactsContract", "methodReturn": "String", "isValid": true, "cleanReplacement": "android.provider.ContactsContract", "fullMethod": "String getSetting(ContentResolver,String,String)", "method": "getSetting(ContentResolver,String,String)"}, "setAudioStreamType": {"methodClass": "android.media.MediaPlayer", "methodName": "setAudioStreamType", "replacementComments": "/**\n* Sets the audio stream type for this MediaPlayer. See {@link AudioManager}\n* for a list of stream types. Must call this method before prepare() or\n* prepareAsync() in order for the target stream type to become effective\n* thereafter.\n*\n* @param streamtype the audio stream type\n* @deprecated use {@link #setAudioAttributes(AudioAttributes)}\n* @see android.media.AudioManager\n*/\n", "isClassDeprecated": true, "dirtyReplacement": "android.media.AudioManager", "methodReturn": "void", "isValid": true, "cleanReplacement": "android.media.AudioManager", "fullMethod": "void setAudioStreamType(int)", "method": "setAudioStreamType(int)"}, "getSubChannel": {"methodClass": "android.hardware.radio.RadioManager.ProgramInfo", "methodName": "getSubChannel", "replacementComments": "/**\n* Sub channel ID. E.g 1 for HD radio HD1\n* @return the program sub channel\n* @deprecated Use {@link getSelector()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getSelector()", "methodReturn": "int", "isValid": true, "cleanReplacement": "getSelector()", "fullMethod": "int getSubChannel()", "method": "getSubChannel()"}, "setProvisionedStringValue": {"methodClass": "com.android.ims.ImsConfig", "methodName": "setProvisionedStringValue", "replacementComments": "/**\n* @deprecated see {@link #setConfig(int, String)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setConfig(int, String)", "methodReturn": "int", "isValid": true, "cleanReplacement": "setConfig(int, String)", "fullMethod": "int setProvisionedStringValue(int,String)", "method": "setProvisionedStringValue(int,String)"}, "isActionViewExpanded": {"methodClass": "androidx.core.view.MenuItemCompat", "methodName": "isActionViewExpanded", "replacementComments": "/**\n* Returns true if this menu item's action view has been expanded.\n*\n* @return true if the item's action view is expanded, false otherwise.\n* @see #expandActionView(MenuItem)\n* @see #collapseActionView(MenuItem)\n* @see #SHOW_AS_ACTION_COLLAPSE_ACTION_VIEW\n* @see androidx.core.view.MenuItemCompat.OnActionExpandListener\n*\n* @deprecated Use {@link MenuItem#isActionViewExpanded()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "MenuItem#isActionViewExpanded()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "isActionViewExpanded()", "fullMethod": "boolean isActionViewExpanded(MenuItem)", "method": "isActionViewExpanded(MenuItem)"}, "openFileDescriptor": {"methodClass": "android.os.Parcel", "methodName": "openFileDescriptor", "replacementComments": "/**\n* @deprecated use {@link android.system.Os#open(String, int, int)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "android.system.Os#open(String, int, int)", "methodReturn": "FileDescriptor", "isValid": true, "cleanReplacement": "open(String, int, int)", "fullMethod": "FileDescriptor openFileDescriptor(String,int)", "method": "openFileDescriptor(String,int)"}, "clipRect": {"methodClass": "android.graphics.Canvas", "methodName": "clipRect", "replacementComments": "/**\n* Modify the current clip with the specified rectangle, which is\n* expressed in local coordinates.\n*\n* @param rect The rectangle to intersect with the current clip.\n* @param op How the clip is modified\n* @return true if the resulting clip is non-empty\n*\n* @deprecated Region.Op values other than {@link Region.Op#INTERSECT} and\n* {@link Region.Op#DIFFERENCE} have the ability to expand the clip. The canvas clipping APIs\n* are intended to only expand the clip as a result of a restore operation. This enables a view\n* parent to clip a canvas to clearly define the maximal drawing area of its children. The\n* recommended alternative calls are {@link #clipRect(Rect)} and {@link #clipOutRect(Rect)};\n*\n* As of API Level API level {@value Build.VERSION_CODES#P} only {@link Region.Op#INTERSECT} and\n* {@link Region.Op#DIFFERENCE} are valid Region.Op parameters.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "Region.Op#INTERSECT", "methodReturn": "boolean", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "boolean clipRect(Rect,Op)", "method": "clipRect(Rect,Op)"}, "setButton": {"methodClass": "android.app.AlertDialog", "methodName": "setButton", "replacementComments": "/**\n* Set a listener to be invoked when button 1 of the dialog is pressed.\n*\n* @param text The text to display in button 1.\n* @param listener The {@link DialogInterface.OnClickListener} to use.\n* @deprecated Use\n* {@link #setButton(int, CharSequence, android.content.DialogInterface.OnClickListener)}\n* with {@link DialogInterface#BUTTON_POSITIVE}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setButton(int, CharSequence, android.content.DialogInterface.OnClickListener)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setButton(int, CharSequence, android.content.DialogInterface.OnClickListener)", "fullMethod": "void setButton(CharSequence,OnClickListener)", "method": "setButton(CharSequence,OnClickListener)"}, "isPassword": {"methodClass": "androidx.core.view.accessibility.AccessibilityRecordCompat", "methodName": "isPassword", "replacementComments": "/**\n* Gets if the source is a password field.\n*\n* @return True if the view is a password field, false otherwise.\n*\n* @deprecated Use {@link AccessibilityRecord#isPassword()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityRecord#isPassword()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "AccessibilityRecord#isPassword()", "fullMethod": "boolean isPassword()", "method": "isPassword()"}, "setReparent": {"methodClass": "android.transition.ChangeBounds", "methodName": "setReparent", "replacementComments": "/**\n* Setting this flag tells ChangeBounds to track the before/after parent\n* of every view using this transition. The flag is not enabled by\n* default because it requires the parent instances to be the same\n* in the two scenes or else all parents must use ids to allow\n* the transition to determine which parents are the same.\n*\n* @param reparent true if the transition should track the parent\n* container of target views and animate parent changes.\n* @deprecated Use {@link android.transition.ChangeTransform} to handle\n* transitions between different parents.\n*/\n", "isClassDeprecated": true, "dirtyReplacement": "android.transition.ChangeTransform", "methodReturn": "void", "isValid": true, "cleanReplacement": "android.transition.ChangeTransform", "fullMethod": "void setReparent(boolean)", "method": "setReparent(boolean)"}, "setSound": {"methodClass": "android.app.Notification.Builder", "methodName": "setSound", "replacementComments": "/**\n* Set the sound to play.\n*\n* It will be played using the {@link #AUDIO_ATTRIBUTES_DEFAULT default audio attributes}\n* for notifications.\n*\n* @deprecated use {@link NotificationChannel#setSound(Uri, AudioAttributes)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "NotificationChannel#setSound(Uri, AudioAttributes)", "methodReturn": "Builder", "isValid": true, "cleanReplacement": "setSound(Uri, AudioAttributes)", "fullMethod": "Builder setSound(Uri)", "method": "setSound(Uri)"}, "getUidTcpRxSegments": {"methodClass": "android.net.TrafficStats", "methodName": "getUidTcpRxSegments", "replacementComments": "/**\n* @deprecated Starting in {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2},\n* transport layer statistics are no longer available, and will\n* always return {@link #UNSUPPORTED}.\n* @see #getUidRxPackets(int)\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getUidRxPackets(int)", "methodReturn": "long", "isValid": true, "cleanReplacement": "getUidRxPackets(int)", "fullMethod": "long getUidTcpRxSegments(int)", "method": "getUidTcpRxSegments(int)"}, "getItemSelectedListener": {"methodClass": "android.widget.AutoCompleteTextView", "methodName": "getItemSelectedListener", "replacementComments": "/**\n* <p>Returns the listener that is notified whenever the user selects an\n* item in the drop down list.</p>\n*\n* @return the item selected listener\n*\n* @deprecated Use {@link #getOnItemSelectedListener()} intead\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getOnItemSelectedListener()", "methodReturn": "OnItemSelectedListener", "isValid": true, "cleanReplacement": "getOnItemSelectedListener()", "fullMethod": "OnItemSelectedListener getItemSelectedListener()", "method": "getItemSelectedListener()"}, "startSync": {"methodClass": "android.content.ContentResolver", "methodName": "startSync", "replacementComments": "/**\n* Start an asynchronous sync operation. If you want to monitor the progress\n* of the sync you may register a SyncObserver. Only values of the following\n* types may be used in the extras bundle:\n* <ul>\n* <li>Integer</li>\n* <li>Long</li>\n* <li>Boolean</li>\n* <li>Float</li>\n* <li>Double</li>\n* <li>String</li>\n* <li>Account</li>\n* <li>null</li>\n* </ul>\n*\n* @param uri the uri of the provider to sync or null to sync all providers.\n* @param extras any extras to pass to the SyncAdapter.\n* @deprecated instead use\n* {@link #requestSync(android.accounts.Account, String, android.os.Bundle)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "requestSync(android.accounts.Account, String, android.os.Bundle)", "methodReturn": "void", "isValid": true, "cleanReplacement": "requestSync(android.accounts.Account, String, android.os.Bundle)", "fullMethod": "void startSync(Uri,Bundle)", "method": "startSync(Uri,Bundle)"}, "writePackedUInt32": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writePackedUInt32", "replacementComments": "/**\n* Write a list of packed proto \"uint32\" type field value.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writePackedUInt32(long,int[])", "method": "writePackedUInt32(long,int[])"}, "dragViewToY": {"methodClass": "android.test.TouchUtils", "methodName": "dragViewToY", "replacementComments": "/**\n* Simulate touching a view and dragging it to a specified location. Only moves vertically.\n*\n* @param test The test case that is being run\n* @param v The view that should be dragged\n* @param gravity Which part of the view to use for the initial down event. A combination of\n* (TOP, CENTER_VERTICAL, BOTTOM) and (LEFT, CENTER_HORIZONTAL, RIGHT)\n* @param toY Final location of the view after dragging\n*\n* @return distance in pixels covered by the drag\n*\n* @deprecated {@link android.test.ActivityInstrumentationTestCase} is deprecated in favor of\n* {@link android.test.ActivityInstrumentationTestCase2}, which provides more options for\n* configuring the Activity under test\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "android.test.ActivityInstrumentationTestCase2", "methodReturn": "int", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "int dragViewToY(ActivityInstrumentationTestCase,View,int,int)", "method": "dragViewToY(ActivityInstrumentationTestCase,View,int,int)"}, "dragViewToX": {"methodClass": "android.test.TouchUtils", "methodName": "dragViewToX", "replacementComments": "/**\n* Simulate touching a view and dragging it to a specified location. Only moves horizontally.\n*\n* @param test The test case that is being run\n* @param v The view that should be dragged\n* @param gravity Which part of the view to use for the initial down event. A combination of\n* (TOP, CENTER_VERTICAL, BOTTOM) and (LEFT, CENTER_HORIZONTAL, RIGHT)\n* @param toX Final location of the view after dragging\n*\n* @return distance in pixels covered by the drag\n*\n* @deprecated {@link android.test.ActivityInstrumentationTestCase} is deprecated in favor of\n* {@link android.test.ActivityInstrumentationTestCase2}, which provides more options for\n* configuring the Activity under test\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "android.test.ActivityInstrumentationTestCase2", "methodReturn": "int", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "int dragViewToX(ActivityInstrumentationTestCase,View,int,int)", "method": "dragViewToX(ActivityInstrumentationTestCase,View,int,int)"}, "getInfo": {"methodClass": "androidx.core.view.accessibility.AccessibilityNodeInfoCompat", "methodName": "getInfo", "replacementComments": "/**\n* @return The wrapped {@link android.view.accessibility.AccessibilityNodeInfo}.\n*\n* @deprecated Use {@link #unwrap()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "unwrap()", "methodReturn": "Object", "isValid": true, "cleanReplacement": "unwrap()", "fullMethod": "Object getInfo()", "method": "getInfo()"}, "encodePredefinedImProtocol": {"methodClass": "android.provider.Contacts.ContactMethods", "methodName": "encodePredefinedImProtocol", "replacementComments": "/**\n* @deprecated see {@link android.provider.ContactsContract}\n*/\n", "isClassDeprecated": true, "dirtyReplacement": "android.provider.ContactsContract", "methodReturn": "String", "isValid": true, "cleanReplacement": "android.provider.ContactsContract", "fullMethod": "String encodePredefinedImProtocol(int)", "method": "encodePredefinedImProtocol(int)"}, "removeGpsStatusListener": {"methodClass": "android.location.LocationManager", "methodName": "removeGpsStatusListener", "replacementComments": "/**\n* Removes a GPS status listener.\n*\n* @param listener GPS status listener object to remove\n* @deprecated use {@link #unregisterGnssStatusCallback(GnssStatus.Callback)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "unregisterGnssStatusCallback(GnssStatus.Callback)", "methodReturn": "void", "isValid": true, "cleanReplacement": "unregisterGnssStatusCallback(GnssStatus.Callback)", "fullMethod": "void removeGpsStatusListener(Listener)", "method": "removeGpsStatusListener(Listener)"}, "showDialog": {"methodClass": "android.app.Activity", "methodName": "showDialog", "replacementComments": "/**\n* Simple version of {@link #showDialog(int, Bundle)} that does not\n* take any arguments.  Simply calls {@link #showDialog(int, Bundle)}\n* with null arguments.\n*\n* @deprecated Use the new {@link DialogFragment} class with\n* {@link FragmentManager} instead; this is also\n* available on older platforms through the Android compatibility package.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "DialogFragment", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void showDialog(int)", "method": "showDialog(int)"}, "asRecord": {"methodClass": "androidx.core.view.accessibility.AccessibilityEventCompat", "methodName": "asRecord", "replacementComments": "/**\n* Creates an {@link AccessibilityRecordCompat} from an {@link AccessibilityEvent}\n* that can be used to manipulate the event properties defined in\n* {@link android.view.accessibility.AccessibilityRecord}.\n* <p>\n* <strong>Note:</strong> Do not call {@link AccessibilityRecordCompat#recycle()} on the\n* returned {@link AccessibilityRecordCompat}. Call {@link AccessibilityEvent#recycle()}\n* in case you want to recycle the event.\n* </p>\n*\n* @param event The from which to create a record.\n* @return An {@link AccessibilityRecordCompat}.\n*\n* @deprecated Use the {@link AccessibilityEvent} directly as {@link AccessibilityRecord}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityEvent", "methodReturn": "AccessibilityRecordCompat", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "AccessibilityRecordCompat asRecord(AccessibilityEvent)", "method": "asRecord(AccessibilityEvent)"}, "toByteArray": {"methodClass": "android.nfc.NdefRecord", "methodName": "toByteArray", "replacementComments": "/**\n* Return this NDEF Record as a byte array.<p>\n* This method is deprecated, use {@link NdefMessage#toByteArray}\n* instead. This is because the NDEF binary format is not defined for\n* a record outside of the context of a message: the MB and ME flags\n* cannot be set without knowing the location inside a message.<p>\n* This implementation will attempt to serialize a single record by\n* always setting the MB and ME flags (in other words, assume this\n* is a single-record NDEF Message).<p>\n*\n* @deprecated use {@link NdefMessage#toByteArray()} instead\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "NdefMessage#toByteArray()", "methodReturn": "byte[]", "isValid": true, "cleanReplacement": "NdefMessage#toByteArray()", "fullMethod": "byte[] toByteArray()", "method": "toByteArray()"}, "fillMarginLayoutParams": {"methodClass": "androidx.percentlayout.widget.PercentLayoutHelper.PercentLayoutInfo", "methodName": "fillMarginLayoutParams", "replacementComments": "/**\n* @deprecated Use\n* {@link #fillMarginLayoutParams(View, ViewGroup.MarginLayoutParams, int, int)}\n* for proper RTL support.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "fillMarginLayoutParams(View, ViewGroup.MarginLayoutParams, int, int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "fillMarginLayoutParams(View, ViewGroup.MarginLayoutParams, int, int)", "fullMethod": "void fillMarginLayoutParams(MarginLayoutParams,int,int)", "method": "fillMarginLayoutParams(MarginLayoutParams,int,int)"}, "getWfcMode": {"methodClass": "com.android.ims.ImsManager", "methodName": "getWfcMode", "replacementComments": "/**\n* Returns the user configuration of WFC preference setting\n*\n* @param roaming {@code false} for home network setting, {@code true} for roaming  setting\n*\n* @deprecated Doesn't support MSIM devices. Use {@link #getWfcMode(boolean)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getWfcMode(boolean)", "methodReturn": "int", "isValid": true, "cleanReplacement": "getWfcMode(boolean)", "fullMethod": "int getWfcMode(Context,boolean)", "method": "getWfcMode(Context,boolean)"}, "getPixelFormat": {"methodClass": "android.view.Display", "methodName": "getPixelFormat", "replacementComments": "/**\n* Gets the pixel format of the display.\n* @return One of the constants defined in {@link android.graphics.PixelFormat}.\n*\n* @deprecated This method is no longer supported.\n* The result is always {@link PixelFormat#RGBA_8888}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "PixelFormat#RGBA_8888", "methodReturn": "int", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "int getPixelFormat()", "method": "getPixelFormat()"}, "addEndItem": {"methodClass": "androidx.slice.builders.ListBuilder.RowBuilder", "methodName": "addEndItem", "replacementComments": "/**\n* Adds an icon to be displayed at the end of the row. A mixture of icons and actions\n* is not permitted. If an action has already been added this will throw\n* {@link IllegalArgumentException}.\n* <p>\n* Use this method to specify content that will appear in the template once it's been\n* loaded.\n* </p>\n* @param isLoading indicates whether the app is doing work to load the added content in the\n* background or not.\n*\n* @deprecated use ListBuilder{@link #addEndItem(Icon, int, boolean)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "addEndItem(Icon, int, boolean)", "methodReturn": "RowBuilder", "isValid": true, "cleanReplacement": "addEndItem(Icon, int, boolean)", "fullMethod": "RowBuilder addEndItem(IconCompat,boolean)", "method": "addEndItem(IconCompat,boolean)"}, "setMenuVisibility": {"methodClass": "androidx.legacy.app.FragmentCompat", "methodName": "setMenuVisibility", "replacementComments": "/**\n* Call {@link Fragment#setMenuVisibility(boolean) Fragment.setMenuVisibility(boolean)}\n* if running on an appropriate version of the platform.\n*\n* @deprecated Use {@link androidx.fragment.app.Fragment} instead of the framework\n* {@link Fragment}.\n*/\n", "isClassDeprecated": true, "dirtyReplacement": "androidx.fragment.app.Fragment", "methodReturn": "void", "isValid": true, "cleanReplacement": "androidx.fragment.app.Fragment", "fullMethod": "void setMenuVisibility(Fragment,boolean)", "method": "setMenuVisibility(Fragment,boolean)"}, "onMetadataChanged": {"methodClass": "android.hardware.radio.RadioTuner.Callback", "methodName": "onMetadataChanged", "replacementComments": "/**\n* Called when metadata is updated for the current program.\n*\n* @deprecated Use {@link #onProgramInfoChanged(RadioManager.ProgramInfo)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "onProgramInfoChanged(RadioManager.ProgramInfo)", "methodReturn": "void", "isValid": true, "cleanReplacement": "onProgramInfoChanged(RadioManager.ProgramInfo)", "fullMethod": "void onMetadataChanged(RadioMetadata)", "method": "onMetadataChanged(RadioMetadata)"}, "scrollToTop": {"methodClass": "android.test.TouchUtils", "methodName": "scrollToTop", "replacementComments": "/**\n* Scroll a ViewGroup to the top by repeatedly calling\n* {@link #dragQuarterScreenDown(InstrumentationTestCase, Activity)}\n*\n* @param test The test case that is being run\n* @param v The ViewGroup that should be dragged\n*\n* @deprecated {@link android.test.ActivityInstrumentationTestCase} is deprecated in favor of\n* {@link android.test.ActivityInstrumentationTestCase2}, which provides more options for\n* configuring the Activity under test\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "android.test.ActivityInstrumentationTestCase2", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void scrollToTop(ActivityInstrumentationTestCase,ViewGroup)", "method": "scrollToTop(ActivityInstrumentationTestCase,ViewGroup)"}, "saveState": {"methodClass": "androidx.legacy.app.FragmentStatePagerAdapter", "methodName": "saveState", "replacementComments": "/**\n* @deprecated Use {@link androidx.fragment.app.FragmentStatePagerAdapter} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "androidx.fragment.app.FragmentStatePagerAdapter", "methodReturn": "Parcelable", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "Parcelable saveState()", "method": "saveState()"}, "setSpeechRecognitionCallback": {"methodClass": "androidx.leanback.widget.SearchBar", "methodName": "setSpeechRecognitionCallback", "replacementComments": "/**\n* Sets the speech recognition callback.\n*\n* @deprecated Launching voice recognition activity is no longer supported. App should declare\n* android.permission.RECORD_AUDIO in AndroidManifest file. See details in\n* {@link androidx.leanback.app.SearchSupportFragment}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "androidx.leanback.app.SearchSupportFragment", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void setSpeechRecognitionCallback(SpeechRecognitionCallback)", "method": "setSpeechRecognitionCallback(SpeechRecognitionCallback)"}, "getAllNetworkInfo": {"methodClass": "android.net.ConnectivityManager", "methodName": "getAllNetworkInfo", "replacementComments": "/**\n* Returns connection status information about all network\n* types supported by the device.\n*\n* @return an array of {@link NetworkInfo} objects.  Check each\n* {@link NetworkInfo#getType} for which type each applies.\n*\n* @deprecated This method does not support multiple connected networks\n* of the same type. Use {@link #getAllNetworks} and\n* {@link #getNetworkInfo(android.net.Network)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getAllNetworks", "methodReturn": "NetworkInfo[]", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "NetworkInfo[] getAllNetworkInfo()", "method": "getAllNetworkInfo()"}, "setAllowOptimization": {"methodClass": "androidx.fragment.app.FragmentTransaction", "methodName": "setAllowOptimization", "replacementComments": "/**\n* @deprecated This has been renamed {@link #setReorderingAllowed(boolean)}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setReorderingAllowed(boolean)", "methodReturn": "FragmentTransaction", "isValid": true, "cleanReplacement": "setReorderingAllowed(boolean)", "fullMethod": "FragmentTransaction setAllowOptimization(boolean)", "method": "setAllowOptimization(boolean)"}, "getTouchSlop": {"methodClass": "android.view.ViewConfiguration", "methodName": "getTouchSlop", "replacementComments": "/**\n* @return Distance in dips a touch can wander before we think the user is scrolling\n*\n* @deprecated Use {@link #getScaledTouchSlop()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getScaledTouchSlop()", "methodReturn": "int", "isValid": true, "cleanReplacement": "getScaledTouchSlop()", "fullMethod": "int getTouchSlop()", "method": "getTouchSlop()"}, "setPreviewFrameRate": {"methodClass": "android.hardware.Camera.Parameters", "methodName": "setPreviewFrameRate", "replacementComments": "/**\n* Sets the rate at which preview frames are received. This is the\n* target frame rate. The actual frame rate depends on the driver.\n*\n* @param fps the frame rate (frames per second)\n* @deprecated replaced by {@link #setPreviewFpsRange(int,int)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setPreviewFpsRange(int,int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setPreviewFpsRange(int,int)", "fullMethod": "void setPreviewFrameRate(int)", "method": "setPreviewFrameRate(int)"}, "onDrawOver": {"methodClass": "androidx.recyclerview.widget.RecyclerView.ItemDecoration", "methodName": "onDrawOver", "replacementComments": "/**\n* @deprecated\n* Override {@link #onDrawOver(Canvas, RecyclerView, RecyclerView.State)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "onDrawOver(Canvas, RecyclerView, RecyclerView.State)", "methodReturn": "void", "isValid": true, "cleanReplacement": "onDrawOver(Canvas, RecyclerView, RecyclerView.State)", "fullMethod": "void onDrawOver(Canvas,RecyclerView)", "method": "onDrawOver(Canvas,RecyclerView)"}, "jumpToCurrentState": {"methodClass": "androidx.core.graphics.drawable.DrawableCompat", "methodName": "jumpToCurrentState", "replacementComments": "/**\n* Call {@link Drawable#jumpToCurrentState() Drawable.jumpToCurrentState()}.\n*\n* @param drawable The Drawable against which to invoke the method.\n*\n* @deprecated Use {@link Drawable#jumpToCurrentState()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "Drawable#jumpToCurrentState()", "methodReturn": "void", "isValid": true, "cleanReplacement": "jumpToCurrentState()", "fullMethod": "void jumpToCurrentState(Drawable)", "method": "jumpToCurrentState(Drawable)"}, "dragViewTo": {"methodClass": "android.test.TouchUtils", "methodName": "dragViewTo", "replacementComments": "/**\n* Simulate touching a view and dragging it to a specified location.\n*\n* @param test The test case that is being run\n* @param v The view that should be dragged\n* @param gravity Which part of the view to use for the initial down event. A combination of\n* (TOP, CENTER_VERTICAL, BOTTOM) and (LEFT, CENTER_HORIZONTAL, RIGHT)\n* @param toX Final location of the view after dragging\n* @param toY Final location of the view after dragging\n*\n* @return distance in pixels covered by the drag\n*\n* @deprecated {@link android.test.ActivityInstrumentationTestCase} is deprecated in favor of\n* {@link android.test.ActivityInstrumentationTestCase2}, which provides more options for\n* configuring the Activity under test\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "android.test.ActivityInstrumentationTestCase2", "methodReturn": "int", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "int dragViewTo(ActivityInstrumentationTestCase,View,int,int,int)", "method": "dragViewTo(ActivityInstrumentationTestCase,View,int,int,int)"}, "setWillNotCacheDrawing": {"methodClass": "android.view.View", "methodName": "setWillNotCacheDrawing", "replacementComments": "/**\n* When a View's drawing cache is enabled, drawing is redirected to an\n* offscreen bitmap. Some views, like an ImageView, must be able to\n* bypass this mechanism if they already draw a single bitmap, to avoid\n* unnecessary usage of the memory.\n*\n* @param willNotCacheDrawing true if this view does not cache its\n* drawing, false otherwise\n*\n* @deprecated The view drawing cache was largely made obsolete with the introduction of\n* hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache\n* layers are largely unnecessary and can easily result in a net loss in performance due to the\n* cost of creating and updating the layer. In the rare cases where caching layers are useful,\n* such as for alpha animations, {@link #setLayerType(int, Paint)} handles this with hardware\n* rendering. For software-rendered snapshots of a small part of the View hierarchy or\n* individual Views it is recommended to create a {@link Canvas} from either a {@link Bitmap} or\n* {@link android.graphics.Picture} and call {@link #draw(Canvas)} on the View. However these\n* software-rendered usages are discouraged and have compatibility issues with hardware-only\n* rendering features such as {@link android.graphics.Bitmap.Config#HARDWARE Config.HARDWARE}\n* bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback\n* reports or unit testing the {@link PixelCopy} API is recommended.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setLayerType(int, Paint)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setLayerType(int, Paint)", "fullMethod": "void setWillNotCacheDrawing(boolean)", "method": "setWillNotCacheDrawing(boolean)"}, "setCamera": {"methodClass": "android.media.MediaRecorder", "methodName": "setCamera", "replacementComments": "/**\n* Sets a {@link android.hardware.Camera} to use for recording.\n*\n* <p>Use this function to switch quickly between preview and capture mode without a teardown of\n* the camera object. {@link android.hardware.Camera#unlock()} should be called before\n* this. Must call before {@link #prepare}.</p>\n*\n* @param c the Camera to use for recording\n* @deprecated Use {@link #getSurface} and the {@link android.hardware.camera2} API instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getSurface", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void setCamera(Camera)", "method": "setCamera(Camera)"}, "setWfcMode": {"methodClass": "com.android.ims.ImsManager", "methodName": "setWfcMode", "replacementComments": "/**\n* Change persistent WFC preference setting.\n*\n* @deprecated Doesn't support MSIM devices. Use {@link #setWfcMode(int)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setWfcMode(int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setWfcMode(int)", "fullMethod": "void setWfcMode(Context,int)", "method": "setWfcMode(Context,int)"}, "setSetting": {"methodClass": "android.provider.Contacts.Settings", "methodName": "setSetting", "replacementComments": "/**\n* @deprecated see {@link android.provider.ContactsContract}\n*/\n", "isClassDeprecated": true, "dirtyReplacement": "android.provider.ContactsContract", "methodReturn": "void", "isValid": true, "cleanReplacement": "android.provider.ContactsContract", "fullMethod": "void setSetting(ContentResolver,String,String,String)", "method": "setSetting(ContentResolver,String,String,String)"}, "abortReliableWrite": {"methodClass": "android.bluetooth.BluetoothGatt", "methodName": "abortReliableWrite", "replacementComments": "/**\n* @deprecated Use {@link #abortReliableWrite()}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "abortReliableWrite()", "methodReturn": "void", "isValid": true, "cleanReplacement": "abortReliableWrite()", "fullMethod": "void abortReliableWrite(BluetoothDevice)", "method": "abortReliableWrite(BluetoothDevice)"}, "removeStickyBroadcastAsUser": {"methodClass": "android.content.Context", "methodName": "removeStickyBroadcastAsUser", "replacementComments": "/**\n* <p>Version of {@link #removeStickyBroadcast(Intent)} that allows you to specify the\n* user the broadcast will be sent to.  This is not available to applications\n* that are not pre-installed on the system image.\n*\n* <p>You must hold the {@link android.Manifest.permission#BROADCAST_STICKY}\n* permission in order to use this API.  If you do not hold that\n* permission, {@link SecurityException} will be thrown.\n*\n* @deprecated Sticky broadcasts should not be used.  They provide no security (anyone\n* can access them), no protection (anyone can modify them), and many other problems.\n* The recommended pattern is to use a non-sticky broadcast to report that <em>something</em>\n* has changed, with another mechanism for apps to retrieve the current value whenever\n* desired.\n*\n* @param intent The Intent that was previously broadcast.\n* @param user UserHandle to remove the sticky broadcast from.\n*\n* @see #sendStickyBroadcastAsUser\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "sendStickyBroadcastAsUser", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void removeStickyBroadcastAsUser(Intent,UserHandle)", "method": "removeStickyBroadcastAsUser(Intent,UserHandle)"}, "clearThreadStatsTag": {"methodClass": "androidx.core.net.TrafficStatsCompat", "methodName": "clearThreadStatsTag", "replacementComments": "/**\n* Clear active tag used when accounting {@link Socket} traffic originating\n* from the current thread.\n*\n* @deprecated Use {@link TrafficStats#clearThreadStatsTag()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "TrafficStats#clearThreadStatsTag()", "methodReturn": "void", "isValid": true, "cleanReplacement": "TrafficStats#clearThreadStatsTag()", "fullMethod": "void clearThreadStatsTag()", "method": "clearThreadStatsTag()"}, "writeBytes": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writeBytes", "replacementComments": "/**\n* Write a single proto \"bytes\" type field value.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writeBytes(long,byte[])", "method": "writeBytes(long,byte[])"}, "appendSelectionArgs": {"methodClass": "androidx.core.database.DatabaseUtilsCompat", "methodName": "appendSelectionArgs", "replacementComments": "/**\n* Appends one set of selection args to another. This is useful when adding a selection\n* argument to a user provided set.\n*\n* @deprecated Use\n* {@link android.database.DatabaseUtils#appendSelectionArgs(String[], String[])} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "android.database.DatabaseUtils#appendSelectionArgs(String[], String[])", "methodReturn": "String[]", "isValid": true, "cleanReplacement": "appendSelectionArgs(String[], String[])", "fullMethod": "String[] appendSelectionArgs(String[],String[])", "method": "appendSelectionArgs(String[],String[])"}, "instantiateItem": {"methodClass": "com.android.internal.widget.PagerAdapter", "methodName": "instantiateItem", "replacementComments": "/**\n* Create the page for the given position.  The adapter is responsible\n* for adding the view to the container given here, although it only\n* must ensure this is done by the time it returns from\n* {@link #finishUpdate(android.view.ViewGroup)}.\n*\n* @param container The containing View in which the page will be shown.\n* @param position The page position to be instantiated.\n* @return Returns an Object representing the new page.  This does not\n* need to be a View, but can be some other container of the page.\n*\n* @deprecated Use {@link #instantiateItem(android.view.ViewGroup, int)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "instantiateItem(android.view.ViewGroup, int)", "methodReturn": "Object", "isValid": true, "cleanReplacement": "instantiateItem(android.view.ViewGroup, int)", "fullMethod": "Object instantiateItem(View,int)", "method": "instantiateItem(View,int)"}, "getOemUnlockEnabled": {"methodClass": "android.service.persistentdata.PersistentDataBlockManager", "methodName": "getOemUnlockEnabled", "replacementComments": "/**\n* Returns whether or not \"OEM unlock\" is enabled or disabled on this device.\n*\n* @deprecated use {@link OemLockManager#isOemUnlockAllowedByUser()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "OemLockManager#isOemUnlockAllowedByUser()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "isOemUnlockAllowedByUser()", "fullMethod": "boolean getOemUnlockEnabled()", "method": "getOemUnlockEnabled()"}, "hasCarrierPrivilegeRules": {"methodClass": "com.android.internal.telephony.uicc.UiccCard", "methodName": "hasCarrierPrivilegeRules", "replacementComments": "/**\n* Returns true if there are some carrier privilege rules loaded and specified.\n* @deprecated Please use {@link UiccProfile#hasCarrierPrivilegeRules()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "UiccProfile#hasCarrierPrivilegeRules()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "UiccProfile#hasCarrierPrivilegeRules()", "fullMethod": "boolean hasCarrierPrivilegeRules()", "method": "hasCarrierPrivilegeRules()"}, "isWfcEnabledByPlatform": {"methodClass": "com.android.ims.ImsManager", "methodName": "isWfcEnabledByPlatform", "replacementComments": "/**\n* Returns a platform configuration for WFC which may override the user\n* setting. Note: WFC presumes that VoLTE is enabled (these are\n* configuration settings which must be done correctly).\n*\n* @deprecated Doesn't work for MSIM devices. Use {@link #isWfcEnabledByPlatform()}\n* instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "isWfcEnabledByPlatform()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "isWfcEnabledByPlatform()", "fullMethod": "boolean isWfcEnabledByPlatform(Context)", "method": "isWfcEnabledByPlatform(Context)"}, "setCurrentHour": {"methodClass": "android.widget.TimePicker", "methodName": "setCurrentHour", "replacementComments": "/**\n* Sets the currently selected hour using 24-hour time.\n*\n* @param currentHour the hour to set, in the range (0-23)\n* @deprecated Use {@link #setHour(int)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setHour(int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setHour(int)", "fullMethod": "void setCurrentHour(Integer)", "method": "setCurrentHour(Integer)"}, "setCurrentItemIndex": {"methodClass": "androidx.core.view.accessibility.AccessibilityRecordCompat", "methodName": "setCurrentItemIndex", "replacementComments": "/**\n* Sets the index of the source in the list of items that can be visited.\n*\n* @param currentItemIndex The current item index.\n*\n* @throws IllegalStateException If called from an AccessibilityService.\n*\n* @deprecated Use {@link AccessibilityRecord#setCurrentItemIndex(int)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityRecord#setCurrentItemIndex(int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "AccessibilityRecord#setCurrentItemIndex(int)", "fullMethod": "void setCurrentItemIndex(int)", "method": "setCurrentItemIndex(int)"}, "getMaximumFlingVelocity": {"methodClass": "android.view.ViewConfiguration", "methodName": "getMaximumFlingVelocity", "replacementComments": "/**\n* @return Maximum velocity to initiate a fling, as measured in dips per second.\n*\n* @deprecated Use {@link #getScaledMaximumFlingVelocity()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getScaledMaximumFlingVelocity()", "methodReturn": "int", "isValid": true, "cleanReplacement": "getScaledMaximumFlingVelocity()", "fullMethod": "int getMaximumFlingVelocity()", "method": "getMaximumFlingVelocity()"}, "cancelNotification": {"methodClass": "android.service.notification.NotificationListenerService", "methodName": "cancelNotification", "replacementComments": "/**\n* Inform the notification manager about dismissal of a single notification.\n* <p>\n* Use this if your listener has a user interface that allows the user to dismiss individual\n* notifications, similar to the behavior of Android's status bar and notification panel.\n* It should be called after the user dismisses a single notification using your UI;\n* upon being informed, the notification manager will actually remove the notification\n* and you will get an {@link #onNotificationRemoved(StatusBarNotification)} callback.\n* <p>\n* <b>Note:</b> If your listener allows the user to fire a notification's\n* {@link android.app.Notification#contentIntent} by tapping/clicking/etc., you should call\n* this method at that time <i>if</i> the Notification in question has the\n* {@link android.app.Notification#FLAG_AUTO_CANCEL} flag set.\n*\n* <p>The service should wait for the {@link #onListenerConnected()} event\n* before performing this operation.\n*\n* @param pkg Package of the notifying app.\n* @param tag Tag of the notification as specified by the notifying app in\n* {@link android.app.NotificationManager#notify(String, int, android.app.Notification)}.\n* @param id  ID of the notification as specified by the notifying app in\n* {@link android.app.NotificationManager#notify(String, int, android.app.Notification)}.\n* <p>\n* @deprecated Use {@link #cancelNotification(String key)}\n* instead. Beginning with {@link android.os.Build.VERSION_CODES#LOLLIPOP} this method will no longer\n* cancel the notification. It will continue to cancel the notification for applications\n* whose {@code targetSdkVersion} is earlier than {@link android.os.Build.VERSION_CODES#LOLLIPOP}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "cancelNotification(String key)", "methodReturn": "void", "isValid": true, "cleanReplacement": "cancelNotification(String key)", "fullMethod": "void cancelNotification(String,String,int)", "method": "cancelNotification(String,String,int)"}, "play": {"methodClass": "android.media.AsyncPlayer", "methodName": "play", "replacementComments": "/**\n* Start playing the sound.  It will actually start playing at some\n* point in the future.  There are no guarantees about latency here.\n* Calling this before another audio file is done playing will stop\n* that one and start the new one.\n*\n* @param context Your application's context.\n* @param uri The URI to play.  (see {@link MediaPlayer#setDataSource(Context, Uri)})\n* @param looping Whether the audio should loop forever.\n* (see {@link MediaPlayer#setLooping(boolean)})\n* @param stream the AudioStream to use.\n* (see {@link MediaPlayer#setAudioStreamType(int)})\n* @deprecated use {@link #play(Context, Uri, boolean, AudioAttributes)} instead\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "play(Context, Uri, boolean, AudioAttributes)", "methodReturn": "void", "isValid": true, "cleanReplacement": "play(Context, Uri, boolean, AudioAttributes)", "fullMethod": "void play(Context,Uri,boolean,int)", "method": "play(Context,Uri,boolean,int)"}, "getUnicodeStream": {"methodClass": "java.sql.ResultSet", "methodName": "getUnicodeStream", "replacementComments": "/**\n* Retrieves the value of the designated column in the current row\n* of this <code>ResultSet</code> object as a stream of two-byte\n* Unicode characters. The first byte is the high byte; the second\n* byte is the low byte.\n*\n* The value can then be read in chunks from the\n* stream. This method is particularly\n* suitable for retrieving large <code>LONGVARCHAR</code> values.\n* The JDBC technology-enabled driver will\n* do any necessary conversion from the database format into Unicode.\n*\n* <P><B>Note:</B> All the data in the returned stream must be\n* read prior to getting the value of any other column. The next\n* call to a getter method implicitly closes the stream.\n* Also, a stream may return <code>0</code> when the method\n* <code>InputStream.available</code> is called, whether there\n* is data available or not.\n*\n* @param columnLabel the label for the column specified with the SQL AS clause.  If the SQL AS clause was not specified, then the label is the name of the column\n* @return a Java input stream that delivers the database column value\n* as a stream of two-byte Unicode characters.\n* If the value is SQL <code>NULL</code>, the value returned\n* is <code>null</code>.\n* @exception SQLException if the columnLabel is not valid;\n* if a database access error occurs or this method is\n* called on a closed result set\n* @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n* this method\n* @deprecated use <code>getCharacterStream</code> instead\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "<code>getCharacterStream</code>", "methodReturn": "InputStream", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "InputStream getUnicodeStream(String)", "method": "getUnicodeStream(String)"}, "engineSetParameter": {"methodClass": "java.security.SignatureSpi", "methodName": "engineSetParameter", "replacementComments": "/**\n* Sets the specified algorithm parameter to the specified\n* value. This method supplies a general-purpose mechanism through\n* which it is possible to set the various parameters of this object.\n* A parameter may be any settable parameter for the algorithm, such as\n* a parameter size, or a source of random bits for signature generation\n* (if appropriate), or an indication of whether or not to perform\n* a specific but optional computation. A uniform algorithm-specific\n* naming scheme for each parameter is desirable but left unspecified\n* at this time.\n*\n* @param param the string identifier of the parameter.\n*\n* @param value the parameter value.\n*\n* @exception InvalidParameterException if {@code param} is an\n* invalid parameter for this signature algorithm engine,\n* the parameter is already set\n* and cannot be set again, a security exception occurs, and so on.\n*\n* @deprecated Replaced by {@link\n* #engineSetParameter(java.security.spec.AlgorithmParameterSpec)\n* engineSetParameter}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "engineSetParameter(java.security.spec.AlgorithmParameterSpec)  engineSetParameter", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void engineSetParameter(String,Object)", "method": "engineSetParameter(String,Object)"}, "writePackedSInt64": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writePackedSInt64", "replacementComments": "/**\n* Write a list of packed proto \"sint64\" type field value.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writePackedSInt64(long,long[])", "method": "writePackedSInt64(long,long[])"}, "sendStickyBroadcast": {"methodClass": "android.content.Context", "methodName": "sendStickyBroadcast", "replacementComments": "/**\n* <p>Perform a {@link #sendBroadcast(Intent)} that is \"sticky,\" meaning the\n* Intent you are sending stays around after the broadcast is complete,\n* so that others can quickly retrieve that data through the return\n* value of {@link #registerReceiver(BroadcastReceiver, IntentFilter)}.  In\n* all other ways, this behaves the same as\n* {@link #sendBroadcast(Intent)}.\n*\n* @deprecated Sticky broadcasts should not be used.  They provide no security (anyone\n* can access them), no protection (anyone can modify them), and many other problems.\n* The recommended pattern is to use a non-sticky broadcast to report that <em>something</em>\n* has changed, with another mechanism for apps to retrieve the current value whenever\n* desired.\n*\n* @param intent The Intent to broadcast; all receivers matching this\n* Intent will receive the broadcast, and the Intent will be held to\n* be re-broadcast to future receivers.\n*\n* @see #sendBroadcast(Intent)\n* @see #sendStickyOrderedBroadcast(Intent, BroadcastReceiver, Handler, int, String, Bundle)\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "sendBroadcast(Intent)", "methodReturn": "void", "isValid": true, "cleanReplacement": "sendBroadcast(Intent)", "fullMethod": "void sendStickyBroadcast(Intent)", "method": "sendStickyBroadcast(Intent)"}, "dragQuarterScreenUp": {"methodClass": "android.test.TouchUtils", "methodName": "dragQuarterScreenUp", "replacementComments": "/**\n* Simulate touching in the center of the screen and dragging one quarter of the way up\n* @param test The test case that is being run\n*\n* @deprecated {@link android.test.ActivityInstrumentationTestCase} is deprecated in favor of\n* {@link android.test.ActivityInstrumentationTestCase2}, which provides more options for\n* configuring the Activity under test\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "android.test.ActivityInstrumentationTestCase2", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void dragQuarterScreenUp(ActivityInstrumentationTestCase)", "method": "dragQuarterScreenUp(ActivityInstrumentationTestCase)"}, "onStart": {"methodClass": "android.app.Service", "methodName": "onStart", "replacementComments": "/**\n* @deprecated Implement {@link #onStartCommand(Intent, int, int)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "onStartCommand(Intent, int, int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "onStartCommand(Intent, int, int)", "fullMethod": "void onStart(Intent,int)", "method": "onStart(Intent,int)"}, "setUserRestriction": {"methodClass": "android.os.UserManager", "methodName": "setUserRestriction", "replacementComments": "/**\n* Sets the value of a specific restriction.\n* Requires the MANAGE_USERS permission.\n* @param key the key of the restriction\n* @param value the value for the restriction\n* @deprecated use {@link android.app.admin.DevicePolicyManager#addUserRestriction(\n* android.content.ComponentName, String)} or\n* {@link android.app.admin.DevicePolicyManager#clearUserRestriction(\n* android.content.ComponentName, String)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "android.app.admin.DevicePolicyManager#addUserRestriction(  android.content.ComponentName, String)", "methodReturn": "void", "isValid": true, "cleanReplacement": "addUserRestriction(  android.content.ComponentName, String)", "fullMethod": "void setUserRestriction(String,boolean)", "method": "setUserRestriction(String,boolean)"}, "getSliceActions": {"methodClass": "androidx.slice.SliceUtils", "methodName": "getSliceActions", "replacementComments": "/**\n* @return the group of actions associated with the provided slice, if they exist.\n*\n* @deprecated TO BE REMOVED; use {@link SliceMetadata#getSliceActions()}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "SliceMetadata#getSliceActions()", "methodReturn": "List<SliceItem>", "isValid": true, "cleanReplacement": "getSliceActions()", "fullMethod": "List<SliceItem> getSliceActions(Slice)", "method": "getSliceActions(Slice)"}, "isApplicationOnIcc": {"methodClass": "com.android.internal.telephony.uicc.UiccCard", "methodName": "isApplicationOnIcc", "replacementComments": "/**\n* @deprecated Please use {@link UiccProfile#isApplicationOnIcc(AppType)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "UiccProfile#isApplicationOnIcc(AppType)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "UiccProfile#isApplicationOnIcc(AppType)", "fullMethod": "boolean isApplicationOnIcc(AppType)", "method": "isApplicationOnIcc(AppType)"}, "grantTrust": {"methodClass": "android.service.trust.TrustAgentService", "methodName": "grantTrust", "replacementComments": "/**\n* Call to grant trust on the device.\n*\n* @param message describes why the device is trusted, e.g. \"Trusted by location\".\n* @param durationMs amount of time in milliseconds to keep the device in a trusted state.\n* Trust for this agent will automatically be revoked when the timeout expires unless\n* extended by a subsequent call to this function. The timeout is measured from the\n* invocation of this function as dictated by {@link SystemClock#elapsedRealtime())}.\n* For security reasons, the value should be no larger than necessary.\n* The value may be adjusted by the system as necessary to comply with a policy controlled\n* by the system or {@link DevicePolicyManager} restrictions. See {@link #onTrustTimeout()}\n* for determining when trust expires.\n* @param initiatedByUser this is a hint to the system that trust is being granted as the\n* direct result of user action - such as solving a security challenge. The hint is used\n* by the system to optimize the experience. Behavior may vary by device and release, so\n* one should only set this parameter if it meets the above criteria rather than relying on\n* the behavior of any particular device or release. Corresponds to\n* {@link #FLAG_GRANT_TRUST_INITIATED_BY_USER}.\n* @throws IllegalStateException if the agent is not currently managing trust.\n*\n* @deprecated use {@link #grantTrust(CharSequence, long, int)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "grantTrust(CharSequence, long, int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "grantTrust(CharSequence, long, int)", "fullMethod": "void grantTrust(CharSequence,long,boolean)", "method": "grantTrust(CharSequence,long,boolean)"}, "getProgramInformation": {"methodClass": "android.hardware.radio.RadioTuner", "methodName": "getProgramInformation", "replacementComments": "/**\n* Get current station information.\n* @param info a ProgramInfo array of lengh 1 where the information is returned.\n* @return\n* <ul>\n* <li>{@link RadioManager#STATUS_OK} in case of success, </li>\n* <li>{@link RadioManager#STATUS_ERROR} in case of unspecified error, </li>\n* <li>{@link RadioManager#STATUS_NO_INIT} if the native service cannot be reached, </li>\n* <li>{@link RadioManager#STATUS_BAD_VALUE} if parameters are invalid, </li>\n* <li>{@link RadioManager#STATUS_INVALID_OPERATION} if the call is out of sequence, </li>\n* <li>{@link RadioManager#STATUS_DEAD_OBJECT} if the binder transaction to the native\n* service fails, </li>\n* </ul>\n* @deprecated Use {@link onProgramInfoChanged} callback instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "onProgramInfoChanged", "methodReturn": "int", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "int getProgramInformation(ProgramInfo[])", "method": "getProgramInformation(ProgramInfo[])"}, "requestVisibleBehind": {"methodClass": "android.app.Activity", "methodName": "requestVisibleBehind", "replacementComments": "/**\n* Activities that want to remain visible behind a translucent activity above them must call\n* this method anytime between the start of {@link #onResume()} and the return from\n* {@link #onPause()}. If this call is successful then the activity will remain visible after\n* {@link #onPause()} is called, and is allowed to continue playing media in the background.\n*\n* <p>The actions of this call are reset each time that this activity is brought to the\n* front. That is, every time {@link #onResume()} is called the activity will be assumed\n* to not have requested visible behind. Therefore, if you want this activity to continue to\n* be visible in the background you must call this method again.\n*\n* <p>Only fullscreen opaque activities may make this call. I.e. this call is a nop\n* for dialog and translucent activities.\n*\n* <p>Under all circumstances, the activity must stop playing and release resources prior to or\n* within a call to {@link #onVisibleBehindCanceled()} or if this call returns false.\n*\n* <p>False will be returned any time this method is called between the return of onPause and\n* the next call to onResume.\n*\n* @deprecated This method's functionality is no longer supported as of\n* {@link android.os.Build.VERSION_CODES#O} and will be removed in a future release.\n*\n* @param visible true to notify the system that the activity wishes to be visible behind other\n* translucent activities, false to indicate otherwise. Resources must be\n* released when passing false to this method.\n*\n* @return the resulting visibiity state. If true the activity will remain visible beyond\n* {@link #onPause()} if the next activity is translucent or not fullscreen. If false\n* then the activity may not count on being visible behind other translucent activities,\n* and must stop any media playback and release resources.\n* Returning false may occur in lieu of a call to {@link #onVisibleBehindCanceled()} so\n* the return value must be checked.\n*\n* @see #onVisibleBehindCanceled()\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "onVisibleBehindCanceled()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "onVisibleBehindCanceled()", "fullMethod": "boolean requestVisibleBehind(boolean)", "method": "requestVisibleBehind(boolean)"}, "onAudioStateChanged": {"methodClass": "android.telecom.Phone.Listener", "methodName": "onAudioStateChanged", "replacementComments": "/**\n* Called when the audio state changes.\n*\n* @param phone The {@code Phone} calling this method.\n* @param audioState The new {@link AudioState}.\n*\n* @deprecated Use {@link #onCallAudioStateChanged(Phone, CallAudioState)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "onCallAudioStateChanged(Phone, CallAudioState)", "methodReturn": "void", "isValid": true, "cleanReplacement": "onCallAudioStateChanged(Phone, CallAudioState)", "fullMethod": "void onAudioStateChanged(Phone,AudioState)", "method": "onAudioStateChanged(Phone,AudioState)"}, "requestFitSystemWindows": {"methodClass": "android.view.View", "methodName": "requestFitSystemWindows", "replacementComments": "/**\n* Ask that a new dispatch of {@link #fitSystemWindows(Rect)} be performed.\n* @deprecated Use {@link #requestApplyInsets()} for newer platform versions.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "requestApplyInsets()", "methodReturn": "void", "isValid": true, "cleanReplacement": "requestApplyInsets()", "fullMethod": "void requestFitSystemWindows()", "method": "requestFitSystemWindows()"}, "setInputMethod": {"methodClass": "android.view.inputmethod.InputMethodManager", "methodName": "setInputMethod", "replacementComments": "/**\n* Force switch to a new input method component. This can only be called\n* from an application or a service which has a token of the currently active input method.\n* @param token Supplies the identifying token given to an input method\n* when it was started, which allows it to perform this operation on\n* itself.\n* @param id The unique identifier for the new input method to be switched to.\n* @deprecated Use {@link InputMethodService#switchInputMethod(String)}\n* instead. This method was intended for IME developers who should be accessing APIs through\n* the service. APIs in this class are intended for app developers interacting with the IME.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "InputMethodService#switchInputMethod(String)", "methodReturn": "void", "isValid": true, "cleanReplacement": "switchInputMethod(String)", "fullMethod": "void setInputMethod(IBinder,String)", "method": "setInputMethod(IBinder,String)"}, "getSensors": {"methodClass": "android.hardware.SensorManager", "methodName": "getSensors", "replacementComments": "/**\n* @return available sensors.\n* @deprecated This method is deprecated, use\n* {@link SensorManager#getSensorList(int)} instead\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "SensorManager#getSensorList(int)", "methodReturn": "int", "isValid": true, "cleanReplacement": "getSensorList(int)", "fullMethod": "int getSensors()", "method": "getSensors()"}, "getDefault": {"methodClass": "android.app.ActivityManagerNative", "methodName": "getDefault", "replacementComments": "/**\n* Retrieve the system's default/global activity manager.\n*\n* @deprecated use ActivityManager.getService instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "ActivityManager.getService", "methodReturn": "IActivityManager", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "IActivityManager getDefault()", "method": "getDefault()"}, "isBlocked": {"methodClass": "com.android.internal.telephony.BlockChecker", "methodName": "isBlocked", "replacementComments": "/**\n* Returns {@code true} if {@code phoneNumber} is blocked according to {@code extras}.\n* <p>\n* This method catches all underlying exceptions to ensure that this method never throws any\n* exception.\n* <p>\n* @deprecated use {@link #isBlocked(Context, String, Bundle)} instead.\n*\n* @param context the context of the caller.\n* @param phoneNumber the number to check.\n* @return {@code true} if the number is blocked. {@code false} otherwise.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "isBlocked(Context, String, Bundle)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "isBlocked(Context, String, Bundle)", "fullMethod": "boolean isBlocked(Context,String)", "method": "isBlocked(Context,String)"}, "setText": {"methodClass": "android.content.ClipboardManager", "methodName": "setText", "replacementComments": "/**\n* @deprecated Use {@link #setPrimaryClip(ClipData)} instead.  This\n* creates a ClippedItem holding the given text and sets it as the\n* primary clip.  It has no label or icon.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setPrimaryClip(ClipData)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setPrimaryClip(ClipData)", "fullMethod": "void setText(CharSequence)", "method": "setText(CharSequence)"}, "requestPermissions": {"methodClass": "androidx.legacy.app.FragmentCompat", "methodName": "requestPermissions", "replacementComments": "/**\n* Requests permissions to be granted to this application. These permissions\n* must be requested in your manifest, they should not be granted to your app,\n* and they should have protection level {@link android.content.pm.PermissionInfo\n* #PROTECTION_DANGEROUS dangerous}, regardless whether they are declared by\n* the platform or a third-party app.\n* <p>\n* Normal permissions {@link android.content.pm.PermissionInfo#PROTECTION_NORMAL}\n* are granted at install time if requested in the manifest. Signature permissions\n* {@link android.content.pm.PermissionInfo#PROTECTION_SIGNATURE} are granted at\n* install time if requested in the manifest and the signature of your app matches\n* the signature of the app declaring the permissions.\n* </p>\n* <p>\n* If your app does not have the requested permissions the user will be presented\n* with UI for accepting them. After the user has accepted or rejected the\n* requested permissions you will receive a callback reporting whether the\n* permissions were granted or not. Your fragment has to implement {@link\n* OnRequestPermissionsResultCallback}\n* and the results of permission requests will be delivered to its\n* {@link OnRequestPermissionsResultCallback#onRequestPermissionsResult(\n* int, String[], int[])}.\n* </p>\n* <p>\n* Note that requesting a permission does not guarantee it will be granted and\n* your app should be able to run without having this permission.\n* </p>\n* <p>\n* This method may start an activity allowing the user to choose which permissions\n* to grant and which to reject. Hence, you should be prepared that your activity\n* may be paused and resumed. Further, granting some permissions may require\n* a restart of you application. In such a case, the system will recreate the\n* activity stack before delivering the result to your onRequestPermissionsResult(\n* int, String[], int[]).\n* </p>\n* <p>\n* When checking whether you have a permission you should use {@link\n* androidx.core.content.ContextCompat#checkSelfPermission(\n* android.content.Context, String)}.\n* </p>\n*\n* @param fragment The target fragment.\n* @param permissions The requested permissions.\n* @param requestCode Application specific request code to match with a result\n* reported to {@link OnRequestPermissionsResultCallback#onRequestPermissionsResult(\n* int, String[], int[])}.\n*\n* @see androidx.core.content.ContextCompat#checkSelfPermission(\n* android.content.Context, String)\n* @see #shouldShowRequestPermissionRationale(android.app.Fragment, String)\n*\n* @deprecated Use {@link androidx.fragment.app.Fragment} instead of the framework\n* {@link Fragment}.\n*/\n", "isClassDeprecated": true, "dirtyReplacement": "androidx.fragment.app.Fragment", "methodReturn": "void", "isValid": true, "cleanReplacement": "androidx.fragment.app.Fragment", "fullMethod": "void requestPermissions(Fragment,String[],int)", "method": "requestPermissions(Fragment,String[],int)"}, "removeQueueItemAt": {"methodClass": "android.support.v4.media.session.MediaControllerCompat", "methodName": "removeQueueItemAt", "replacementComments": "/**\n* Removes an queue item at the specified position in the play queue\n* of this session. Not all sessions may support this. To know whether the session supports\n* this, get the session's flags with {@link #getFlags()} and check that the flag\n* {@link MediaSessionCompat#FLAG_HANDLES_QUEUE_COMMANDS} is set.\n*\n* @param index The index of the element to be removed.\n* @throws UnsupportedOperationException If this session doesn't support this.\n* @see #getFlags()\n* @see MediaSessionCompat#FLAG_HANDLES_QUEUE_COMMANDS\n* @deprecated Use {@link #removeQueueItem(MediaDescriptionCompat)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "removeQueueItem(MediaDescriptionCompat)", "methodReturn": "void", "isValid": true, "cleanReplacement": "removeQueueItem(MediaDescriptionCompat)", "fullMethod": "void removeQueueItemAt(int)", "method": "removeQueueItemAt(int)"}, "clipPath": {"methodClass": "android.graphics.Canvas", "methodName": "clipPath", "replacementComments": "/**\n* Modify the current clip with the specified path.\n*\n* @param path The path to operate on the current clip\n* @param op   How the clip is modified\n* @return     true if the resulting is non-empty\n*\n* @deprecated Region.Op values other than {@link Region.Op#INTERSECT} and\n* {@link Region.Op#DIFFERENCE} have the ability to expand the clip. The canvas clipping APIs\n* are intended to only expand the clip as a result of a restore operation. This enables a view\n* parent to clip a canvas to clearly define the maximal drawing area of its children. The\n* recommended alternative calls are {@link #clipPath(Path)} and\n* {@link #clipOutPath(Path)};\n*\n* As of API Level API level {@value Build.VERSION_CODES#P} only {@link Region.Op#INTERSECT} and\n* {@link Region.Op#DIFFERENCE} are valid Region.Op parameters.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "Region.Op#INTERSECT", "methodReturn": "boolean", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "boolean clipPath(Path,Op)", "method": "clipPath(Path,Op)"}, "getCurrentTimeLong": {"methodClass": "androidx.leanback.widget.PlaybackControlsRow", "methodName": "getCurrentTimeLong", "replacementComments": "/**\n* Returns the current time in milliseconds of long type for playback controls row.\n* @deprecated Use {@link #getCurrentPosition()}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getCurrentPosition()", "methodReturn": "long", "isValid": true, "cleanReplacement": "getCurrentPosition()", "fullMethod": "long getCurrentTimeLong()", "method": "getCurrentTimeLong()"}, "isSystemReady": {"methodClass": "android.app.ActivityManagerNative", "methodName": "isSystemReady", "replacementComments": "/**\n* Convenience for checking whether the system is ready.  For internal use only.\n*\n* @deprecated use ActivityManagerInternal.isSystemReady instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "ActivityManagerInternal.isSystemReady", "methodReturn": "boolean", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "boolean isSystemReady()", "method": "isSystemReady()"}, "setAddedCount": {"methodClass": "androidx.core.view.accessibility.AccessibilityRecordCompat", "methodName": "setAddedCount", "replacementComments": "/**\n* Sets the number of added characters.\n*\n* @param addedCount The number of added characters.\n*\n* @throws IllegalStateException If called from an AccessibilityService.\n*\n* @deprecated Use {@link AccessibilityRecord#setAddedCount(int)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityRecord#setAddedCount(int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "AccessibilityRecord#setAddedCount(int)", "fullMethod": "void setAddedCount(int)", "method": "setAddedCount(int)"}, "setWindowLayoutMode": {"methodClass": "android.widget.PopupWindow", "methodName": "setWindowLayoutMode", "replacementComments": "/**\n* <p>Change the width and height measure specs that are given to the\n* window manager by the popup.  By default these are 0, meaning that\n* the current width or height is requested as an explicit size from\n* the window manager.  You can supply\n* {@link ViewGroup.LayoutParams#WRAP_CONTENT} or\n* {@link ViewGroup.LayoutParams#MATCH_PARENT} to have that measure\n* spec supplied instead, replacing the absolute width and height that\n* has been set in the popup.</p>\n*\n* <p>If the popup is showing, calling this method will take effect only\n* the next time the popup is shown.</p>\n*\n* @param widthSpec an explicit width measure spec mode, either\n* {@link ViewGroup.LayoutParams#WRAP_CONTENT},\n* {@link ViewGroup.LayoutParams#MATCH_PARENT}, or 0 to use the absolute\n* width.\n* @param heightSpec an explicit height measure spec mode, either\n* {@link ViewGroup.LayoutParams#WRAP_CONTENT},\n* {@link ViewGroup.LayoutParams#MATCH_PARENT}, or 0 to use the absolute\n* height.\n*\n* @deprecated Use {@link #setWidth(int)} and {@link #setHeight(int)}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setWidth(int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setWidth(int)", "fullMethod": "void setWindowLayoutMode(int,int)", "method": "setWindowLayoutMode(int,int)"}, "getNeighboringCellInfo": {"methodClass": "android.telephony.TelephonyManager", "methodName": "getNeighboringCellInfo", "replacementComments": "/**\n* Returns the neighboring cell information of the device.\n*\n* @return List of NeighboringCellInfo or null if info unavailable.\n*\n* @deprecated Use {@link #getAllCellInfo} which returns a superset of the information\n* from NeighboringCellInfo.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getAllCellInfo", "methodReturn": "List<NeighboringCellInfo>", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "List<NeighboringCellInfo> getNeighboringCellInfo()", "method": "getNeighboringCellInfo()"}, "setLabel": {"methodClass": "android.view.textclassifier.TextClassification.Builder", "methodName": "setLabel", "replacementComments": "/**\n* Sets the label for the <i>primary</i> action that may be rendered on a widget used to\n* act on the classified text.\n*\n* <p><strong>NOTE: </strong>This field is not parcelled. If read from a parcel, the\n* returned label represents the label of the first {@link RemoteAction} (if one exists).\n*\n* @deprecated Use {@link #addAction(RemoteAction)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "addAction(RemoteAction)", "methodReturn": "Builder", "isValid": true, "cleanReplacement": "addAction(RemoteAction)", "fullMethod": "Builder setLabel(String)", "method": "setLabel(String)"}, "getSeconds": {"methodClass": "java.sql.Date", "methodName": "getSeconds", "replacementComments": "/**\n* @deprecated This method is deprecated and should not be used because SQL Date\n* values do not have a time component.\n*\n* @exception java.lang.IllegalArgumentException if this method is invoked\n* @see #setSeconds\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setSeconds", "methodReturn": "int", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "int getSeconds()", "method": "getSeconds()"}, "getCurrVelocity": {"methodClass": "androidx.core.widget.ScrollerCompat", "methodName": "getCurrVelocity", "replacementComments": "/**\n* Returns the current velocity on platform versions that support it.\n*\n* <p> This method should only be used as input for nonessential visual effects such as\n* {@link EdgeEffectCompat}.</p>\n*\n* @return The original velocity less the deceleration. Result may be\n* negative.\n*\n* @deprecated Use {@link OverScroller#getCurrVelocity()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "OverScroller#getCurrVelocity()", "methodReturn": "float", "isValid": true, "cleanReplacement": "OverScroller#getCurrVelocity()", "fullMethod": "float getCurrVelocity()", "method": "getCurrVelocity()"}, "getOrientation": {"methodClass": "android.view.Display", "methodName": "getOrientation", "replacementComments": "/**\n* @deprecated use {@link #getRotation}\n* @return orientation of this display.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getRotation", "methodReturn": "int", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "int getOrientation()", "method": "getOrientation()"}, "getProgramList": {"methodClass": "android.hardware.radio.RadioTuner", "methodName": "getProgramList", "replacementComments": "/**\n* Get the list of discovered radio stations.\n*\n* To get the full list, set filter to null or empty map.\n* Keys must be prefixed with unique vendor Java-style namespace,\n* eg. 'com.somecompany.parameter1'.\n*\n* @param vendorFilter vendor-specific selector for radio stations.\n* @return a list of radio stations.\n* @throws IllegalStateException if the scan is in progress or has not been started,\n* startBackgroundScan() call may fix it.\n* @throws IllegalArgumentException if the vendorFilter argument is not valid.\n* @deprecated Use {@link getDynamicProgramList} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getDynamicProgramList", "methodReturn": "ProgramInfo>", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "ProgramInfo> getProgramList(Map<String, String>)", "method": "getProgramList(Map<String,"}, "getWallpaper": {"methodClass": "android.content.Context", "methodName": "getWallpaper", "replacementComments": "/**\n* @deprecated Use {@link android.app.WallpaperManager#getDrawable\n* WallpaperManager.get()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "android.app.WallpaperManager#getDrawable  WallpaperManager.get()", "methodReturn": "Drawable", "isValid": true, "cleanReplacement": "getDrawable  WallpaperManager.get()", "fullMethod": "Drawable getWallpaper()", "method": "getWallpaper()"}, "getScaledPagingTouchSlop": {"methodClass": "androidx.core.view.ViewConfigurationCompat", "methodName": "getScaledPagingTouchSlop", "replacementComments": "/**\n* Call {@link ViewConfiguration#getScaledPagingTouchSlop()}.\n*\n* @deprecated Call {@link ViewConfiguration#getScaledPagingTouchSlop()} directly.\n* This method will be removed in a future release.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "ViewConfiguration#getScaledPagingTouchSlop()", "methodReturn": "int", "isValid": true, "cleanReplacement": "getScaledPagingTouchSlop()", "fullMethod": "int getScaledPagingTouchSlop(ViewConfiguration)", "method": "getScaledPagingTouchSlop(ViewConfiguration)"}, "springBack": {"methodClass": "androidx.core.widget.ScrollerCompat", "methodName": "springBack", "replacementComments": "/**\n* Call this when you want to 'spring back' into a valid coordinate range.\n*\n* @param startX Starting X coordinate\n* @param startY Starting Y coordinate\n* @param minX Minimum valid X value\n* @param maxX Maximum valid X value\n* @param minY Minimum valid Y value\n* @param maxY Maximum valid Y value\n* @return true if a springback was initiated, false if startX and startY were\n* already within the valid range.\n*\n* @deprecated Use {@link OverScroller#springBack(int, int, int, int, int, int)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "OverScroller#springBack(int, int, int, int, int, int)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "springBack(int, int, int, int, int, int)", "fullMethod": "boolean springBack(int,int,int,int,int,int)", "method": "springBack(int,int,int,int,int,int)"}, "getLabel": {"methodClass": "android.view.textclassifier.TextClassification", "methodName": "getLabel", "replacementComments": "/**\n* Returns a label that may be rendered on a widget used to act on the classified text.\n*\n* <p><strong>NOTE: </strong>This field is not parcelable and only represents the label of the\n* first {@link RemoteAction} (if one exists) when this object is read from a parcel.\n*\n* @deprecated Use {@link #getActions()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getActions()", "methodReturn": "CharSequence", "isValid": true, "cleanReplacement": "getActions()", "fullMethod": "CharSequence getLabel()", "method": "getLabel()"}, "getPresenceIconResourceId": {"methodClass": "android.provider.Contacts.Presence", "methodName": "getPresenceIconResourceId", "replacementComments": "/**\n* Gets the resource ID for the proper presence icon.\n*\n* @param status the status to get the icon for\n* @return the resource ID for the proper presence icon\n* @deprecated see {@link android.provider.ContactsContract}\n*/\n", "isClassDeprecated": true, "dirtyReplacement": "android.provider.ContactsContract", "methodReturn": "int", "isValid": true, "cleanReplacement": "android.provider.ContactsContract", "fullMethod": "int getPresenceIconResourceId(int)", "method": "getPresenceIconResourceId(int)"}, "getViewPosition": {"methodClass": "androidx.recyclerview.widget.RecyclerView.LayoutParams", "methodName": "getViewPosition", "replacementComments": "/**\n* @deprecated use {@link #getViewLayoutPosition()} or {@link #getViewAdapterPosition()}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getViewLayoutPosition()", "methodReturn": "int", "isValid": true, "cleanReplacement": "getViewLayoutPosition()", "fullMethod": "int getViewPosition()", "method": "getViewPosition()"}, "getNativeFrameCount": {"methodClass": "android.media.AudioTrack", "methodName": "getNativeFrameCount", "replacementComments": "/**\n* Returns the frame count of the native <code>AudioTrack</code> buffer.\n* @return current size in frames of the <code>AudioTrack</code> buffer.\n* @throws IllegalStateException\n* @deprecated Use the identical public method {@link #getBufferSizeInFrames()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getBufferSizeInFrames()", "methodReturn": "int", "isValid": true, "cleanReplacement": "getBufferSizeInFrames()", "fullMethod": "int getNativeFrameCount()", "method": "getNativeFrameCount()"}, "setVoicemailVibrationEnabled": {"methodClass": "android.telephony.TelephonyManager", "methodName": "setVoicemailVibrationEnabled", "replacementComments": "/**\n* Sets the per-account preference whether vibration is enabled for voicemail notifications.\n*\n* <p>Requires that the calling app is the default dialer, or has carrier privileges (see\n* {@link #hasCarrierPrivileges}, or has permission\n* {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE}.\n*\n* @param phoneAccountHandle The handle for the {@link PhoneAccount} for which to set the\n* voicemail vibration setting.\n* @param enabled Whether to enable or disable vibration for voicemail notifications from a\n* specific PhoneAccount.\n*\n* @deprecated Use {@link android.provider.Settings#ACTION_CHANNEL_NOTIFICATION_SETTINGS}\n* instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "android.provider.Settings#ACTION_CHANNEL_NOTIFICATION_SETTINGS", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void setVoicemailVibrationEnabled(PhoneAccountHandle,boolean)", "method": "setVoicemailVibrationEnabled(PhoneAccountHandle,boolean)"}, "formatIpAddress": {"methodClass": "android.text.format.Formatter", "methodName": "formatIpAddress", "replacementComments": "/**\n* Returns a string in the canonical IPv4 format ###.###.###.### from a packed integer\n* containing the IP address. The IPv4 address is expected to be in little-endian\n* format (LSB first). That is, 0x01020304 will return \"4.3.2.1\".\n*\n* @deprecated Use {@link java.net.InetAddress#getHostAddress()}, which supports both IPv4 and\n* IPv6 addresses. This method does not support IPv6 addresses.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "java.net.InetAddress#getHostAddress()", "methodReturn": "String", "isValid": true, "cleanReplacement": "getHostAddress()", "fullMethod": "String formatIpAddress(int)", "method": "formatIpAddress(int)"}, "isEnabled": {"methodClass": "androidx.core.view.accessibility.AccessibilityRecordCompat", "methodName": "isEnabled", "replacementComments": "/**\n* Gets if the source is enabled.\n*\n* @return True if the view is enabled, false otherwise.\n*\n* @deprecated Use {@link AccessibilityRecord#isEnabled()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityRecord#isEnabled()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "AccessibilityRecord#isEnabled()", "fullMethod": "boolean isEnabled()", "method": "isEnabled()"}, "getCarrierPrivilegeStatusForCurrentTransaction": {"methodClass": "com.android.internal.telephony.uicc.UiccCard", "methodName": "getCarrierPrivilegeStatusForCurrentTransaction", "replacementComments": "/**\n* Exposes {@link UiccCarrierPrivilegeRules#getCarrierPrivilegeStatusForCurrentTransaction}.\n* @deprecated Please use\n* {@link UiccProfile#getCarrierPrivilegeStatusForCurrentTransaction(PackageManager)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "UiccProfile#getCarrierPrivilegeStatusForCurrentTransaction(PackageManager)", "methodReturn": "int", "isValid": true, "cleanReplacement": "UiccProfile#getCarrierPrivilegeStatusForCurrentTransaction(PackageManager)", "fullMethod": "int getCarrierPrivilegeStatusForCurrentTransaction(PackageManager)", "method": "getCarrierPrivilegeStatusForCurrentTransaction(PackageManager)"}, "getDayOfWeekString": {"methodClass": "android.text.format.DateUtils", "methodName": "getDayOfWeekString", "replacementComments": "/**\n* Return a string for the day of the week.\n* @param dayOfWeek One of {@link Calendar#SUNDAY Calendar.SUNDAY},\n* {@link Calendar#MONDAY Calendar.MONDAY}, etc.\n* @param abbrev One of {@link #LENGTH_LONG}, {@link #LENGTH_SHORT},\n* {@link #LENGTH_MEDIUM}, or {@link #LENGTH_SHORTEST}.\n* Note that in most languages, {@link #LENGTH_SHORT}\n* will return the same as {@link #LENGTH_MEDIUM}.\n* Undefined lengths will return {@link #LENGTH_MEDIUM}\n* but may return something different in the future.\n* @throws IndexOutOfBoundsException if the dayOfWeek is out of bounds.\n* @deprecated Use {@link java.text.SimpleDateFormat} instead.\n*/\n", "isClassDeprecated": true, "dirtyReplacement": "java.text.SimpleDateFormat", "methodReturn": "String", "isValid": true, "cleanReplacement": "java.text.SimpleDateFormat", "fullMethod": "String getDayOfWeekString(int,int)", "method": "getDayOfWeekString(int,int)"}, "getSender": {"methodClass": "androidx.core.app.NotificationCompat.MessagingStyle.Message", "methodName": "getSender", "replacementComments": "/**\n* Get the text used to display the contact's name in the messaging experience\n*\n* @deprecated Use {@link #getPerson()}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getPerson()", "methodReturn": "CharSequence", "isValid": true, "cleanReplacement": "getPerson()", "fullMethod": "CharSequence getSender()", "method": "getSender()"}, "setBufferedProgress": {"methodClass": "androidx.leanback.widget.PlaybackControlsRow", "methodName": "setBufferedProgress", "replacementComments": "/**\n* Sets the buffered progress for the playback controls row.\n* If this row is bound to a view, the view will automatically\n* be updated to reflect the new value.\n* @deprecated Use {@link #setBufferedPosition(long)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setBufferedPosition(long)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setBufferedPosition(long)", "fullMethod": "void setBufferedProgress(int)", "method": "setBufferedProgress(int)"}, "collapseActionView": {"methodClass": "androidx.core.view.MenuItemCompat", "methodName": "collapseActionView", "replacementComments": "/**\n* Collapse the action view associated with this menu item. The menu item must have an action\n* view set, as well as the showAsAction flag {@link #SHOW_AS_ACTION_COLLAPSE_ACTION_VIEW}. If a\n* listener has been set using {@link #setOnActionExpandListener(MenuItem,\n* androidx.core.view.MenuItemCompat.OnActionExpandListener)}\n* it will have its {@link\n* androidx.core.view.MenuItemCompat.OnActionExpandListener#onMenuItemActionCollapse(MenuItem)}\n* method invoked. The listener may return false from this method to prevent collapsing\n* the action view.\n*\n* @return true if the action view was collapsed, false otherwise.\n*\n* @deprecated Use {@link MenuItem#collapseActionView()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "MenuItem#collapseActionView()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "collapseActionView()", "fullMethod": "boolean collapseActionView(MenuItem)", "method": "collapseActionView(MenuItem)"}, "setCurrentTimeLong": {"methodClass": "androidx.leanback.widget.PlaybackControlsRow", "methodName": "setCurrentTimeLong", "replacementComments": "/**\n* Sets the current time in milliseconds for playback controls row in long type.\n* @param ms Current time in milliseconds of long type.\n* @deprecated use {@link #setCurrentPosition(long)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setCurrentPosition(long)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setCurrentPosition(long)", "fullMethod": "void setCurrentTimeLong(long)", "method": "setCurrentTimeLong(long)"}, "setVoicemailRingtoneUri": {"methodClass": "android.telephony.TelephonyManager", "methodName": "setVoicemailRingtoneUri", "replacementComments": "/**\n* Sets the per-account voicemail ringtone.\n*\n* <p>Requires that the calling app is the default dialer, or has carrier privileges (see\n* {@link #hasCarrierPrivileges}, or has permission\n* {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE}.\n*\n* @param phoneAccountHandle The handle for the {@link PhoneAccount} for which to set the\n* voicemail ringtone.\n* @param uri The URI for the ringtone to play when receiving a voicemail from a specific\n* PhoneAccount.\n*\n* @deprecated Use {@link android.provider.Settings#ACTION_CHANNEL_NOTIFICATION_SETTINGS}\n* instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "android.provider.Settings#ACTION_CHANNEL_NOTIFICATION_SETTINGS", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void setVoicemailRingtoneUri(PhoneAccountHandle,Uri)", "method": "setVoicemailRingtoneUri(PhoneAccountHandle,Uri)"}, "setPassword": {"methodClass": "androidx.core.view.accessibility.AccessibilityRecordCompat", "methodName": "setPassword", "replacementComments": "/**\n* Sets if the source is a password field.\n*\n* @param isPassword True if the view is a password field, false otherwise.\n*\n* @throws IllegalStateException If called from an AccessibilityService.\n*\n* @deprecated Use {@link AccessibilityRecord#setPassword(boolean)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityRecord#setPassword(boolean)", "methodReturn": "void", "isValid": true, "cleanReplacement": "AccessibilityRecord#setPassword(boolean)", "fullMethod": "void setPassword(boolean)", "method": "setPassword(boolean)"}, "setCurrentMinute": {"methodClass": "android.widget.TimePicker", "methodName": "setCurrentMinute", "replacementComments": "/**\n* Sets the currently selected minute.\n*\n* @param currentMinute the minute to set, in the range (0-59)\n* @deprecated Use {@link #setMinute(int)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setMinute(int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setMinute(int)", "fullMethod": "void setCurrentMinute(Integer)", "method": "setCurrentMinute(Integer)"}, "getBufferedProgress": {"methodClass": "androidx.leanback.widget.PlaybackControlsRow", "methodName": "getBufferedProgress", "replacementComments": "/**\n* Returns the buffered progress for the playback controls row.\n* @throws ArithmeticException If buffered progress in milliseconds overflows int.\n* @deprecated Use {@link #getBufferedPosition()}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getBufferedPosition()", "methodReturn": "int", "isValid": true, "cleanReplacement": "getBufferedPosition()", "fullMethod": "int getBufferedProgress()", "method": "getBufferedProgress()"}, "updateImsServiceConfig": {"methodClass": "com.android.ims.ImsManager", "methodName": "updateImsServiceConfig", "replacementComments": "/**\n* Sync carrier config and user settings with ImsConfig.\n*\n* @param context for the manager object\n* @param phoneId phone id\n* @param force update\n*\n* @deprecated Doesn't support MSIM devices. Use {@link #updateImsServiceConfig(boolean)}\n* instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "updateImsServiceConfig(boolean)", "methodReturn": "void", "isValid": true, "cleanReplacement": "updateImsServiceConfig(boolean)", "fullMethod": "void updateImsServiceConfig(Context,int,boolean)", "method": "updateImsServiceConfig(Context,int,boolean)"}, "setScaleY": {"methodClass": "androidx.core.view.ViewCompat", "methodName": "setScaleY", "replacementComments": "/**\n* Sets the amount that the view is scaled in Y around the pivot point, as a proportion of\n* the view's unscaled width. A value of 1 means that no scaling is applied.\n*\n* @param value The scaling factor.\n*\n* @deprecated Use {@link View#setScaleY(float)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "View#setScaleY(float)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setScaleY(float)", "fullMethod": "void setScaleY(View,float)", "method": "setScaleY(View,float)"}, "setScaleX": {"methodClass": "androidx.core.view.ViewCompat", "methodName": "setScaleX", "replacementComments": "/**\n* Sets the amount that the view is scaled in x around the pivot point, as a proportion of\n* the view's unscaled width. A value of 1 means that no scaling is applied.\n*\n* @param value The scaling factor.\n*\n* @deprecated Use {@link View#setScaleX(float)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "View#setScaleX(float)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setScaleX(float)", "fullMethod": "void setScaleX(View,float)", "method": "setScaleX(View,float)"}, "getColor": {"methodClass": "android.content.res.Resources", "methodName": "getColor", "replacementComments": "/**\n* Returns a color integer associated with a particular resource ID. If the\n* resource holds a complex {@link ColorStateList}, then the default color\n* from the set is returned.\n*\n* @param id The desired resource identifier, as generated by the aapt\n* tool. This integer encodes the package, type, and resource\n* entry. The value 0 is an invalid identifier.\n*\n* @throws NotFoundException Throws NotFoundException if the given ID does\n* not exist.\n*\n* @return A single color value in the form 0xAARRGGBB.\n* @deprecated Use {@link #getColor(int, Theme)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getColor(int, Theme)", "methodReturn": "int", "isValid": true, "cleanReplacement": "getColor(int, Theme)", "fullMethod": "int getColor(int)", "method": "getColor(int)"}, "resolveSizeAndState": {"methodClass": "androidx.core.view.ViewCompat", "methodName": "resolveSizeAndState", "replacementComments": "/**\n* Utility to reconcile a desired size and state, with constraints imposed\n* by a MeasureSpec.  Will take the desired size, unless a different size\n* is imposed by the constraints.  The returned value is a compound integer,\n* with the resolved size in the {@link #MEASURED_SIZE_MASK} bits and\n* optionally the bit {@link #MEASURED_STATE_TOO_SMALL} set if the resulting\n* size is smaller than the size the view wants to be.\n*\n* @param size How big the view wants to be\n* @param measureSpec Constraints imposed by the parent\n* @return Size information bit mask as defined by\n* {@link #MEASURED_SIZE_MASK} and {@link #MEASURED_STATE_TOO_SMALL}.\n*\n* @deprecated Use {@link View#resolveSizeAndState(int, int, int)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "View#resolveSizeAndState(int, int, int)", "methodReturn": "int", "isValid": true, "cleanReplacement": "resolveSizeAndState(int, int, int)", "fullMethod": "int resolveSizeAndState(int,int,int)", "method": "resolveSizeAndState(int,int,int)"}, "stop": {"methodClass": "java.lang.ThreadGroup", "methodName": "stop", "replacementComments": "/**\n* Stops all threads in this thread group.\n* <p>\n* First, the <code>checkAccess</code> method of this thread group is\n* called with no arguments; this may result in a security exception.\n* <p>\n* This method then calls the <code>stop</code> method on all the\n* threads in this thread group and in all of its subgroups.\n*\n* @exception  SecurityException  if the current thread is not allowed\n* to access this thread group or any of the threads in\n* the thread group.\n* @see        java.lang.SecurityException\n* @see        java.lang.Thread#stop()\n* @see        java.lang.ThreadGroup#checkAccess()\n* @since      JDK1.0\n* @deprecated    This method is inherently unsafe.  See\n* {@link Thread#stop} for details.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "Thread#stop", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void stop()", "method": "stop()"}, "isEnhanced4gLteModeSettingEnabledByUser": {"methodClass": "com.android.ims.ImsManager", "methodName": "isEnhanced4gLteModeSettingEnabledByUser", "replacementComments": "/**\n* Returns the user configuration of Enhanced 4G LTE Mode setting.\n*\n* @deprecated Doesn't support MSIM devices. Use\n* {@link #isEnhanced4gLteModeSettingEnabledByUser()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "isEnhanced4gLteModeSettingEnabledByUser()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "isEnhanced4gLteModeSettingEnabledByUser()", "fullMethod": "boolean isEnhanced4gLteModeSettingEnabledByUser(Context)", "method": "isEnhanced4gLteModeSettingEnabledByUser(Context)"}, "newCreator": {"methodClass": "androidx.core.os.ParcelableCompat", "methodName": "newCreator", "replacementComments": "/**\n* Factory method for {@link Parcelable.Creator}.\n*\n* @param callbacks Creator callbacks implementation.\n* @return New creator.\n*\n* @deprecated Use {@link android.os.Parcelable.ClassLoaderCreator} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "android.os.Parcelable.ClassLoaderCreator", "methodReturn": "Creator<T>", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "Creator<T> newCreator(ParcelableCompatCreatorCallbacks<T>)", "method": "newCreator(ParcelableCompatCreatorCallbacks<T>)"}, "setStreamMute": {"methodClass": "android.media.AudioManager", "methodName": "setStreamMute", "replacementComments": "/**\n* Mute or unmute an audio stream.\n* <p>\n* This method should only be used by applications that replace the\n* platform-wide management of audio settings or the main telephony\n* application.\n* <p>\n* This method has no effect if the device implements a fixed volume policy\n* as indicated by {@link #isVolumeFixed()}.\n* <p>\n* This method was deprecated in API level 22. Prior to API level 22 this\n* method had significantly different behavior and should be used carefully.\n* The following applies only to pre-22 platforms:\n* <ul>\n* <li>The mute command is protected against client process death: if a\n* process with an active mute request on a stream dies, this stream will be\n* unmuted automatically.</li>\n* <li>The mute requests for a given stream are cumulative: the AudioManager\n* can receive several mute requests from one or more clients and the stream\n* will be unmuted only when the same number of unmute requests are\n* received.</li>\n* <li>For a better user experience, applications MUST unmute a muted stream\n* in onPause() and mute is again in onResume() if appropriate.</li>\n* </ul>\n*\n* @param streamType The stream to be muted/unmuted.\n* @param state The required mute state: true for mute ON, false for mute\n* OFF\n* @see #isVolumeFixed()\n* @deprecated Use {@link #adjustStreamVolume(int, int, int)} with\n* {@link #ADJUST_MUTE} or {@link #ADJUST_UNMUTE} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "adjustStreamVolume(int, int, int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "adjustStreamVolume(int, int, int)", "fullMethod": "void setStreamMute(int,boolean)", "method": "setStreamMute(int,boolean)"}, "onRemoveQueueItemAt": {"methodClass": "android.support.v4.media.session.MediaSessionCompat.Callback", "methodName": "onRemoveQueueItemAt", "replacementComments": "/**\n* Called when a {@link MediaControllerCompat} wants to remove a {@link QueueItem} at the\n* specified position in the play queue.\n*\n* @param index The index of the element to be removed.\n* @deprecated {@link #onRemoveQueueItem} will be called instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "led", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void onRemoveQueueItemAt(int)", "method": "onRemoveQueueItemAt(int)"}, "unregisterRemoteControlClient": {"methodClass": "android.media.AudioManager", "methodName": "unregisterRemoteControlClient", "replacementComments": "/**\n* Unregisters the remote control client that was providing information to display on the\n* remote controls.\n* @param rcClient The remote control client to unregister.\n* @see #registerRemoteControlClient(RemoteControlClient)\n* @deprecated Use {@link MediaSession} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "MediaSession", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void unregisterRemoteControlClient(RemoteControlClient)", "method": "unregisterRemoteControlClient(RemoteControlClient)"}, "unloadNanoApp": {"methodClass": "android.hardware.location.ContextHubManager", "methodName": "unloadNanoApp", "replacementComments": "/**\n* Unload a specified nanoApp\n*\n* Note that unloading is asynchronous.  When we return from this method,\n* the nano app (probably) hasn't unloaded yet.  Assuming a return of 0\n* from this method, then the final success/failure for the unload is\n* delivered in a byte string via a call to Callback.onMessageReceipt.\n*\n* TODO(b/30784270): Provide a better success/failure delivery.\n*\n* @param nanoAppHandle handle of the nanoApp to unload\n*\n* @return 0 if the command for unloading was sent to the context hub;\n* -1 otherwise\n*\n* @deprecated Use {@link #unloadNanoApp(ContextHubInfo, long)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "unloadNanoApp(ContextHubInfo, long)", "methodReturn": "int", "isValid": true, "cleanReplacement": "unloadNanoApp(ContextHubInfo, long)", "fullMethod": "int unloadNanoApp(int)", "method": "unloadNanoApp(int)"}, "switchToNextInputMethod": {"methodClass": "android.view.inputmethod.InputMethodManager", "methodName": "switchToNextInputMethod", "replacementComments": "/**\n* Force switch to the next input method and subtype. If there is no IME enabled except\n* current IME and subtype, do nothing.\n* @param imeToken Supplies the identifying token given to an input method when it was started,\n* which allows it to perform this operation on itself.\n* @param onlyCurrentIme if true, the framework will find the next subtype which\n* belongs to the current IME\n* @return true if the current input method and subtype was successfully switched to the next\n* input method and subtype.\n* @deprecated Use {@link InputMethodService#switchToNextInputMethod(boolean)} instead. This\n* method was intended for IME developers who should be accessing APIs through the service.\n* APIs in this class are intended for app developers interacting with the IME.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "InputMethodService#switchToNextInputMethod(boolean)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "switchToNextInputMethod(boolean)", "fullMethod": "boolean switchToNextInputMethod(IBinder,boolean)", "method": "switchToNextInputMethod(IBinder,boolean)"}, "getCurrentItemIndex": {"methodClass": "androidx.core.view.accessibility.AccessibilityRecordCompat", "methodName": "getCurrentItemIndex", "replacementComments": "/**\n* Gets the index of the source in the list of items the can be visited.\n*\n* @return The current item index.\n*\n* @deprecated Use {@link AccessibilityRecord#getCurrentItemIndex()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityRecord#getCurrentItemIndex()", "methodReturn": "int", "isValid": true, "cleanReplacement": "AccessibilityRecord#getCurrentItemIndex()", "fullMethod": "int getCurrentItemIndex()", "method": "getCurrentItemIndex()"}, "onPictureInPictureModeChanged": {"methodClass": "android.app.Fragment", "methodName": "onPictureInPictureModeChanged", "replacementComments": "/**\n* Called by the system when the activity changes to and from picture-in-picture mode. This is\n* generally tied to {@link Activity#onPictureInPictureModeChanged} of the containing Activity.\n*\n* @param isInPictureInPictureMode True if the activity is in picture-in-picture mode.\n*\n* @deprecated Use {@link #onPictureInPictureModeChanged(boolean, Configuration)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "onPictureInPictureModeChanged(boolean, Configuration)", "methodReturn": "void", "isValid": true, "cleanReplacement": "onPictureInPictureModeChanged(boolean, Configuration)", "fullMethod": "void onPictureInPictureModeChanged(boolean)", "method": "onPictureInPictureModeChanged(boolean)"}, "setColor": {"methodClass": "androidx.slice.builders.ListBuilder", "methodName": "setColor", "replacementComments": "/**\n* @deprecated TO BE REMOVED; use {@link #setAccentColor(int)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setAccentColor(int)", "methodReturn": "ListBuilder", "isValid": true, "cleanReplacement": "setAccentColor(int)", "fullMethod": "ListBuilder setColor(int)", "method": "setColor(int)"}, "getYVelocity": {"methodClass": "androidx.core.view.VelocityTrackerCompat", "methodName": "getYVelocity", "replacementComments": "/**\n* Call {@link VelocityTracker#getYVelocity(int)}.\n* If running on a pre-{@link android.os.Build.VERSION_CODES#HONEYCOMB} device,\n* returns {@link VelocityTracker#getYVelocity()}.\n*\n* @deprecated Use {@link VelocityTracker#getYVelocity(int)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "VelocityTracker#getYVelocity(int)", "methodReturn": "float", "isValid": true, "cleanReplacement": "getYVelocity(int)", "fullMethod": "float getYVelocity(VelocityTracker,int)", "method": "getYVelocity(VelocityTracker,int)"}, "getIcon": {"methodClass": "android.view.textclassifier.TextClassification", "methodName": "getIcon", "replacementComments": "/**\n* Returns an icon that may be rendered on a widget used to act on the classified text.\n*\n* <p><strong>NOTE: </strong>This field is not parcelable and only represents the icon of the\n* first {@link RemoteAction} (if one exists) when this object is read from a parcel.\n*\n* @deprecated Use {@link #getActions()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getActions()", "methodReturn": "Drawable", "isValid": true, "cleanReplacement": "getActions()", "fullMethod": "Drawable getIcon()", "method": "getIcon()"}, "onScreenTurnedOn": {"methodClass": "com.android.keyguard.KeyguardUpdateMonitorCallback", "methodName": "onScreenTurnedOn", "replacementComments": "/**\n* Called when the screen has been turned on.\n*\n* @deprecated use {@link com.android.systemui.keyguard.ScreenLifecycle}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "com.android.systemui.keyguard.ScreenLifecycle", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void onScreenTurnedOn()", "method": "onScreenTurnedOn()"}, "setChildrenDrawingCacheEnabled": {"methodClass": "android.view.ViewGroup", "methodName": "setChildrenDrawingCacheEnabled", "replacementComments": "/**\n* Enables or disables the drawing cache for each child of this view group.\n*\n* @param enabled true to enable the cache, false to dispose of it\n*\n* @deprecated The view drawing cache was largely made obsolete with the introduction of\n* hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache\n* layers are largely unnecessary and can easily result in a net loss in performance due to the\n* cost of creating and updating the layer. In the rare cases where caching layers are useful,\n* such as for alpha animations, {@link #setLayerType(int, Paint)} handles this with hardware\n* rendering. For software-rendered snapshots of a small part of the View hierarchy or\n* individual Views it is recommended to create a {@link Canvas} from either a {@link Bitmap} or\n* {@link android.graphics.Picture} and call {@link #draw(Canvas)} on the View. However these\n* software-rendered usages are discouraged and have compatibility issues with hardware-only\n* rendering features such as {@link android.graphics.Bitmap.Config#HARDWARE Config.HARDWARE}\n* bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback\n* reports or unit testing the {@link PixelCopy} API is recommended.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setLayerType(int, Paint)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setLayerType(int, Paint)", "fullMethod": "void setChildrenDrawingCacheEnabled(boolean)", "method": "setChildrenDrawingCacheEnabled(boolean)"}, "getActions": {"methodClass": "android.view.accessibility.AccessibilityNodeInfo", "methodName": "getActions", "replacementComments": "/**\n* Gets the actions that can be performed on the node.\n*\n* @return The bit mask of with actions.\n*\n* @see AccessibilityNodeInfo#ACTION_FOCUS\n* @see AccessibilityNodeInfo#ACTION_CLEAR_FOCUS\n* @see AccessibilityNodeInfo#ACTION_SELECT\n* @see AccessibilityNodeInfo#ACTION_CLEAR_SELECTION\n* @see AccessibilityNodeInfo#ACTION_ACCESSIBILITY_FOCUS\n* @see AccessibilityNodeInfo#ACTION_CLEAR_ACCESSIBILITY_FOCUS\n* @see AccessibilityNodeInfo#ACTION_CLICK\n* @see AccessibilityNodeInfo#ACTION_LONG_CLICK\n* @see AccessibilityNodeInfo#ACTION_NEXT_AT_MOVEMENT_GRANULARITY\n* @see AccessibilityNodeInfo#ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY\n* @see AccessibilityNodeInfo#ACTION_NEXT_HTML_ELEMENT\n* @see AccessibilityNodeInfo#ACTION_PREVIOUS_HTML_ELEMENT\n* @see AccessibilityNodeInfo#ACTION_SCROLL_FORWARD\n* @see AccessibilityNodeInfo#ACTION_SCROLL_BACKWARD\n*\n* @deprecated Use {@link #getActionList()}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getActionList()", "methodReturn": "int", "isValid": true, "cleanReplacement": "getActionList()", "fullMethod": "int getActions()", "method": "getActions()"}, "getStorageState": {"methodClass": "android.os.Environment", "methodName": "getStorageState", "replacementComments": "/**\n* @deprecated use {@link #getExternalStorageState(File)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getExternalStorageState(File)", "methodReturn": "String", "isValid": true, "cleanReplacement": "getExternalStorageState(File)", "fullMethod": "String getStorageState(File)", "method": "getStorageState(File)"}, "decodeImProtocol": {"methodClass": "android.provider.Contacts.ContactMethods", "methodName": "decodeImProtocol", "replacementComments": "/**\n* @deprecated see {@link android.provider.ContactsContract}\n*/\n", "isClassDeprecated": true, "dirtyReplacement": "android.provider.ContactsContract", "methodReturn": "Object", "isValid": true, "cleanReplacement": "android.provider.ContactsContract", "fullMethod": "Object decodeImProtocol(String)", "method": "decodeImProtocol(String)"}, "isDigital": {"methodClass": "android.hardware.radio.RadioManager.ProgramInfo", "methodName": "isDigital", "replacementComments": "/**\n* {@code true} if the received program is digital (e.g HD radio)\n* @return {@code true} if digital, {@code false} otherwise.\n* @deprecated Use {@link getLogicallyTunedTo()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getLogicallyTunedTo()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "getLogicallyTunedTo()", "fullMethod": "boolean isDigital()", "method": "isDigital()"}, "release": {"methodClass": "android.drm.DrmManagerClient", "methodName": "release", "replacementComments": "/**\n* @deprecated replaced by {@link #close()}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "close()", "methodReturn": "void", "isValid": true, "cleanReplacement": "close()", "fullMethod": "void release()", "method": "release()"}, "startExpandedTransition": {"methodClass": "androidx.leanback.widget.GuidedActionsStylist", "methodName": "startExpandedTransition", "replacementComments": "/**\n* Start transition to expand or collapse GuidedActionStylist.\n* @param avh When not null, the GuidedActionStylist expands the sub actions of avh.  When null\n* the GuidedActionStylist will collapse sub actions.\n* @deprecated use {@link #expandAction(GuidedAction, boolean)} and\n* {@link #collapseAction(boolean)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "expandAction(GuidedAction, boolean)", "methodReturn": "void", "isValid": true, "cleanReplacement": "expandAction(GuidedAction, boolean)", "fullMethod": "void startExpandedTransition(ViewHolder)", "method": "startExpandedTransition(ViewHolder)"}, "addOption": {"methodClass": "android.service.autofill.ImageTransformation.Builder", "methodName": "addOption", "replacementComments": "/**\n* Adds an option to replace the child view with a different image when the regex matches.\n*\n* @param regex regular expression defining what should be matched to use this image.\n* @param resId resource id of the image (in the autofill service's package). The\n* {@link RemoteViews presentation} must contain a {@link ImageView} child with that id.\n*\n* @return this build\n*\n* @deprecated use {@link #addOption(Pattern, int, CharSequence)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "addOption(Pattern, int, CharSequence)", "methodReturn": "Builder", "isValid": true, "cleanReplacement": "addOption(Pattern, int, CharSequence)", "fullMethod": "Builder addOption(Pattern,int)", "method": "addOption(Pattern,int)"}, "stopLeScan": {"methodClass": "android.bluetooth.BluetoothAdapter", "methodName": "stopLeScan", "replacementComments": "/**\n* Stops an ongoing Bluetooth LE device scan.\n*\n* @param callback used to identify which scan to stop must be the same handle used to start the\n* scan\n* @deprecated Use {@link BluetoothLeScanner#stopScan(ScanCallback)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "BluetoothLeScanner#stopScan(ScanCallback)", "methodReturn": "void", "isValid": true, "cleanReplacement": "stopScan(ScanCallback)", "fullMethod": "void stopLeScan(LeScanCallback)", "method": "stopLeScan(LeScanCallback)"}, "dump": {"methodClass": "androidx.loader.content.Loader", "methodName": "dump", "replacementComments": "/**\n* Print the Loader's state into the given stream.\n*\n* @param prefix Text to print at the front of each line.\n* @param fd The raw file descriptor that the dump is being sent to.\n* @param writer A PrintWriter to which the dump is to be set.\n* @param args Additional arguments to the dump request.\n* @deprecated Consider using {@link LoaderManager#enableDebugLogging(boolean)} to understand\n* the series of operations performed by LoaderManager.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "LoaderManager#enableDebugLogging(boolean)", "methodReturn": "void", "isValid": true, "cleanReplacement": "enableDebugLogging(boolean)", "fullMethod": "void dump(String,FileDescriptor,PrintWriter,String[])", "method": "dump(String,FileDescriptor,PrintWriter,String[])"}, "isBluetoothA2dpOn": {"methodClass": "android.media.AudioManager", "methodName": "isBluetoothA2dpOn", "replacementComments": "/**\n* Checks whether a Bluetooth A2DP audio peripheral is connected or not.\n*\n* @return true if a Bluetooth A2DP peripheral is connected\n* false if otherwise\n* @deprecated Use {@link AudioManager#getDevices(int)} instead to list available audio devices.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AudioManager#getDevices(int)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "getDevices(int)", "fullMethod": "boolean isBluetoothA2dpOn()", "method": "isBluetoothA2dpOn()"}, "getNetworkType": {"methodClass": "android.app.job.JobInfo", "methodName": "getNetworkType", "replacementComments": "/**\n* Return the basic description of the kind of network this job requires.\n*\n* @deprecated This method attempts to map {@link #getRequiredNetwork()}\n* into the set of simple constants, which results in a loss of\n* fidelity. Callers should move to using\n* {@link #getRequiredNetwork()} directly.\n* @see Builder#setRequiredNetworkType(int)\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "Builder#setRequiredNetworkType(int)", "methodReturn": "int", "isValid": true, "cleanReplacement": "setRequiredNetworkType(int)", "fullMethod": "int getNetworkType()", "method": "getNetworkType()"}, "setContentInfo": {"methodClass": "android.app.Notification.Builder", "methodName": "setContentInfo", "replacementComments": "/**\n* A small piece of additional information pertaining to this notification.\n*\n* The platform template will draw this on the last line of the notification, at the far\n* right (to the right of a smallIcon if it has been placed there).\n*\n* @deprecated use {@link #setSubText(CharSequence)} instead to set a text in the header.\n* For legacy apps targeting a version below {@link android.os.Build.VERSION_CODES#N} this\n* field will still show up, but the subtext will take precedence.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setSubText(CharSequence)", "methodReturn": "Builder", "isValid": true, "cleanReplacement": "setSubText(CharSequence)", "fullMethod": "Builder setContentInfo(CharSequence)", "method": "setContentInfo(CharSequence)"}, "yieldIfContended": {"methodClass": "android.database.sqlite.SQLiteDatabase", "methodName": "yieldIfContended", "replacementComments": "/**\n* Temporarily end the transaction to let other threads run. The transaction is assumed to be\n* successful so far. Do not call setTransactionSuccessful before calling this. When this\n* returns a new transaction will have been created but not marked as successful.\n* @return true if the transaction was yielded\n* @deprecated if the db is locked more than once (becuase of nested transactions) then the lock\n* will not be yielded. Use yieldIfContendedSafely instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "yieldIfContendedSafely", "methodReturn": "boolean", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "boolean yieldIfContended()", "method": "yieldIfContended()"}, "isOpaque": {"methodClass": "androidx.core.view.ViewCompat", "methodName": "isOpaque", "replacementComments": "/**\n* Indicates whether this View is opaque. An opaque View guarantees that it will\n* draw all the pixels overlapping its bounds using a fully opaque color.\n*\n* @return True if this View is guaranteed to be fully opaque, false otherwise.\n* @deprecated Use {@link View#isOpaque()} directly. This method will be\n* removed in a future release.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "View#isOpaque()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "isOpaque()", "fullMethod": "boolean isOpaque(View)", "method": "isOpaque(View)"}, "saveLayer": {"methodClass": "android.graphics.Canvas", "methodName": "saveLayer", "replacementComments": "/**\n* Helper version of saveLayer() that takes 4 values rather than a RectF.\n*\n* As of API Level API level {@value Build.VERSION_CODES#P} the only valid\n* {@code saveFlags} is {@link #ALL_SAVE_FLAG}.  All other flags are ignored.\n*\n* @deprecated Use {@link #saveLayer(float, float, float, float, Paint)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "saveLayer(float, float, float, float, Paint)", "methodReturn": "int", "isValid": true, "cleanReplacement": "saveLayer(float, float, float, float, Paint)", "fullMethod": "int saveLayer(float,float,float,float,Paint,int)", "method": "saveLayer(float,float,float,float,Paint,int)"}, "isQuickScaleEnabled": {"methodClass": "androidx.core.view.ScaleGestureDetectorCompat", "methodName": "isQuickScaleEnabled", "replacementComments": "/**\n* Returns whether the quick scale gesture, in which the user performs a double tap followed by\n* a swipe, should perform scaling. See\n* {@link #setQuickScaleEnabled(ScaleGestureDetector, boolean)}.\n*\n* @deprecated Use {@link #isQuickScaleEnabled(ScaleGestureDetector)} that takes\n* {@link ScaleGestureDetector} instead of {@link Object}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "isQuickScaleEnabled(ScaleGestureDetector)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "isQuickScaleEnabled(ScaleGestureDetector)", "fullMethod": "boolean isQuickScaleEnabled(Object)", "method": "isQuickScaleEnabled(Object)"}, "getWallpaperDesiredMinimumWidth": {"methodClass": "android.content.Context", "methodName": "getWallpaperDesiredMinimumWidth", "replacementComments": "/**\n* @deprecated Use {@link android.app.WallpaperManager#getDesiredMinimumWidth()\n* WallpaperManager.getDesiredMinimumWidth()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "android.app.WallpaperManager#getDesiredMinimumWidth()  WallpaperManager.getDesiredMinimumWidth()", "methodReturn": "int", "isValid": true, "cleanReplacement": "getDesiredMinimumWidth()  WallpaperManager.getDesiredMinimumWidth()", "fullMethod": "int getWallpaperDesiredMinimumWidth()", "method": "getWallpaperDesiredMinimumWidth()"}, "setTextSize": {"methodClass": "android.webkit.WebSettings", "methodName": "setTextSize", "replacementComments": "/**\n* Sets the text size of the page. The default is {@link TextSize#NORMAL}.\n*\n* @param t the text size as a {@link TextSize} value\n* @deprecated Use {@link #setTextZoom} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setTextZoom", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void setTextSize(TextSize)", "method": "setTextSize(TextSize)"}, "writeSInt32": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writeSInt32", "replacementComments": "/**\n* Write a single proto \"sint32\" type field value.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writeSInt32(long,int)", "method": "writeSInt32(long,int)"}, "setVibrateSetting": {"methodClass": "android.media.AudioManager", "methodName": "setVibrateSetting", "replacementComments": "/**\n* Sets the setting for when the vibrate type should vibrate.\n* <p>\n* This method should only be used by applications that replace the platform-wide\n* management of audio settings or the main telephony application.\n*\n* @param vibrateType The type of vibrate. One of\n* {@link #VIBRATE_TYPE_NOTIFICATION} or\n* {@link #VIBRATE_TYPE_RINGER}.\n* @param vibrateSetting The vibrate setting, one of\n* {@link #VIBRATE_SETTING_ON},\n* {@link #VIBRATE_SETTING_OFF}, or\n* {@link #VIBRATE_SETTING_ONLY_SILENT}.\n* @see #getVibrateSetting(int)\n* @see #shouldVibrate(int)\n* @deprecated Applications should maintain their own vibrate policy based on\n* current ringer mode that can be queried via {@link #getRingerMode()}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getRingerMode()", "methodReturn": "void", "isValid": true, "cleanReplacement": "getRingerMode()", "fullMethod": "void setVibrateSetting(int,int)", "method": "setVibrateSetting(int,int)"}, "isHeading": {"methodClass": "androidx.core.view.accessibility.AccessibilityNodeInfoCompat.CollectionItemInfoCompat", "methodName": "isHeading", "replacementComments": "/**\n* Gets if the collection item is a heading. For example, section\n* heading, table header, etc.\n*\n* @return If the item is a heading.\n* @deprecated Use {@link AccessibilityNodeInfoCompat#isHeading()}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityNodeInfoCompat#isHeading()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "AccessibilityNodeInfoCompat#isHeading()", "fullMethod": "boolean isHeading()", "method": "isHeading()"}, "onError": {"methodClass": "android.hardware.radio.RadioTuner.Callback", "methodName": "onError", "replacementComments": "/**\n* onError() is called when an error occured while performing an asynchronous\n* operation of when the hardware or system service experiences a problem.\n* status is one of {@link #ERROR_HARDWARE_FAILURE}, {@link #ERROR_SERVER_DIED},\n* {@link #ERROR_CANCELLED}, {@link #ERROR_SCAN_TIMEOUT},\n* {@link #ERROR_CONFIG}\n*\n* @deprecated Use {@link onTuneFailed} for tune, scan and step;\n* other use cases (configuration, background scan) are already deprecated.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "onTuneFailed", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void onError(int)", "method": "onError(int)"}, "writeRepeatedString": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writeRepeatedString", "replacementComments": "/**\n* Write a single repeated proto \"string\" type field value.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writeRepeatedString(long,String)", "method": "writeRepeatedString(long,String)"}, "shouldVibrate": {"methodClass": "android.media.AudioManager", "methodName": "shouldVibrate", "replacementComments": "/**\n* Returns whether a particular type should vibrate according to user\n* settings and the current ringer mode.\n* <p>\n* This shouldn't be needed by most clients that use notifications to\n* vibrate. The notification manager will not vibrate if the policy doesn't\n* allow it, so the client should always set a vibrate pattern and let the\n* notification manager control whether or not to actually vibrate.\n*\n* @param vibrateType The type of vibrate. One of\n* {@link #VIBRATE_TYPE_NOTIFICATION} or\n* {@link #VIBRATE_TYPE_RINGER}.\n* @return Whether the type should vibrate at the instant this method is\n* called.\n* @see #setVibrateSetting(int, int)\n* @see #getVibrateSetting(int)\n* @deprecated Applications should maintain their own vibrate policy based on\n* current ringer mode that can be queried via {@link #getRingerMode()}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getRingerMode()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "getRingerMode()", "fullMethod": "boolean shouldVibrate(int)", "method": "shouldVibrate(int)"}, "toString": {"methodClass": "java.io.ByteArrayOutputStream", "methodName": "toString", "replacementComments": "/**\n* Creates a newly allocated string. Its size is the current size of\n* the output stream and the valid contents of the buffer have been\n* copied into it. Each character <i>c</i> in the resulting string is\n* constructed from the corresponding element <i>b</i> in the byte\n* array such that:\n* <blockquote><pre>\n* c == (char)(((hibyte &amp; 0xff) &lt;&lt; 8) | (b &amp; 0xff))\n* </pre></blockquote>\n*\n* @deprecated This method does not properly convert bytes into characters.\n* As of JDK&nbsp;1.1, the preferred way to do this is via the\n* <code>toString(String enc)</code> method, which takes an encoding-name\n* argument, or the <code>toString()</code> method, which uses the\n* platform's default character encoding.\n*\n* @param      hibyte    the high byte of each resulting Unicode character.\n* @return     the current contents of the output stream, as a string.\n* @see        java.io.ByteArrayOutputStream#size()\n* @see        java.io.ByteArrayOutputStream#toString(String)\n* @see        java.io.ByteArrayOutputStream#toString()\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "java.io.ByteArrayOutputStream#size()", "methodReturn": "String", "isValid": true, "cleanReplacement": "size()", "fullMethod": "String toString(int)", "method": "toString(int)"}, "removeSessionCookie": {"methodClass": "android.webkit.CookieManager", "methodName": "removeSessionCookie", "replacementComments": "/**\n* Removes all session cookies, which are cookies without an expiration\n* date.\n* @deprecated use {@link #removeSessionCookies(ValueCallback)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "removeSessionCookies(ValueCallback)", "methodReturn": "void", "isValid": true, "cleanReplacement": "removeSessionCookies(ValueCallback)", "fullMethod": "void removeSessionCookie()", "method": "removeSessionCookie()"}, "addNmeaListener": {"methodClass": "android.location.LocationManager", "methodName": "addNmeaListener", "replacementComments": "/**\n* Adds an NMEA listener.\n*\n* @param listener a {@link GpsStatus.NmeaListener} object to register\n*\n* @return true if the listener was successfully added\n*\n* @throws SecurityException if the ACCESS_FINE_LOCATION permission is not present\n* @deprecated use {@link #addNmeaListener(OnNmeaMessageListener)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "addNmeaListener(OnNmeaMessageListener)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "addNmeaListener(OnNmeaMessageListener)", "fullMethod": "boolean addNmeaListener(NmeaListener)", "method": "addNmeaListener(NmeaListener)"}, "unregisterForCarrierPrivilegeRulesLoaded": {"methodClass": "com.android.internal.telephony.uicc.UiccCard", "methodName": "unregisterForCarrierPrivilegeRulesLoaded", "replacementComments": "/**\n* @deprecated Please use\n* {@link UiccProfile#unregisterForCarrierPrivilegeRulesLoaded(Handler)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "UiccProfile#unregisterForCarrierPrivilegeRulesLoaded(Handler)", "methodReturn": "void", "isValid": true, "cleanReplacement": "UiccProfile#unregisterForCarrierPrivilegeRulesLoaded(Handler)", "fullMethod": "void unregisterForCarrierPrivilegeRulesLoaded(Handler)", "method": "unregisterForCarrierPrivilegeRulesLoaded(Handler)"}, "areCarrierPriviligeRulesLoaded": {"methodClass": "com.android.internal.telephony.uicc.UiccCard", "methodName": "areCarrierPriviligeRulesLoaded", "replacementComments": "/**\n* Returns true iff carrier privileges rules are null (dont need to be loaded) or loaded.\n* @deprecated Please use {@link UiccProfile#areCarrierPriviligeRulesLoaded()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "UiccProfile#areCarrierPriviligeRulesLoaded()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "UiccProfile#areCarrierPriviligeRulesLoaded()", "fullMethod": "boolean areCarrierPriviligeRulesLoaded()", "method": "areCarrierPriviligeRulesLoaded()"}, "destroyItem": {"methodClass": "com.android.internal.widget.PagerAdapter", "methodName": "destroyItem", "replacementComments": "/**\n* Remove a page for the given position.  The adapter is responsible\n* for removing the view from its container, although it only must ensure\n* this is done by the time it returns from {@link #finishUpdate(android.view.View)}.\n*\n* @param container The containing View from which the page will be removed.\n* @param position The page position to be removed.\n* @param object The same object that was returned by\n* {@link #instantiateItem(android.view.View, int)}.\n*\n* @deprecated Use {@link #destroyItem(android.view.ViewGroup, int, Object)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "destroyItem(android.view.ViewGroup, int, Object)", "methodReturn": "void", "isValid": true, "cleanReplacement": "destroyItem(android.view.ViewGroup, int, Object)", "fullMethod": "void destroyItem(View,int,Object)", "method": "destroyItem(View,int,Object)"}, "onTabChanged": {"methodClass": "androidx.legacy.app.FragmentTabHost", "methodName": "onTabChanged", "replacementComments": "/**\n* @deprecated Use {@link androidx.fragment.app.FragmentTabHost} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "androidx.fragment.app.FragmentTabHost", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void onTabChanged(String)", "method": "onTabChanged(String)"}, "setMotionEventSplittingEnabled": {"methodClass": "androidx.core.view.ViewGroupCompat", "methodName": "setMotionEventSplittingEnabled", "replacementComments": "/**\n* Enable or disable the splitting of MotionEvents to multiple children during touch event\n* dispatch. This behavior is enabled by default for applications that target an\n* SDK version of 11 (Honeycomb) or newer. On earlier platform versions this feature\n* was not supported and this method is a no-op.\n*\n* <p>When this option is enabled MotionEvents may be split and dispatched to different child\n* views depending on where each pointer initially went down. This allows for user interactions\n* such as scrolling two panes of content independently, chording of buttons, and performing\n* independent gestures on different pieces of content.\n*\n* @param group ViewGroup to modify\n* @param split <code>true</code> to allow MotionEvents to be split and dispatched to multiple\n* child views. <code>false</code> to only allow one child view to be the target of\n* any MotionEvent received by this ViewGroup.\n*\n* @deprecated Use {@link ViewGroup#setMotionEventSplittingEnabled(boolean)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "ViewGroup#setMotionEventSplittingEnabled(boolean)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setMotionEventSplittingEnabled(boolean)", "fullMethod": "void setMotionEventSplittingEnabled(ViewGroup,boolean)", "method": "setMotionEventSplittingEnabled(ViewGroup,boolean)"}, "setDrawingCacheQuality": {"methodClass": "android.view.View", "methodName": "setDrawingCacheQuality", "replacementComments": "/**\n* Set the drawing cache quality of this view. This value is used only when the\n* drawing cache is enabled\n*\n* @param quality One of {@link #DRAWING_CACHE_QUALITY_AUTO},\n* {@link #DRAWING_CACHE_QUALITY_LOW}, or {@link #DRAWING_CACHE_QUALITY_HIGH}\n*\n* @see #getDrawingCacheQuality()\n* @see #setDrawingCacheEnabled(boolean)\n* @see #isDrawingCacheEnabled()\n*\n* @attr ref android.R.styleable#View_drawingCacheQuality\n*\n* @deprecated The view drawing cache was largely made obsolete with the introduction of\n* hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache\n* layers are largely unnecessary and can easily result in a net loss in performance due to the\n* cost of creating and updating the layer. In the rare cases where caching layers are useful,\n* such as for alpha animations, {@link #setLayerType(int, Paint)} handles this with hardware\n* rendering. For software-rendered snapshots of a small part of the View hierarchy or\n* individual Views it is recommended to create a {@link Canvas} from either a {@link Bitmap} or\n* {@link android.graphics.Picture} and call {@link #draw(Canvas)} on the View. However these\n* software-rendered usages are discouraged and have compatibility issues with hardware-only\n* rendering features such as {@link android.graphics.Bitmap.Config#HARDWARE Config.HARDWARE}\n* bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback\n* reports or unit testing the {@link PixelCopy} API is recommended.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setLayerType(int, Paint)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setLayerType(int, Paint)", "fullMethod": "void setDrawingCacheQuality(int)", "method": "setDrawingCacheQuality(int)"}, "getAddedCount": {"methodClass": "androidx.core.view.accessibility.AccessibilityRecordCompat", "methodName": "getAddedCount", "replacementComments": "/**\n* Gets the number of added characters.\n*\n* @return The number of added characters.\n*\n* @deprecated Use {@link AccessibilityRecord#getAddedCount()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityRecord#getAddedCount()", "methodReturn": "int", "isValid": true, "cleanReplacement": "AccessibilityRecord#getAddedCount()", "fullMethod": "int getAddedCount()", "method": "getAddedCount()"}, "getSubjectMatch": {"methodClass": "android.net.wifi.WifiEnterpriseConfig", "methodName": "getSubjectMatch", "replacementComments": "/**\n* Get subject match (deprecated)\n* @return the subject match string\n* @deprecated in favor of altSubjectMatch\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "altSubjectMatch", "methodReturn": "String", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "String getSubjectMatch()", "method": "getSubjectMatch()"}, "getBufferedProgressLong": {"methodClass": "androidx.leanback.widget.PlaybackControlsRow", "methodName": "getBufferedProgressLong", "replacementComments": "/**\n* Returns the buffered progress of long type for the playback controls row.\n* @deprecated Use {@link #getBufferedPosition()}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getBufferedPosition()", "methodReturn": "long", "isValid": true, "cleanReplacement": "getBufferedPosition()", "fullMethod": "long getBufferedProgressLong()", "method": "getBufferedProgressLong()"}, "setOutput": {"methodClass": "android.renderscript.ScriptGroup", "methodName": "setOutput", "replacementComments": "/**\n* Sets an output of the ScriptGroup. This specifies an\n* Allocation to be used for the kernels that require an output\n* Allocation visible after the ScriptGroup is executed.\n*\n* @deprecated Use return value of {@link #execute(Object...)} instead.\n*\n* @param s The ID of the kernel where the allocation should be\n* connected.\n* @param a The allocation to connect.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "execute(Object...)", "methodReturn": "void", "isValid": true, "cleanReplacement": "execute(Object...)", "fullMethod": "void setOutput(KernelID,Allocation)", "method": "setOutput(KernelID,Allocation)"}, "isAnalogForced": {"methodClass": "android.hardware.radio.RadioTuner", "methodName": "isAnalogForced", "replacementComments": "/**\n* Checks, if the analog playback is forced, see setAnalogForced.\n*\n* @throws IllegalStateException if the switch is not supported at current\n* configuration.\n* @return {@code true} if analog is forced, {@code false} otherwise.\n* @deprecated Use {@link isConfigFlagSet(int)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "isConfigFlagSet(int)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "isConfigFlagSet(int)", "fullMethod": "boolean isAnalogForced()", "method": "isAnalogForced()"}, "retainNonConfig": {"methodClass": "android.app.FragmentController", "methodName": "retainNonConfig", "replacementComments": "/**\n* Returns a list of Fragments that have opted to retain their instance across\n* configuration changes.\n*\n* @deprecated use {@link #retainNestedNonConfig()} to also track retained\n* nested child fragments\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "retainNestedNonConfig()", "methodReturn": "List<Fragment>", "isValid": true, "cleanReplacement": "retainNestedNonConfig()", "fullMethod": "List<Fragment> retainNonConfig()", "method": "retainNonConfig()"}, "sendEnvelopeWithStatus": {"methodClass": "com.android.internal.telephony.uicc.UiccCard", "methodName": "sendEnvelopeWithStatus", "replacementComments": "/**\n* Exposes {@link CommandsInterface#sendEnvelopeWithStatus}\n* @deprecated Please use {@link UiccProfile#sendEnvelopeWithStatus(String, Message)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "UiccProfile#sendEnvelopeWithStatus(String, Message)", "methodReturn": "void", "isValid": true, "cleanReplacement": "sendEnvelopeWithStatus(String, Message)", "fullMethod": "void sendEnvelopeWithStatus(String,Message)", "method": "sendEnvelopeWithStatus(String,Message)"}, "setButton2": {"methodClass": "android.app.AlertDialog", "methodName": "setButton2", "replacementComments": "/**\n* Set a listener to be invoked when button 2 of the dialog is pressed.\n* @param text The text to display in button 2.\n* @param listener The {@link DialogInterface.OnClickListener} to use.\n* @deprecated Use\n* {@link #setButton(int, CharSequence, android.content.DialogInterface.OnClickListener)}\n* with {@link DialogInterface#BUTTON_NEGATIVE}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setButton(int, CharSequence, android.content.DialogInterface.OnClickListener)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setButton(int, CharSequence, android.content.DialogInterface.OnClickListener)", "fullMethod": "void setButton2(CharSequence,OnClickListener)", "method": "setButton2(CharSequence,OnClickListener)"}, "setButton3": {"methodClass": "android.app.AlertDialog", "methodName": "setButton3", "replacementComments": "/**\n* @deprecated Use {@link #setButton(int, CharSequence, Message)} with\n* {@link DialogInterface#BUTTON_NEUTRAL}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setButton(int, CharSequence, Message)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setButton(int, CharSequence, Message)", "fullMethod": "void setButton3(CharSequence,Message)", "method": "setButton3(CharSequence,Message)"}, "dragViewToBottom": {"methodClass": "android.test.TouchUtils", "methodName": "dragViewToBottom", "replacementComments": "/**\n* Simulate touching the center of a view and dragging to the bottom of the screen.\n*\n* @param test The test case that is being run\n* @param v The view that should be dragged\n*\n* @deprecated {@link android.test.ActivityInstrumentationTestCase} is deprecated in favor of\n* {@link android.test.ActivityInstrumentationTestCase2}, which provides more options for\n* configuring the Activity under test\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "android.test.ActivityInstrumentationTestCase2", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void dragViewToBottom(ActivityInstrumentationTestCase,View)", "method": "dragViewToBottom(ActivityInstrumentationTestCase,View)"}, "setBitmap": {"methodClass": "com.android.systemui.statusbar.phone.UserAvatarView", "methodName": "setBitmap", "replacementComments": "/**\n* @deprecated use {@link #setAvatar(Bitmap)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setAvatar(Bitmap)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setAvatar(Bitmap)", "fullMethod": "void setBitmap(Bitmap)", "method": "setBitmap(Bitmap)"}, "getPersistentDrawingCache": {"methodClass": "android.view.ViewGroup", "methodName": "getPersistentDrawingCache", "replacementComments": "/**\n* Returns an integer indicating what types of drawing caches are kept in memory.\n*\n* @see #setPersistentDrawingCache(int)\n* @see #setAnimationCacheEnabled(boolean)\n*\n* @return one or a combination of {@link #PERSISTENT_NO_CACHE},\n* {@link #PERSISTENT_ANIMATION_CACHE}, {@link #PERSISTENT_SCROLLING_CACHE}\n* and {@link #PERSISTENT_ALL_CACHES}\n*\n* @deprecated The view drawing cache was largely made obsolete with the introduction of\n* hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache\n* layers are largely unnecessary and can easily result in a net loss in performance due to the\n* cost of creating and updating the layer. In the rare cases where caching layers are useful,\n* such as for alpha animations, {@link #setLayerType(int, Paint)} handles this with hardware\n* rendering. For software-rendered snapshots of a small part of the View hierarchy or\n* individual Views it is recommended to create a {@link Canvas} from either a {@link Bitmap} or\n* {@link android.graphics.Picture} and call {@link #draw(Canvas)} on the View. However these\n* software-rendered usages are discouraged and have compatibility issues with hardware-only\n* rendering features such as {@link android.graphics.Bitmap.Config#HARDWARE Config.HARDWARE}\n* bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback\n* reports or unit testing the {@link PixelCopy} API is recommended.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setLayerType(int, Paint)", "methodReturn": "int", "isValid": true, "cleanReplacement": "setLayerType(int, Paint)", "fullMethod": "int getPersistentDrawingCache()", "method": "getPersistentDrawingCache()"}, "getNumApplications": {"methodClass": "com.android.internal.telephony.uicc.UiccCard", "methodName": "getNumApplications", "replacementComments": "/**\n* Returns number of applications on this card\n* @deprecated Please use {@link UiccProfile#getNumApplications()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "UiccProfile#getNumApplications()", "methodReturn": "int", "isValid": true, "cleanReplacement": "UiccProfile#getNumApplications()", "fullMethod": "int getNumApplications()", "method": "getNumApplications()"}, "addMessage": {"methodClass": "androidx.core.app.NotificationCompat.MessagingStyle", "methodName": "addMessage", "replacementComments": "/**\n* Adds a message for display by this notification. Convenience call for a simple\n* {@link Message} in {@link #addMessage(Message)}\n* @param text A {@link CharSequence} to be displayed as the message content\n* @param timestamp Time at which the message arrived in ms since Unix epoch\n* @param sender A {@link CharSequence} to be used for displaying the name of the\n* sender. Should be <code>null</code> for messages by the current user, in which case\n* the platform will insert {@link #getUserDisplayName()}.\n* Should be unique amongst all individuals in the conversation, and should be\n* consistent during re-posts of the notification.\n*\n* @see Message#Message(CharSequence, long, CharSequence)\n*\n* @return this object for method chaining\n*\n* @deprecated Use {@link #addMessage(CharSequence, long, Person)} or\n* {@link #addMessage(Message)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "addMessage(CharSequence, long, Person)", "methodReturn": "MessagingStyle", "isValid": true, "cleanReplacement": "addMessage(CharSequence, long, Person)", "fullMethod": "MessagingStyle addMessage(CharSequence,long,CharSequence)", "method": "addMessage(CharSequence,long,CharSequence)"}, "getInstance": {"methodClass": "androidx.core.content.SharedPreferencesCompat.EditorCompat", "methodName": "getInstance", "replacementComments": "/**\n* @deprecated This compatibility class is no longer required. Use\n* {@link SharedPreferences.Editor} directly.\n*/\n", "isClassDeprecated": true, "dirtyReplacement": "SharedPreferences.Editor", "methodReturn": "EditorCompat", "isValid": true, "cleanReplacement": "SharedPreferences.Editor", "fullMethod": "EditorCompat getInstance()", "method": "getInstance()"}, "currentClassLoader": {"methodClass": "java.lang.SecurityManager", "methodName": "currentClassLoader", "replacementComments": "/**\n* @deprecated Use {@link #checkPermission} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "checkPermission", "methodReturn": "ClassLoader", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "ClassLoader currentClassLoader()", "method": "currentClassLoader()"}, "inClassLoader": {"methodClass": "java.lang.SecurityManager", "methodName": "inClassLoader", "replacementComments": "/**\n* @deprecated Use {@link #checkPermission} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "checkPermission", "methodReturn": "boolean", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "boolean inClassLoader()", "method": "inClassLoader()"}, "onAttachFragment": {"methodClass": "android.app.Activity", "methodName": "onAttachFragment", "replacementComments": "/**\n* Called when a Fragment is being attached to this activity, immediately\n* after the call to its {@link Fragment#onAttach Fragment.onAttach()}\n* method and before {@link Fragment#onCreate Fragment.onCreate()}.\n*\n* @deprecated Use {@link\n* android.support.v4.app.FragmentActivity#onAttachFragment(android.support.v4.app.Fragment)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "android.support.v4.app.FragmentActivity#onAttachFragment(android.support.v4.app.Fragment)", "methodReturn": "void", "isValid": true, "cleanReplacement": "onAttachFragment(android.support.v4.app.Fragment)", "fullMethod": "void onAttachFragment(Fragment)", "method": "onAttachFragment(Fragment)"}, "getOverScrollMode": {"methodClass": "androidx.core.view.ViewCompat", "methodName": "getOverScrollMode", "replacementComments": "/**\n* Returns the over-scroll mode for this view. The result will be\n* one of {@link #OVER_SCROLL_ALWAYS} (default), {@link #OVER_SCROLL_IF_CONTENT_SCROLLS}\n* (allow over-scrolling only if the view content is larger than the container),\n* or {@link #OVER_SCROLL_NEVER}.\n*\n* @param v The View against which to invoke the method.\n* @return This view's over-scroll mode.\n* @deprecated Call {@link View#getOverScrollMode()} directly. This method will be\n* removed in a future release.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "View#getOverScrollMode()", "methodReturn": "int", "isValid": true, "cleanReplacement": "getOverScrollMode()", "fullMethod": "int getOverScrollMode(View)", "method": "getOverScrollMode(View)"}, "getTotalTimeLong": {"methodClass": "androidx.leanback.widget.PlaybackControlsRow", "methodName": "getTotalTimeLong", "replacementComments": "/**\n* Returns the total time in milliseconds of long type for the playback controls row.\n* @deprecated use {@link #getDuration()}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getDuration()", "methodReturn": "long", "isValid": true, "cleanReplacement": "getDuration()", "fullMethod": "long getTotalTimeLong()", "method": "getTotalTimeLong()"}, "removeAllCookie": {"methodClass": "android.webkit.CookieManager", "methodName": "removeAllCookie", "replacementComments": "/**\n* Removes all cookies.\n* @deprecated Use {@link #removeAllCookies(ValueCallback)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "removeAllCookies(ValueCallback)", "methodReturn": "void", "isValid": true, "cleanReplacement": "removeAllCookies(ValueCallback)", "fullMethod": "void removeAllCookie()", "method": "removeAllCookie()"}, "getUidUdpRxPackets": {"methodClass": "android.net.TrafficStats", "methodName": "getUidUdpRxPackets", "replacementComments": "/**\n* @deprecated Starting in {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2},\n* transport layer statistics are no longer available, and will\n* always return {@link #UNSUPPORTED}.\n* @see #getUidRxPackets(int)\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getUidRxPackets(int)", "methodReturn": "long", "isValid": true, "cleanReplacement": "getUidRxPackets(int)", "fullMethod": "long getUidUdpRxPackets(int)", "method": "getUidUdpRxPackets(int)"}, "addAccessibilityStateChangeListener": {"methodClass": "androidx.core.view.accessibility.AccessibilityManagerCompat", "methodName": "addAccessibilityStateChangeListener", "replacementComments": "/**\n* Registers an {@link AccessibilityManager.AccessibilityStateChangeListener} for changes in\n* the global accessibility state of the system.\n*\n* @param manager The accessibility manager.\n* @param listener The listener.\n* @return True if successfully registered.\n*\n* @deprecated Use {@link AccessibilityManager#addAccessibilityStateChangeListener(\n* AccessibilityManager.AccessibilityStateChangeListener)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityManager#addAccessibilityStateChangeListener(  AccessibilityManager.AccessibilityStateChangeListener)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "addAccessibilityStateChangeListener(  AccessibilityManager.AccessibilityStateChangeListener)", "fullMethod": "boolean addAccessibilityStateChangeListener(AccessibilityManager,AccessibilityStateChangeListener)", "method": "addAccessibilityStateChangeListener(AccessibilityManager,AccessibilityStateChangeListener)"}, "setDataFetchOperation": {"methodClass": "android.app.StatsManager", "methodName": "setDataFetchOperation", "replacementComments": "/**\n* @deprecated Use {@link #setFetchReportsOperation(PendingIntent, long)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setFetchReportsOperation(PendingIntent, long)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "setFetchReportsOperation(PendingIntent, long)", "fullMethod": "boolean setDataFetchOperation(long,PendingIntent)", "method": "setDataFetchOperation(long,PendingIntent)"}, "setOnClickListener": {"methodClass": "android.view.textclassifier.TextClassification.Builder", "methodName": "setOnClickListener", "replacementComments": "/**\n* Sets the OnClickListener for the <i>primary</i> action that may be triggered to act on\n* the classified text.\n*\n* <p><strong>NOTE: </strong>This field is not parcelable. If read from a parcel, the\n* returned OnClickListener represents the first {@link RemoteAction} (if one exists).\n*\n* @deprecated Use {@link #addAction(RemoteAction)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "addAction(RemoteAction)", "methodReturn": "Builder", "isValid": true, "cleanReplacement": "addAction(RemoteAction)", "fullMethod": "Builder setOnClickListener(OnClickListener)", "method": "setOnClickListener(OnClickListener)"}, "canScrollVertically": {"methodClass": "androidx.core.view.ViewCompat", "methodName": "canScrollVertically", "replacementComments": "/**\n* Check if this view can be scrolled vertically in a certain direction.\n*\n* @param view The View against which to invoke the method.\n* @param direction Negative to check scrolling up, positive to check scrolling down.\n* @return true if this view can be scrolled in the specified direction, false otherwise.\n*\n* @deprecated Use {@link View#canScrollVertically(int)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "View#canScrollVertically(int)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "canScrollVertically(int)", "fullMethod": "boolean canScrollVertically(View,int)", "method": "canScrollVertically(View,int)"}, "smoothSlideOpen": {"methodClass": "androidx.slidingpanelayout.widget.SlidingPaneLayout", "methodName": "smoothSlideOpen", "replacementComments": "/**\n* @deprecated Renamed to {@link #openPane()} - this method is going away soon!\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "openPane()", "methodReturn": "void", "isValid": true, "cleanReplacement": "openPane()", "fullMethod": "void smoothSlideOpen()", "method": "smoothSlideOpen()"}, "releaseAllSecureStops": {"methodClass": "android.media.MediaDrm", "methodName": "releaseAllSecureStops", "replacementComments": "/**\n* Remove all secure stops without requiring a secure stop release message from\n* the license server.\n*\n* @deprecated Remove all secure stops using {@link #removeAllSecureStops} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "removeAllSecureStops", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void releaseAllSecureStops()", "method": "releaseAllSecureStops()"}, "setupHeaderItemFocusHighlight": {"methodClass": "androidx.leanback.widget.FocusHighlightHelper", "methodName": "setupHeaderItemFocusHighlight", "replacementComments": "/**\n* Sets up default focus highlight behavior of a focused item in header list. It would scale\n* the focused item and update\n* {@link RowHeaderPresenter#onSelectLevelChanged(RowHeaderPresenter.ViewHolder)}.\n* Equivalent to call setupHeaderItemFocusHighlight(gridView, true).\n*\n* @param gridView  The header list.\n* @deprecated Use {@link #setupHeaderItemFocusHighlight(ItemBridgeAdapter)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setupHeaderItemFocusHighlight(ItemBridgeAdapter)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setupHeaderItemFocusHighlight(ItemBridgeAdapter)", "fullMethod": "void setupHeaderItemFocusHighlight(VerticalGridView)", "method": "setupHeaderItemFocusHighlight(VerticalGridView)"}, "getFinalX": {"methodClass": "androidx.core.widget.ScrollerCompat", "methodName": "getFinalX", "replacementComments": "/**\n* @return The final X position for the scroll in progress, if known.\n*\n* @deprecated Use {@link OverScroller#getFinalX()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "OverScroller#getFinalX()", "methodReturn": "int", "isValid": true, "cleanReplacement": "OverScroller#getFinalX()", "fullMethod": "int getFinalX()", "method": "getFinalX()"}, "isPurgingAllowed": {"methodClass": "android.os.MemoryFile", "methodName": "isPurgingAllowed", "replacementComments": "/**\n* Is memory file purging enabled?\n*\n* @return true if the file may be purged.\n*\n* @deprecated Purgable is considered generally fragile and hard to use safely. Applications\n* are recommend to instead use {@link android.content.ComponentCallbacks2#onTrimMemory(int)}\n* to react to memory events and release shared memory regions as appropriate.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "android.content.ComponentCallbacks2#onTrimMemory(int)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "onTrimMemory(int)", "fullMethod": "boolean isPurgingAllowed()", "method": "isPurgingAllowed()"}, "onCreateDialog": {"methodClass": "android.app.Activity", "methodName": "onCreateDialog", "replacementComments": "/**\n* @deprecated Old no-arguments version of {@link #onCreateDialog(int, Bundle)}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "onCreateDialog(int, Bundle)", "methodReturn": "Dialog", "isValid": true, "cleanReplacement": "onCreateDialog(int, Bundle)", "fullMethod": "Dialog onCreateDialog(int)", "method": "onCreateDialog(int)"}, "isDrawingCacheEnabled": {"methodClass": "android.view.View", "methodName": "isDrawingCacheEnabled", "replacementComments": "/**\n* <p>Indicates whether the drawing cache is enabled for this view.</p>\n*\n* @return true if the drawing cache is enabled\n*\n* @see #setDrawingCacheEnabled(boolean)\n* @see #getDrawingCache()\n*\n* @deprecated The view drawing cache was largely made obsolete with the introduction of\n* hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache\n* layers are largely unnecessary and can easily result in a net loss in performance due to the\n* cost of creating and updating the layer. In the rare cases where caching layers are useful,\n* such as for alpha animations, {@link #setLayerType(int, Paint)} handles this with hardware\n* rendering. For software-rendered snapshots of a small part of the View hierarchy or\n* individual Views it is recommended to create a {@link Canvas} from either a {@link Bitmap} or\n* {@link android.graphics.Picture} and call {@link #draw(Canvas)} on the View. However these\n* software-rendered usages are discouraged and have compatibility issues with hardware-only\n* rendering features such as {@link android.graphics.Bitmap.Config#HARDWARE Config.HARDWARE}\n* bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback\n* reports or unit testing the {@link PixelCopy} API is recommended.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setLayerType(int, Paint)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "setLayerType(int, Paint)", "fullMethod": "boolean isDrawingCacheEnabled()", "method": "isDrawingCacheEnabled()"}, "setTranslationX": {"methodClass": "androidx.core.view.ViewCompat", "methodName": "setTranslationX", "replacementComments": "/**\n* Sets the horizontal location of this view relative to its left position.\n* This effectively positions the object post-layout, in addition to wherever the object's\n* layout placed it.\n*\n* @param value The horizontal position of this view relative to its left position,\n* in pixels.\n*\n* @deprecated Use {@link View#setTranslationX(float)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "View#setTranslationX(float)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setTranslationX(float)", "fullMethod": "void setTranslationX(View,float)", "method": "setTranslationX(View,float)"}, "setTranslationY": {"methodClass": "androidx.core.view.ViewCompat", "methodName": "setTranslationY", "replacementComments": "/**\n* Sets the vertical location of this view relative to its top position.\n* This effectively positions the object post-layout, in addition to wherever the object's\n* layout placed it.\n*\n* @param value The vertical position of this view relative to its top position,\n* in pixels.\n*\n* @attr name android:translationY\n*\n* @deprecated Use {@link View#setTranslationY(float)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "View#setTranslationY(float)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setTranslationY(float)", "fullMethod": "void setTranslationY(View,float)", "method": "setTranslationY(View,float)"}, "setSummarySubtitle": {"methodClass": "androidx.slice.builders.ListBuilder.HeaderBuilder", "methodName": "setSummarySubtitle", "replacementComments": "/**\n* Sets the summary subtitle to be shown in this header. If unset, the normal subtitle\n* will be used. The summary is used when the parent template is presented in a\n* small format.\n* @deprecated TO BE REMOVED; use {@link #setSummary(CharSequence, boolean)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setSummary(CharSequence, boolean)", "methodReturn": "HeaderBuilder", "isValid": true, "cleanReplacement": "setSummary(CharSequence, boolean)", "fullMethod": "HeaderBuilder setSummarySubtitle(CharSequence,boolean)", "method": "setSummarySubtitle(CharSequence,boolean)"}, "getOnClickListener": {"methodClass": "android.view.textclassifier.TextClassification", "methodName": "getOnClickListener", "replacementComments": "/**\n* Returns the OnClickListener that may be triggered to act on the classified text.\n*\n* <p><strong>NOTE: </strong>This field is not parcelable and only represents the first\n* {@link RemoteAction} (if one exists) when this object is read from a parcel.\n*\n* @deprecated Use {@link #getActions()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getActions()", "methodReturn": "OnClickListener", "isValid": true, "cleanReplacement": "getActions()", "fullMethod": "OnClickListener getOnClickListener()", "method": "getOnClickListener()"}, "writeRepeatedEnum": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writeRepeatedEnum", "replacementComments": "/**\n* Write a single repeated proto enum type field value.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writeRepeatedEnum(long,int)", "method": "writeRepeatedEnum(long,int)"}, "dispatch": {"methodClass": "android.view.KeyEvent", "methodName": "dispatch", "replacementComments": "/**\n* @deprecated Use {@link #dispatch(Callback, DispatcherState, Object)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "dispatch(Callback, DispatcherState, Object)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "dispatch(Callback, DispatcherState, Object)", "fullMethod": "boolean dispatch(Callback)", "method": "dispatch(Callback)"}, "onConsoleMessage": {"methodClass": "android.webkit.WebChromeClient", "methodName": "onConsoleMessage", "replacementComments": "/**\n* Report a JavaScript error message to the host application. The ChromeClient\n* should override this to process the log message as they see fit.\n* @param message The error message to report.\n* @param lineNumber The line number of the error.\n* @param sourceID The name of the source file that caused the error.\n* @deprecated Use {@link #onConsoleMessage(ConsoleMessage) onConsoleMessage(ConsoleMessage)}\n* instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "onConsoleMessage(ConsoleMessage) onConsoleMessage(ConsoleMessage)", "methodReturn": "void", "isValid": true, "cleanReplacement": "onConsoleMessage(ConsoleMessage) onConsoleMessage(ConsoleMessage)", "fullMethod": "void onConsoleMessage(String,int,String)", "method": "onConsoleMessage(String,int,String)"}, "getRotation": {"methodClass": "androidx.core.view.ViewCompat", "methodName": "getRotation", "replacementComments": "/**\n* @deprecated Use {@link View#getRotation()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "View#getRotation()", "methodReturn": "float", "isValid": true, "cleanReplacement": "getRotation()", "fullMethod": "float getRotation(View)", "method": "getRotation(View)"}, "getCurrentHour": {"methodClass": "android.widget.TimePicker", "methodName": "getCurrentHour", "replacementComments": "/**\n* @return the currently selected hour, in the range (0-23)\n* @deprecated Use {@link #getHour()}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getHour()", "methodReturn": "Integer", "isValid": true, "cleanReplacement": "getHour()", "fullMethod": "Integer getCurrentHour()", "method": "getCurrentHour()"}, "setTextAppearance": {"methodClass": "android.widget.TextView", "methodName": "setTextAppearance", "replacementComments": "/**\n* Sets the text color, size, style, hint color, and highlight color\n* from the specified TextAppearance resource.\n*\n* @deprecated Use {@link #setTextAppearance(int)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setTextAppearance(int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setTextAppearance(int)", "fullMethod": "void setTextAppearance(Context,int)", "method": "setTextAppearance(Context,int)"}, "speak": {"methodClass": "android.speech.tts.TextToSpeech", "methodName": "speak", "replacementComments": "/**\n* Speaks the string using the specified queuing strategy and speech parameters.\n* This method is asynchronous, i.e. the method just adds the request to the queue of TTS\n* requests and then returns. The synthesis might not have finished (or even started!) at the\n* time when this method returns. In order to reliably detect errors during synthesis,\n* we recommend setting an utterance progress listener (see\n* {@link #setOnUtteranceProgressListener}) and using the\n* {@link Engine#KEY_PARAM_UTTERANCE_ID} parameter.\n*\n* @param text The string of text to be spoken. No longer than\n* {@link #getMaxSpeechInputLength()} characters.\n* @param queueMode The queuing strategy to use, {@link #QUEUE_ADD} or {@link #QUEUE_FLUSH}.\n* @param params Parameters for the request. Can be null.\n* Supported parameter names:\n* {@link Engine#KEY_PARAM_STREAM},\n* {@link Engine#KEY_PARAM_UTTERANCE_ID},\n* {@link Engine#KEY_PARAM_VOLUME},\n* {@link Engine#KEY_PARAM_PAN}.\n* Engine specific parameters may be passed in but the parameter keys\n* must be prefixed by the name of the engine they are intended for. For example\n* the keys \"com.svox.pico_foo\" and \"com.svox.pico:bar\" will be passed to the\n* engine named \"com.svox.pico\" if it is being used.\n*\n* @return {@link #ERROR} or {@link #SUCCESS} of <b>queuing</b> the speak operation.\n* @deprecated As of API level 21, replaced by\n* {@link #speak(CharSequence, int, Bundle, String)}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "speak(CharSequence, int, Bundle, String)", "methodReturn": "int", "isValid": true, "cleanReplacement": "speak(CharSequence, int, Bundle, String)", "fullMethod": "int speak(String,int,HashMap<String, String>)", "method": "speak(String,int,HashMap<String,"}, "getScrollBarSize": {"methodClass": "android.view.ViewConfiguration", "methodName": "getScrollBarSize", "replacementComments": "/**\n* @return The width of the horizontal scrollbar and the height of the vertical\n* scrollbar in dips\n*\n* @deprecated Use {@link #getScaledScrollBarSize()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getScaledScrollBarSize()", "methodReturn": "int", "isValid": true, "cleanReplacement": "getScaledScrollBarSize()", "fullMethod": "int getScrollBarSize()", "method": "getScrollBarSize()"}, "getMnc": {"methodClass": "android.telephony.CellIdentityGsm", "methodName": "getMnc", "replacementComments": "/**\n* @return 2 or 3-digit Mobile Network Code, 0..999, Integer.MAX_VALUE if unknown\n* @deprecated Use {@link #getMncString} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getMncString", "methodReturn": "int", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "int getMnc()", "method": "getMnc()"}, "getCarrierPrivilegeStatus": {"methodClass": "com.android.internal.telephony.uicc.UiccCard", "methodName": "getCarrierPrivilegeStatus", "replacementComments": "/**\n* Exposes {@link UiccCarrierPrivilegeRules#getCarrierPrivilegeStatus}.\n* @deprecated Please use\n* {@link UiccProfile#getCarrierPrivilegeStatus(PackageManager, String)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "UiccProfile#getCarrierPrivilegeStatus(PackageManager, String)", "methodReturn": "int", "isValid": true, "cleanReplacement": "getCarrierPrivilegeStatus(PackageManager, String)", "fullMethod": "int getCarrierPrivilegeStatus(PackageManager,String)", "method": "getCarrierPrivilegeStatus(PackageManager,String)"}, "onInflate": {"methodClass": "android.app.Fragment", "methodName": "onInflate", "replacementComments": "/**\n* @deprecated Use {@link #onInflate(Context, AttributeSet, Bundle)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "onInflate(Context, AttributeSet, Bundle)", "methodReturn": "void", "isValid": true, "cleanReplacement": "onInflate(Context, AttributeSet, Bundle)", "fullMethod": "void onInflate(Activity,AttributeSet,Bundle)", "method": "onInflate(Activity,AttributeSet,Bundle)"}, "getCheckItemIds": {"methodClass": "android.widget.ListView", "methodName": "getCheckItemIds", "replacementComments": "/**\n* Returns the set of checked items ids. The result is only valid if the\n* choice mode has not been set to {@link #CHOICE_MODE_NONE}.\n*\n* @return A new array which contains the id of each checked item in the\n* list.\n*\n* @deprecated Use {@link #getCheckedItemIds()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getCheckedItemIds()", "methodReturn": "long[]", "isValid": true, "cleanReplacement": "getCheckedItemIds()", "fullMethod": "long[] getCheckItemIds()", "method": "getCheckItemIds()"}, "removeConfiguration": {"methodClass": "android.app.StatsManager", "methodName": "removeConfiguration", "replacementComments": "/**\n* @deprecated Use {@link #removeConfig(long)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "removeConfig(long)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "removeConfig(long)", "fullMethod": "boolean removeConfiguration(long)", "method": "removeConfiguration(long)"}, "restoreAllState": {"methodClass": "android.app.FragmentController", "methodName": "restoreAllState", "replacementComments": "/**\n* Restores the saved state for all Fragments. The given Fragment list are Fragment\n* instances retained across configuration changes.\n*\n* @see #retainNonConfig()\n*\n* @deprecated use {@link #restoreAllState(Parcelable, FragmentManagerNonConfig)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "restoreAllState(Parcelable, FragmentManagerNonConfig)", "methodReturn": "void", "isValid": true, "cleanReplacement": "restoreAllState(Parcelable, FragmentManagerNonConfig)", "fullMethod": "void restoreAllState(Parcelable,List<Fragment>)", "method": "restoreAllState(Parcelable,List<Fragment>)"}, "setInverseBackgroundForced": {"methodClass": "androidx.appcompat.app.AlertDialog.Builder", "methodName": "setInverseBackgroundForced", "replacementComments": "/**\n* Sets the Dialog to use the inverse background, regardless of what the\n* contents is.\n*\n* @param useInverseBackground Whether to use the inverse background\n* @return This Builder object to allow for chaining of calls to set methods\n* @deprecated This flag is only used for pre-Material themes. Instead,\n* specify the window background using on the alert dialog\n* theme.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "d for pre-Material themes.", "methodReturn": "Builder", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "Builder setInverseBackgroundForced(boolean)", "method": "setInverseBackgroundForced(boolean)"}, "checkMulticast": {"methodClass": "java.lang.SecurityManager", "methodName": "checkMulticast", "replacementComments": "/**\n* @deprecated use {@link #checkMulticast(java.net.InetAddress)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "checkMulticast(java.net.InetAddress)", "methodReturn": "void", "isValid": true, "cleanReplacement": "checkMulticast(java.net.InetAddress)", "fullMethod": "void checkMulticast(InetAddress,byte)", "method": "checkMulticast(InetAddress,byte)"}, "getDescription": {"methodClass": "android.accessibilityservice.AccessibilityServiceInfo", "methodName": "getDescription", "replacementComments": "/**\n* Gets the non-localized description of the accessibility service.\n* <p>\n* <strong>Statically set from\n* {@link AccessibilityService#SERVICE_META_DATA meta-data}.</strong>\n* </p>\n* @return The description.\n*\n* @deprecated Use {@link #loadDescription(PackageManager)}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "loadDescription(PackageManager)", "methodReturn": "String", "isValid": true, "cleanReplacement": "loadDescription(PackageManager)", "fullMethod": "String getDescription()", "method": "getDescription()"}, "setEnhanced4gLteModeSetting": {"methodClass": "com.android.ims.ImsManager", "methodName": "setEnhanced4gLteModeSetting", "replacementComments": "/**\n* Change persistent Enhanced 4G LTE Mode setting.\n*\n* @deprecated Doesn't support MSIM devices. Use {@link #setEnhanced4gLteModeSetting(boolean)}\n* instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setEnhanced4gLteModeSetting(boolean)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setEnhanced4gLteModeSetting(boolean)", "fullMethod": "void setEnhanced4gLteModeSetting(Context,boolean)", "method": "setEnhanced4gLteModeSetting(Context,boolean)"}, "getFocusedVirtualView": {"methodClass": "androidx.customview.widget.ExploreByTouchHelper", "methodName": "getFocusedVirtualView", "replacementComments": "/**\n* Returns the virtual view ID for the currently accessibility focused\n* item.\n*\n* @return the identifier of the virtual view that has accessibility focus\n* or {@link #INVALID_ID} if no virtual view has accessibility\n* focus\n* @deprecated Use {@link #getAccessibilityFocusedVirtualViewId()}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getAccessibilityFocusedVirtualViewId()", "methodReturn": "int", "isValid": true, "cleanReplacement": "getAccessibilityFocusedVirtualViewId()", "fullMethod": "int getFocusedVirtualView()", "method": "getFocusedVirtualView()"}, "setRotationY": {"methodClass": "androidx.core.view.ViewCompat", "methodName": "setRotationY", "replacementComments": "/**\n* Sets the degrees that the view is rotated around the vertical axis through the pivot point.\n* Increasing values result in counter-clockwise rotation from the viewpoint of looking\n* down the y axis.\n*\n* @param value The degrees of Y rotation.\n*\n* @deprecated Use {@link View#setRotationY(float)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "View#setRotationY(float)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setRotationY(float)", "fullMethod": "void setRotationY(View,float)", "method": "setRotationY(View,float)"}, "getCurrX": {"methodClass": "androidx.core.widget.ScrollerCompat", "methodName": "getCurrX", "replacementComments": "/**\n* Returns the current X offset in the scroll.\n*\n* @return The new X offset as an absolute distance from the origin.\n*\n* @deprecated Use {@link OverScroller#getCurrX()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "OverScroller#getCurrX()", "methodReturn": "int", "isValid": true, "cleanReplacement": "OverScroller#getCurrX()", "fullMethod": "int getCurrX()", "method": "getCurrX()"}, "getCurrY": {"methodClass": "androidx.core.widget.ScrollerCompat", "methodName": "getCurrY", "replacementComments": "/**\n* Returns the current Y offset in the scroll.\n*\n* @return The new Y offset as an absolute distance from the origin.\n*\n* @deprecated Use {@link OverScroller#getCurrY()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "OverScroller#getCurrY()", "methodReturn": "int", "isValid": true, "cleanReplacement": "OverScroller#getCurrY()", "fullMethod": "int getCurrY()", "method": "getCurrY()"}, "buildQuery": {"methodClass": "android.database.sqlite.SQLiteQueryBuilder", "methodName": "buildQuery", "replacementComments": "/**\n* @deprecated This method's signature is misleading since no SQL parameter\n* substitution is carried out.  The selection arguments parameter does not get\n* used at all.  To avoid confusion, call\n* {@link #buildQuery(String[], String, String, String, String, String)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "buildQuery(String[], String, String, String, String, String)", "methodReturn": "String", "isValid": true, "cleanReplacement": "buildQuery(String[], String, String, String, String, String)", "fullMethod": "String buildQuery(String[],String,String[],String,String,String,String)", "method": "buildQuery(String[],String,String[],String,String,String,String)"}, "onDraw": {"methodClass": "androidx.recyclerview.widget.RecyclerView.ItemDecoration", "methodName": "onDraw", "replacementComments": "/**\n* @deprecated\n* Override {@link #onDraw(Canvas, RecyclerView, RecyclerView.State)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "onDraw(Canvas, RecyclerView, RecyclerView.State)", "methodReturn": "void", "isValid": true, "cleanReplacement": "onDraw(Canvas, RecyclerView, RecyclerView.State)", "fullMethod": "void onDraw(Canvas,RecyclerView)", "method": "onDraw(Canvas,RecyclerView)"}, "onStopNestedScroll": {"methodClass": "androidx.coordinatorlayout.widget.CoordinatorLayout.Behavior", "methodName": "onStopNestedScroll", "replacementComments": "/**\n* @deprecated You should now override\n* {@link #onStopNestedScroll(CoordinatorLayout, View, View, int)}. This method will still\n* continue to be called if the type is {@link ViewCompat#TYPE_TOUCH}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "onStopNestedScroll(CoordinatorLayout, View, View, int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "onStopNestedScroll(CoordinatorLayout, View, View, int)", "fullMethod": "void onStopNestedScroll(CoordinatorLayout,V,View)", "method": "onStopNestedScroll(CoordinatorLayout,V,View)"}, "writeRepeatedFixed64": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writeRepeatedFixed64", "replacementComments": "/**\n* Write a single repeated proto \"fixed64\" type field value.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writeRepeatedFixed64(long,long)", "method": "writeRepeatedFixed64(long,long)"}, "appendRecord": {"methodClass": "androidx.core.view.accessibility.AccessibilityEventCompat", "methodName": "appendRecord", "replacementComments": "/**\n* Appends an {@link android.view.accessibility.AccessibilityRecord} to the end of\n* event records.\n*\n* @param record The record to append.\n*\n* @throws IllegalStateException If called from an AccessibilityService.\n*\n* @deprecated Use {@link AccessibilityEvent#appendRecord(AccessibilityRecord)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityEvent#appendRecord(AccessibilityRecord)", "methodReturn": "void", "isValid": true, "cleanReplacement": "appendRecord(AccessibilityRecord)", "fullMethod": "void appendRecord(AccessibilityEvent,AccessibilityRecordCompat)", "method": "appendRecord(AccessibilityEvent,AccessibilityRecordCompat)"}, "inKeyguardRestrictedInputMode": {"methodClass": "android.app.KeyguardManager", "methodName": "inKeyguardRestrictedInputMode", "replacementComments": "/**\n* @deprecated Use {@link #isKeyguardLocked()} instead.\n*\n* If keyguard screen is showing or in restricted key input mode (i.e. in\n* keyguard password emergency screen). When in such mode, certain keys,\n* such as the Home key and the right soft keys, don't work.\n*\n* @return true if in keyguard restricted input mode.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "isKeyguardLocked()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "isKeyguardLocked()", "fullMethod": "boolean inKeyguardRestrictedInputMode()", "method": "inKeyguardRestrictedInputMode()"}, "writeSFixed32": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writeSFixed32", "replacementComments": "/**\n* Write a single proto \"sfixed32\" type field value.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writeSFixed32(long,int)", "method": "writeSFixed32(long,int)"}, "copyToFile": {"methodClass": "android.os.FileUtils", "methodName": "copyToFile", "replacementComments": "/**\n* @deprecated use {@link #copy(InputStream, OutputStream)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "copy(InputStream, OutputStream)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "copy(InputStream, OutputStream)", "fullMethod": "boolean copyToFile(InputStream,File)", "method": "copyToFile(InputStream,File)"}, "setOnTabChangedListener": {"methodClass": "androidx.legacy.app.FragmentTabHost", "methodName": "setOnTabChangedListener", "replacementComments": "/**\n* @deprecated Use {@link androidx.fragment.app.FragmentTabHost} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "androidx.fragment.app.FragmentTabHost", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void setOnTabChangedListener(OnTabChangeListener)", "method": "setOnTabChangedListener(OnTabChangeListener)"}, "getDrawable": {"methodClass": "android.content.res.Resources", "methodName": "getDrawable", "replacementComments": "/**\n* Return a drawable object associated with a particular resource ID.\n* Various types of objects will be returned depending on the underlying\n* resource -- for example, a solid color, PNG image, scalable image, etc.\n* The Drawable API hides these implementation details.\n*\n* <p class=\"note\"><strong>Note:</strong> Prior to\n* {@link android.os.Build.VERSION_CODES#JELLY_BEAN}, this function\n* would not correctly retrieve the final configuration density when\n* the resource ID passed here is an alias to another Drawable resource.\n* This means that if the density configuration of the alias resource\n* is different than the actual resource, the density of the returned\n* Drawable would be incorrect, resulting in bad scaling. To work\n* around this, you can instead manually resolve the aliased reference\n* by using {@link #getValue(int, TypedValue, boolean)} and passing\n* {@code true} for {@code resolveRefs}. The resulting\n* {@link TypedValue#resourceId} value may be passed to this method.</p>\n*\n* <p class=\"note\"><strong>Note:</strong> To obtain a themed drawable, use\n* {@link android.content.Context#getDrawable(int) Context.getDrawable(int)}\n* or {@link #getDrawable(int, Theme)} passing the desired theme.</p>\n*\n* @param id The desired resource identifier, as generated by the aapt\n* tool. This integer encodes the package, type, and resource\n* entry. The value 0 is an invalid identifier.\n* @return Drawable An object that can be used to draw this resource.\n* @throws NotFoundException Throws NotFoundException if the given ID does\n* not exist.\n* @see #getDrawable(int, Theme)\n* @deprecated Use {@link #getDrawable(int, Theme)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getDrawable(int, Theme)", "methodReturn": "Drawable", "isValid": true, "cleanReplacement": "getDrawable(int, Theme)", "fullMethod": "Drawable getDrawable(int)", "method": "getDrawable(int)"}, "writeRepeatedSInt32": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writeRepeatedSInt32", "replacementComments": "/**\n* Write a single repeated proto \"sint32\" type field value.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writeRepeatedSInt32(long,int)", "method": "writeRepeatedSInt32(long,int)"}, "setPrimaryItem": {"methodClass": "androidx.viewpager.widget.PagerAdapter", "methodName": "setPrimaryItem", "replacementComments": "/**\n* Called to inform the adapter of which item is currently considered to\n* be the \"primary\", that is the one show to the user as the current page.\n*\n* @param container The containing View from which the page will be removed.\n* @param position The page position that is now the primary.\n* @param object The same object that was returned by\n* {@link #instantiateItem(View, int)}.\n*\n* @deprecated Use {@link #setPrimaryItem(ViewGroup, int, Object)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setPrimaryItem(ViewGroup, int, Object)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setPrimaryItem(ViewGroup, int, Object)", "fullMethod": "void setPrimaryItem(View,int,Object)", "method": "setPrimaryItem(View,int,Object)"}, "isWfcEnabledByUser": {"methodClass": "com.android.ims.ImsManager", "methodName": "isWfcEnabledByUser", "replacementComments": "/**\n* Returns the user configuration of WFC setting\n*\n* @deprecated Does not support MSIM devices. Please use\n* {@link #isWfcEnabledByUser()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "isWfcEnabledByUser()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "isWfcEnabledByUser()", "fullMethod": "boolean isWfcEnabledByUser(Context)", "method": "isWfcEnabledByUser(Context)"}, "getMonthString": {"methodClass": "android.text.format.DateUtils", "methodName": "getMonthString", "replacementComments": "/**\n* Return a localized string for the month of the year.\n* @param month One of {@link Calendar#JANUARY Calendar.JANUARY},\n* {@link Calendar#FEBRUARY Calendar.FEBRUARY}, etc.\n* @param abbrev One of {@link #LENGTH_LONG}, {@link #LENGTH_MEDIUM},\n* or {@link #LENGTH_SHORTEST}.\n* Undefined lengths will return {@link #LENGTH_MEDIUM}\n* but may return something different in the future.\n* @return Localized month of the year.\n* @deprecated Use {@link java.text.SimpleDateFormat} instead.\n*/\n", "isClassDeprecated": true, "dirtyReplacement": "java.text.SimpleDateFormat", "methodReturn": "String", "isValid": true, "cleanReplacement": "java.text.SimpleDateFormat", "fullMethod": "String getMonthString(int,int)", "method": "getMonthString(int,int)"}, "getMinimumFlingVelocity": {"methodClass": "android.view.ViewConfiguration", "methodName": "getMinimumFlingVelocity", "replacementComments": "/**\n* @return Minimum velocity to initiate a fling, as measured in dips per second.\n*\n* @deprecated Use {@link #getScaledMinimumFlingVelocity()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getScaledMinimumFlingVelocity()", "methodReturn": "int", "isValid": true, "cleanReplacement": "getScaledMinimumFlingVelocity()", "fullMethod": "int getMinimumFlingVelocity()", "method": "getMinimumFlingVelocity()"}, "asInterface": {"methodClass": "android.app.ActivityManagerNative", "methodName": "asInterface", "replacementComments": "/**\n* Cast a Binder object into an activity manager interface, generating\n* a proxy if needed.\n*\n* @deprecated use IActivityManager.Stub.asInterface instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "IActivityManager.Stub.asInterface", "methodReturn": "IActivityManager", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "IActivityManager asInterface(IBinder)", "method": "asInterface(IBinder)"}, "dispatchMultiWindowModeChanged": {"methodClass": "android.app.FragmentController", "methodName": "dispatchMultiWindowModeChanged", "replacementComments": "/**\n* Lets all Fragments managed by the controller's FragmentManager know the multi-window mode of\n* the activity changed.\n* <p>Call when the multi-window mode of the activity changed.\n*\n* @see Fragment#onMultiWindowModeChanged\n* @deprecated use {@link #dispatchMultiWindowModeChanged(boolean, Configuration)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "dispatchMultiWindowModeChanged(boolean, Configuration)", "methodReturn": "void", "isValid": true, "cleanReplacement": "dispatchMultiWindowModeChanged(boolean, Configuration)", "fullMethod": "void dispatchMultiWindowModeChanged(boolean)", "method": "dispatchMultiWindowModeChanged(boolean)"}, "setAutoMeasureEnabled": {"methodClass": "androidx.recyclerview.widget.RecyclerView.LayoutManager", "methodName": "setAutoMeasureEnabled", "replacementComments": "/**\n* Defines whether the measuring pass of layout should use the AutoMeasure mechanism of\n* {@link RecyclerView} or if it should be done by the LayoutManager's implementation of\n* {@link LayoutManager#onMeasure(Recycler, State, int, int)}.\n*\n* @param enabled <code>True</code> if layout measurement should be done by the\n* RecyclerView, <code>false</code> if it should be done by this\n* LayoutManager.\n*\n* @see #isAutoMeasureEnabled()\n*\n* @deprecated Implementors of LayoutManager should define whether or not it uses\n* AutoMeasure by overriding {@link #isAutoMeasureEnabled()}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "isAutoMeasureEnabled()", "methodReturn": "void", "isValid": true, "cleanReplacement": "isAutoMeasureEnabled()", "fullMethod": "void setAutoMeasureEnabled(boolean)", "method": "setAutoMeasureEnabled(boolean)"}, "setErrorMessage": {"methodClass": "android.support.v4.media.session.PlaybackStateCompat.Builder", "methodName": "setErrorMessage", "replacementComments": "/**\n* Set a user readable error message. This should be set when the state\n* is {@link PlaybackStateCompat#STATE_ERROR}.\n*\n* @return this\n* @deprecated Use {@link #setErrorMessage(int, CharSequence)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setErrorMessage(int, CharSequence)", "methodReturn": "Builder", "isValid": true, "cleanReplacement": "setErrorMessage(int, CharSequence)", "fullMethod": "Builder setErrorMessage(CharSequence)", "method": "setErrorMessage(CharSequence)"}, "getContextHubInfo": {"methodClass": "android.hardware.location.ContextHubManager", "methodName": "getContextHubInfo", "replacementComments": "/**\n* Get more information about a specific hub.\n*\n* @param hubHandle Handle (system-wide unique identifier) of a context hub.\n* @return ContextHubInfo Information about the requested context hub.\n*\n* @see ContextHubInfo\n*\n* @deprecated Use {@link #getContextHubs()} instead. The use of handles are deprecated in the\n* new APIs.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getContextHubs()", "methodReturn": "ContextHubInfo", "isValid": true, "cleanReplacement": "getContextHubs()", "fullMethod": "ContextHubInfo getContextHubInfo(int)", "method": "getContextHubInfo(int)"}, "updateCursor": {"methodClass": "android.view.inputmethod.InputMethodManager", "methodName": "updateCursor", "replacementComments": "/**\n* Report the current cursor location in its window.\n*\n* @deprecated Use {@link #updateCursorAnchorInfo(View, CursorAnchorInfo)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "updateCursorAnchorInfo(View, CursorAnchorInfo)", "methodReturn": "void", "isValid": true, "cleanReplacement": "updateCursorAnchorInfo(View, CursorAnchorInfo)", "fullMethod": "void updateCursor(View,int,int,int,int)", "method": "updateCursor(View,int,int,int,int)"}, "onRequestSendAccessibilityEvent": {"methodClass": "androidx.core.view.ViewGroupCompat", "methodName": "onRequestSendAccessibilityEvent", "replacementComments": "/**\n* Called when a child has requested sending an {@link AccessibilityEvent} and\n* gives an opportunity to its parent to augment the event.\n* <p>\n* If an {@link AccessibilityDelegateCompat} has been specified via calling\n* {@link ViewCompat#setAccessibilityDelegate(View, AccessibilityDelegateCompat)} its\n* {@link AccessibilityDelegateCompat#onRequestSendAccessibilityEvent(ViewGroup, View,\n* AccessibilityEvent)} is responsible for handling this call.\n* </p>\n*\n* @param group The group whose method to invoke.\n* @param child The child which requests sending the event.\n* @param event The event to be sent.\n* @return True if the event should be sent.\n*\n* @deprecated Use {@link ViewGroup#onRequestSendAccessibilityEvent(View, AccessibilityEvent)}\n* directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "ViewGroup#onRequestSendAccessibilityEvent(View, AccessibilityEvent)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "onRequestSendAccessibilityEvent(View, AccessibilityEvent)", "fullMethod": "boolean onRequestSendAccessibilityEvent(ViewGroup,View,AccessibilityEvent)", "method": "onRequestSendAccessibilityEvent(ViewGroup,View,AccessibilityEvent)"}, "getTranslationX": {"methodClass": "androidx.core.view.ViewCompat", "methodName": "getTranslationX", "replacementComments": "/**\n* The horizontal location of this view relative to its {@link View#getLeft() left} position.\n* This position is post-layout, in addition to wherever the object's\n* layout placed it.\n*\n* @return The horizontal position of this view relative to its left position, in pixels.\n*\n* @deprecated Use {@link View#getTranslationX()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "View#getTranslationX()", "methodReturn": "float", "isValid": true, "cleanReplacement": "getTranslationX()", "fullMethod": "float getTranslationX(View)", "method": "getTranslationX(View)"}, "findPointerIndex": {"methodClass": "androidx.core.view.MotionEventCompat", "methodName": "findPointerIndex", "replacementComments": "/**\n* Call {@link MotionEvent#findPointerIndex(int)}.\n*\n* @deprecated Call {@link MotionEvent#findPointerIndex(int)} directly. This method will be\n* removed in a future release.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "MotionEvent#findPointerIndex(int)", "methodReturn": "int", "isValid": true, "cleanReplacement": "findPointerIndex(int)", "fullMethod": "int findPointerIndex(MotionEvent,int)", "method": "findPointerIndex(MotionEvent,int)"}, "supportInvalidateOptionsMenu": {"methodClass": "androidx.fragment.app.FragmentActivity", "methodName": "supportInvalidateOptionsMenu", "replacementComments": "/**\n* Support library version of {@link Activity#invalidateOptionsMenu}.\n*\n* <p>Invalidate the activity's options menu. This will cause relevant presentations\n* of the menu to fully update via calls to onCreateOptionsMenu and\n* onPrepareOptionsMenu the next time the menu is requested.\n*\n* @deprecated Call {@link Activity#invalidateOptionsMenu} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "Activity#invalidateOptionsMenu", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void supportInvalidateOptionsMenu()", "method": "supportInvalidateOptionsMenu()"}, "isVtEnabledByUser": {"methodClass": "com.android.ims.ImsManager", "methodName": "isVtEnabledByUser", "replacementComments": "/**\n* Returns the user configuration of VT setting\n* @deprecated Does not support MSIM devices. Please use\n* {@link #isVtEnabledByUser()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "isVtEnabledByUser()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "isVtEnabledByUser()", "fullMethod": "boolean isVtEnabledByUser(Context)", "method": "isVtEnabledByUser(Context)"}, "getTranslationY": {"methodClass": "androidx.core.view.ViewCompat", "methodName": "getTranslationY", "replacementComments": "/**\n* The vertical location of this view relative to its {@link View#getTop() top} position.\n* This position is post-layout, in addition to wherever the object's\n* layout placed it.\n*\n* @return The vertical position of this view relative to its top position, in pixels.\n*\n* @deprecated Use {@link View#getTranslationY()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "View#getTranslationY()", "methodReturn": "float", "isValid": true, "cleanReplacement": "getTranslationY()", "fullMethod": "float getTranslationY(View)", "method": "getTranslationY(View)"}, "onSendDataSms": {"methodClass": "android.service.carrier.CarrierMessagingService", "methodName": "onSendDataSms", "replacementComments": "/**\n* Override this method to intercept binary SMSs sent from the device.\n* @deprecated Override {@link #onSendDataSms} below instead.\n*\n* @param data the binary content\n* @param subId SMS subscription ID of the SIM\n* @param destAddress phone number of the recipient of the message\n* @param destPort the destination port\n* @param callback result callback. Call with a {@link SendSmsResult}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "onSendDataSms", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void onSendDataSms(byte[],int,String,int,ResultCallback<SendSmsResult>)", "method": "onSendDataSms(byte[],int,String,int,ResultCallback<SendSmsResult>)"}, "parse": {"methodClass": "com.android.vcard.VCardParser", "methodName": "parse", "replacementComments": "/**\n* @deprecated use {@link #addInterpreter(VCardInterpreter)} and\n* {@link #parse(InputStream)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "addInterpreter(VCardInterpreter)", "methodReturn": "void", "isValid": true, "cleanReplacement": "addInterpreter(VCardInterpreter)", "fullMethod": "void parse(InputStream,VCardInterpreter)", "method": "parse(InputStream,VCardInterpreter)"}, "getChildMeasureSpec": {"methodClass": "com.android.internal.widget.RecyclerView.LayoutManager", "methodName": "getChildMeasureSpec", "replacementComments": "/**\n* Calculate a MeasureSpec value for measuring a child view in one dimension.\n*\n* @param parentSize Size of the parent view where the child will be placed\n* @param padding Total space currently consumed by other elements of the parent\n* @param childDimension Desired size of the child view, or MATCH_PARENT/WRAP_CONTENT.\n* Generally obtained from the child view's LayoutParams\n* @param canScroll true if the parent RecyclerView can scroll in this dimension\n*\n* @return a MeasureSpec value for the child view\n* @deprecated use {@link #getChildMeasureSpec(int, int, int, int, boolean)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getChildMeasureSpec(int, int, int, int, boolean)", "methodReturn": "int", "isValid": true, "cleanReplacement": "getChildMeasureSpec(int, int, int, int, boolean)", "fullMethod": "int getChildMeasureSpec(int,int,int,boolean)", "method": "getChildMeasureSpec(int,int,int,boolean)"}, "setClassName": {"methodClass": "androidx.core.view.accessibility.AccessibilityRecordCompat", "methodName": "setClassName", "replacementComments": "/**\n* Sets the class name of the source.\n*\n* @param className The lass name.\n*\n* @throws IllegalStateException If called from an AccessibilityService.\n*\n* @deprecated Use {@link AccessibilityRecord#setClassName(CharSequence)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityRecord#setClassName(CharSequence)", "methodReturn": "void", "isValid": true, "cleanReplacement": "AccessibilityRecord#setClassName(CharSequence)", "fullMethod": "void setClassName(CharSequence)", "method": "setClassName(CharSequence)"}, "addTab": {"methodClass": "androidx.legacy.app.FragmentTabHost", "methodName": "addTab", "replacementComments": "/**\n* @deprecated Use {@link androidx.fragment.app.FragmentTabHost} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "androidx.fragment.app.FragmentTabHost", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void addTab(TabSpec,Class<?>,Bundle)", "method": "addTab(TabSpec,Class<?>,Bundle)"}, "onScreenTurnedOff": {"methodClass": "com.android.keyguard.KeyguardUpdateMonitorCallback", "methodName": "onScreenTurnedOff", "replacementComments": "/**\n* Called when the screen has been turned off.\n*\n* @deprecated use {@link com.android.systemui.keyguard.ScreenLifecycle}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "com.android.systemui.keyguard.ScreenLifecycle", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void onScreenTurnedOff()", "method": "onScreenTurnedOff()"}, "notifyChange": {"methodClass": "android.database.ContentObservable", "methodName": "notifyChange", "replacementComments": "/**\n* Invokes {@link ContentObserver#onChange} on each observer.\n*\n* @param selfChange True if this is a self-change notification.\n*\n* @deprecated Use {@link #dispatchChange} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "dispatchChange", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void notifyChange(boolean)", "method": "notifyChange(boolean)"}, "setSeconds": {"methodClass": "java.sql.Date", "methodName": "setSeconds", "replacementComments": "/**\n* @deprecated This method is deprecated and should not be used because SQL Date\n* values do not have a time component.\n*\n* @exception java.lang.IllegalArgumentException if this method is invoked\n* @see #getSeconds\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getSeconds", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void setSeconds(int)", "method": "setSeconds(int)"}, "getScaleY": {"methodClass": "androidx.core.view.ViewCompat", "methodName": "getScaleY", "replacementComments": "/**\n* @deprecated Use {@link View#getScaleY()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "View#getScaleY()", "methodReturn": "float", "isValid": true, "cleanReplacement": "getScaleY()", "fullMethod": "float getScaleY(View)", "method": "getScaleY(View)"}, "getScaleX": {"methodClass": "androidx.core.view.ViewCompat", "methodName": "getScaleX", "replacementComments": "/**\n* @deprecated Use {@link View#getScaleX()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "View#getScaleX()", "methodReturn": "float", "isValid": true, "cleanReplacement": "getScaleX()", "fullMethod": "float getScaleX(View)", "method": "getScaleX(View)"}, "addToMyContactsGroup": {"methodClass": "android.provider.Contacts.People", "methodName": "addToMyContactsGroup", "replacementComments": "/**\n* Adds a person to the My Contacts group.\n*\n* @param resolver the resolver to use\n* @param personId the person to add to the group\n* @return the URI of the group membership row\n* @throws IllegalStateException if the My Contacts group can't be found\n* @deprecated see {@link android.provider.ContactsContract}\n*/\n", "isClassDeprecated": true, "dirtyReplacement": "android.provider.ContactsContract", "methodReturn": "Uri", "isValid": true, "cleanReplacement": "android.provider.ContactsContract", "fullMethod": "Uri addToMyContactsGroup(ContentResolver,long)", "method": "addToMyContactsGroup(ContentResolver,long)"}, "invalidateChildInParent": {"methodClass": "android.view.ViewParent", "methodName": "invalidateChildInParent", "replacementComments": "/**\n* All or part of a child is dirty and needs to be redrawn.\n*\n* <p>The location array is an array of two int values which respectively\n* define the left and the top position of the dirty child.</p>\n*\n* <p>This method must return the parent of this ViewParent if the specified\n* rectangle must be invalidated in the parent. If the specified rectangle\n* does not require invalidation in the parent or if the parent does not\n* exist, this method must return null.</p>\n*\n* <p>When this method returns a non-null value, the location array must\n* have been updated with the left and top coordinates of this ViewParent.</p>\n*\n* @param location An array of 2 ints containing the left and top\n* coordinates of the child to invalidate\n* @param r The area within the child that is invalid\n*\n* @return the parent of this ViewParent or null\n*\n* @deprecated Use {@link #onDescendantInvalidated(View, View)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "onDescendantInvalidated(View, View)", "methodReturn": "ViewParent", "isValid": true, "cleanReplacement": "onDescendantInvalidated(View, View)", "fullMethod": "ViewParent invalidateChildInParent(int[],Rect)", "method": "invalidateChildInParent(int[],Rect)"}, "onSignalStrengthChanged": {"methodClass": "android.telephony.PhoneStateListener", "methodName": "onSignalStrengthChanged", "replacementComments": "/**\n* Callback invoked when network signal strength changes.\n*\n* @see ServiceState#STATE_EMERGENCY_ONLY\n* @see ServiceState#STATE_IN_SERVICE\n* @see ServiceState#STATE_OUT_OF_SERVICE\n* @see ServiceState#STATE_POWER_OFF\n* @deprecated Use {@link #onSignalStrengthsChanged(SignalStrength)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "onSignalStrengthsChanged(SignalStrength)", "methodReturn": "void", "isValid": true, "cleanReplacement": "onSignalStrengthsChanged(SignalStrength)", "fullMethod": "void onSignalStrengthChanged(int)", "method": "onSignalStrengthChanged(int)"}, "setWallpaper": {"methodClass": "android.content.Context", "methodName": "setWallpaper", "replacementComments": "/**\n* @deprecated Use {@link android.app.WallpaperManager#setStream(InputStream)\n* WallpaperManager.set()} instead.\n* <p>This method requires the caller to hold the permission\n* {@link android.Manifest.permission#SET_WALLPAPER}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "android.app.WallpaperManager#setStream(InputStream)  WallpaperManager.set()", "methodReturn": "void", "isValid": true, "cleanReplacement": "setStream(InputStream)  WallpaperManager.set()", "fullMethod": "void setWallpaper(InputStream)", "method": "setWallpaper(InputStream)"}, "setEngineByPackageName": {"methodClass": "android.speech.tts.TextToSpeech", "methodName": "setEngineByPackageName", "replacementComments": "/**\n* Sets the TTS engine to use.\n*\n* @deprecated This doesn't inform callers when the TTS engine has been\n* initialized. {@link #TextToSpeech(Context, OnInitListener, String)}\n* can be used with the appropriate engine name. Also, there is no\n* guarantee that the engine specified will be loaded. If it isn't\n* installed or disabled, the user / system wide defaults will apply.\n*\n* @param enginePackageName The package name for the synthesis engine (e.g. \"com.svox.pico\")\n*\n* @return {@link #ERROR} or {@link #SUCCESS}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "TextToSpeech(Context, OnInitListener, String)", "methodReturn": "int", "isValid": true, "cleanReplacement": "TextToSpeech(Context, OnInitListener, String)", "fullMethod": "int setEngineByPackageName(String)", "method": "setEngineByPackageName(String)"}, "onPull": {"methodClass": "androidx.core.widget.EdgeEffectCompat", "methodName": "onPull", "replacementComments": "/**\n* A view should call this when content is pulled away from an edge by the user.\n* This will update the state of the current visual effect and its associated animation.\n* The host view should always {@link android.view.View#invalidate()} if this method\n* returns true and draw the results accordingly.\n*\n* Views using {@link EdgeEffect} should favor {@link EdgeEffect#onPull(float, float)} when\n* the displacement of the pull point is known.\n*\n* @param deltaDistance Change in distance since the last call. Values may be 0 (no change) to\n* 1.f (full length of the view) or negative values to express change\n* back toward the edge reached to initiate the effect.\n* @param displacement The displacement from the starting side of the effect of the point\n* initiating the pull. In the case of touch this is the finger position.\n* Values may be from 0-1.\n* @return true if the host view should call invalidate, false if it should not.\n*\n* @deprecated Use {@link EdgeEffect#onPull(float)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "EdgeEffect#onPull(float)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "onPull(float)", "fullMethod": "boolean onPull(float,float)", "method": "onPull(float,float)"}, "onMonitoringSystemChange": {"methodClass": "android.hardware.location.GeofenceHardwareMonitorCallback", "methodName": "onMonitoringSystemChange", "replacementComments": "/**\n* The callback called when the state of a monitoring system changes.\n* {@link GeofenceHardware#MONITORING_TYPE_GPS_HARDWARE} is an example of a\n* monitoring system.\n*\n* @deprecated use {@link #onMonitoringSystemChange(GeofenceHardwareMonitorEvent)} instead.\n* NOTE: this API is will remain to be called on Android API 21 and above for backwards\n* compatibility. But clients must stop implementing it when updating their code.\n*\n* @param monitoringType The type of the monitoring system.\n* @param available Indicates whether the system is currently available or not.\n* @param location The last known location according to the monitoring system.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "onMonitoringSystemChange(GeofenceHardwareMonitorEvent)", "methodReturn": "void", "isValid": true, "cleanReplacement": "onMonitoringSystemChange(GeofenceHardwareMonitorEvent)", "fullMethod": "void onMonitoringSystemChange(int,boolean,Location)", "method": "onMonitoringSystemChange(int,boolean,Location)"}, "setStreamType": {"methodClass": "android.media.Ringtone", "methodName": "setStreamType", "replacementComments": "/**\n* Sets the stream type where this ringtone will be played.\n*\n* @param streamType The stream, see {@link AudioManager}.\n* @deprecated use {@link #setAudioAttributes(AudioAttributes)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setAudioAttributes(AudioAttributes)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setAudioAttributes(AudioAttributes)", "fullMethod": "void setStreamType(int)", "method": "setStreamType(int)"}, "setDate": {"methodClass": "java.sql.Time", "methodName": "setDate", "replacementComments": "/**\n* @deprecated This method is deprecated and should not be used because SQL <code>TIME</code>\n* values do not have a date component.\n*\n* @exception java.lang.IllegalArgumentException if this\n* method is invoked\n* @see #getDate\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getDate", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void setDate(int)", "method": "setDate(int)"}, "getVibrateSetting": {"methodClass": "android.media.AudioManager", "methodName": "getVibrateSetting", "replacementComments": "/**\n* Returns whether the user's vibrate setting for a vibrate type.\n* <p>\n* This shouldn't be needed by most clients that want to vibrate, instead\n* see {@link #shouldVibrate(int)}.\n*\n* @param vibrateType The type of vibrate. One of\n* {@link #VIBRATE_TYPE_NOTIFICATION} or\n* {@link #VIBRATE_TYPE_RINGER}.\n* @return The vibrate setting, one of {@link #VIBRATE_SETTING_ON},\n* {@link #VIBRATE_SETTING_OFF}, or\n* {@link #VIBRATE_SETTING_ONLY_SILENT}.\n* @see #setVibrateSetting(int, int)\n* @see #shouldVibrate(int)\n* @deprecated Applications should maintain their own vibrate policy based on\n* current ringer mode that can be queried via {@link #getRingerMode()}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getRingerMode()", "methodReturn": "int", "isValid": true, "cleanReplacement": "getRingerMode()", "fullMethod": "int getVibrateSetting(int)", "method": "getVibrateSetting(int)"}, "onPasswordSucceeded": {"methodClass": "android.app.admin.DeviceAdminReceiver", "methodName": "onPasswordSucceeded", "replacementComments": "/**\n* Called after the user has succeeded at entering their device or profile challenge password,\n* as a result of receiving {@link #ACTION_PASSWORD_SUCCEEDED}.  This will\n* only be received the first time they succeed after having previously\n* failed.\n* @param context The running context as per {@link #onReceive}.\n* @param intent The received intent as per {@link #onReceive}.\n*\n* @deprecated From {@link android.os.Build.VERSION_CODES#O}, use\n* {@link #onPasswordSucceeded(Context, Intent, UserHandle)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "onPasswordSucceeded(Context, Intent, UserHandle)", "methodReturn": "void", "isValid": true, "cleanReplacement": "onPasswordSucceeded(Context, Intent, UserHandle)", "fullMethod": "void onPasswordSucceeded(Context,Intent)", "method": "onPasswordSucceeded(Context,Intent)"}, "numberToCalledPartyBCD": {"methodClass": "android.telephony.PhoneNumberUtils", "methodName": "numberToCalledPartyBCD", "replacementComments": "/**\n* Convert a dialing number to BCD byte array\n*\n* @param number dialing number string. If the dialing number starts with '+', set to\n* international TOA\n*\n* @return BCD byte array\n*\n* @deprecated use {@link #numberToCalledPartyBCD(String, int)} instead. Calling this method\n* is equivalent to calling {@link #numberToCalledPartyBCD(String, int)} with\n* {@link #BCD_EXTENDED_TYPE_EF_ADN} as the extended type.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "numberToCalledPartyBCD(String, int)", "methodReturn": "byte[]", "isValid": true, "cleanReplacement": "numberToCalledPartyBCD(String, int)", "fullMethod": "byte[] numberToCalledPartyBCD(String)", "method": "numberToCalledPartyBCD(String)"}, "addPreferredActivity": {"methodClass": "android.content.pm.PackageManager", "methodName": "addPreferredActivity", "replacementComments": "/**\n* @deprecated This is a protected API that should not have been available\n* to third party applications.  It is the platform's responsibility for\n* assigning preferred activities and this cannot be directly modified.\n*\n* Add a new preferred activity mapping to the system.  This will be used\n* to automatically select the given activity component when\n* {@link Context#startActivity(Intent) Context.startActivity()} finds\n* multiple matching activities and also matches the given filter.\n*\n* @param filter The set of intents under which this activity will be\n* made preferred.\n* @param match The IntentFilter match category that this preference\n* applies to.\n* @param set The set of activities that the user was picking from when\n* this preference was made.\n* @param activity The component name of the activity that is to be\n* preferred.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "Context#startActivity(Intent) Context.startActivity()", "methodReturn": "void", "isValid": true, "cleanReplacement": "startActivity(Intent) Context.startActivity()", "fullMethod": "void addPreferredActivity(IntentFilter,int,ComponentName[],ComponentName)", "method": "addPreferredActivity(IntentFilter,int,ComponentName[],ComponentName)"}, "getExtraVisibility": {"methodClass": "androidx.leanback.widget.BaseCardView", "methodName": "getExtraVisibility", "replacementComments": "/**\n* Returns the visibility of the extra region of the card.\n* @deprecated Extra view's visibility is controlled by {@link #getInfoVisibility()}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getInfoVisibility()", "methodReturn": "int", "isValid": true, "cleanReplacement": "getInfoVisibility()", "fullMethod": "int getExtraVisibility()", "method": "getExtraVisibility()"}, "generateAsync": {"methodClass": "com.android.internal.graphics.palette.Palette", "methodName": "generateAsync", "replacementComments": "/**\n* @deprecated Use {@link Palette.Builder} to generate the Palette.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "Palette.Builder", "methodReturn": "AsyncTask<Bitmap,", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "AsyncTask<Bitmap, Void, Palette> generateAsync(Bitmap,PaletteAsyncListener)", "method": "Void,"}, "isWatchingCursor": {"methodClass": "android.view.inputmethod.InputMethodManager", "methodName": "isWatchingCursor", "replacementComments": "/**\n* Return true if the current input method wants to watch the location\n* of the input editor's cursor in its window.\n*\n* @deprecated Use {@link InputConnection#requestCursorUpdates(int)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "InputConnection#requestCursorUpdates(int)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "requestCursorUpdates(int)", "fullMethod": "boolean isWatchingCursor(View)", "method": "isWatchingCursor(View)"}, "drawBitmap": {"methodClass": "android.graphics.Canvas", "methodName": "drawBitmap", "replacementComments": "/**\n* Treat the specified array of colors as a bitmap, and draw it. This gives the same result as\n* first creating a bitmap from the array, and then drawing it, but this method avoids\n* explicitly creating a bitmap object which can be more efficient if the colors are changing\n* often.\n*\n* @param colors Array of colors representing the pixels of the bitmap\n* @param offset Offset into the array of colors for the first pixel\n* @param stride The number of colors in the array between rows (must be >= width or <= -width).\n* @param x The X coordinate for where to draw the bitmap\n* @param y The Y coordinate for where to draw the bitmap\n* @param width The width of the bitmap\n* @param height The height of the bitmap\n* @param hasAlpha True if the alpha channel of the colors contains valid values. If false, the\n* alpha byte is ignored (assumed to be 0xFF for every pixel).\n* @param paint May be null. The paint used to draw the bitmap\n* @deprecated Usage with a {@link #isHardwareAccelerated() hardware accelerated} canvas\n* requires an internal copy of color buffer contents every time this method is\n* called. Using a Bitmap avoids this copy, and allows the application to more\n* explicitly control the lifetime and copies of pixel data.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "isHardwareAccelerated() hardware accelerated", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void drawBitmap(int[],int,int,float,float,int,int,boolean,Paint)", "method": "drawBitmap(int[],int,int,float,float,int,int,boolean,Paint)"}, "getWallpaperDesiredMinimumHeight": {"methodClass": "android.content.Context", "methodName": "getWallpaperDesiredMinimumHeight", "replacementComments": "/**\n* @deprecated Use {@link android.app.WallpaperManager#getDesiredMinimumHeight()\n* WallpaperManager.getDesiredMinimumHeight()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "android.app.WallpaperManager#getDesiredMinimumHeight()  WallpaperManager.getDesiredMinimumHeight()", "methodReturn": "int", "isValid": true, "cleanReplacement": "getDesiredMinimumHeight()  WallpaperManager.getDesiredMinimumHeight()", "fullMethod": "int getWallpaperDesiredMinimumHeight()", "method": "getWallpaperDesiredMinimumHeight()"}, "loadNanoApp": {"methodClass": "android.hardware.location.ContextHubManager", "methodName": "loadNanoApp", "replacementComments": "/**\n* Load a nano app on a specified context hub.\n*\n* Note that loading is asynchronous.  When we return from this method,\n* the nano app (probably) hasn't loaded yet.  Assuming a return of 0\n* from this method, then the final success/failure for the load, along\n* with the \"handle\" for the nanoapp, is all delivered in a byte\n* string via a call to Callback.onMessageReceipt.\n*\n* TODO(b/30784270): Provide a better success/failure and \"handle\" delivery.\n*\n* @param hubHandle handle of context hub to load the app on.\n* @param app the nanoApp to load on the hub\n*\n* @return 0 if the command for loading was sent to the context hub;\n* -1 otherwise\n*\n* @see NanoApp\n*\n* @deprecated Use {@link #loadNanoApp(ContextHubInfo, NanoAppBinary)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "loadNanoApp(ContextHubInfo, NanoAppBinary)", "methodReturn": "int", "isValid": true, "cleanReplacement": "loadNanoApp(ContextHubInfo, NanoAppBinary)", "fullMethod": "int loadNanoApp(int,NanoApp)", "method": "loadNanoApp(int,NanoApp)"}, "writeFixed32": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writeFixed32", "replacementComments": "/**\n* Write a single proto \"fixed32\" type field value.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writeFixed32(long,int)", "method": "writeFixed32(long,int)"}, "getChildPosition": {"methodClass": "com.android.internal.widget.RecyclerView", "methodName": "getChildPosition", "replacementComments": "/**\n* @deprecated use {@link #getChildAdapterPosition(View)} or\n* {@link #getChildLayoutPosition(View)}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getChildAdapterPosition(View)", "methodReturn": "int", "isValid": true, "cleanReplacement": "getChildAdapterPosition(View)", "fullMethod": "int getChildPosition(View)", "method": "getChildPosition(View)"}, "clearDeviceOwnerApp": {"methodClass": "android.app.admin.DevicePolicyManager", "methodName": "clearDeviceOwnerApp", "replacementComments": "/**\n* Clears the current device owner. The caller must be the device owner. This function should be\n* used cautiously as once it is called it cannot be undone. The device owner can only be set as\n* a part of device setup, before it completes.\n* <p>\n* While some policies previously set by the device owner will be cleared by this method, it is\n* a best-effort process and some other policies will still remain in place after the device\n* owner is cleared.\n*\n* @param packageName The package name of the device owner.\n* @throws SecurityException if the caller is not in {@code packageName} or {@code packageName}\n* does not own the current device owner component.\n*\n* @deprecated This method is expected to be used for testing purposes only. The device owner\n* will lose control of the device and its data after calling it. In order to protect any\n* sensitive data that remains on the device, it is advised that the device owner factory resets\n* the device instead of calling this method. See {@link #wipeData(int)}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "wipeData(int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "wipeData(int)", "fullMethod": "void clearDeviceOwnerApp(String)", "method": "clearDeviceOwnerApp(String)"}, "writeRepeatedSInt64": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writeRepeatedSInt64", "replacementComments": "/**\n* Write a single repeated proto \"sint64\" type field value.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writeRepeatedSInt64(long,long)", "method": "writeRepeatedSInt64(long,long)"}, "getSeparator": {"methodClass": "androidx.leanback.widget.picker.Picker", "methodName": "getSeparator", "replacementComments": "/**\n* Gets separator string between columns.\n*\n* @return The separator that will be populated between all the Picker columns.\n* @deprecated Use {@link #getSeparators()}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getSeparators()", "methodReturn": "CharSequence", "isValid": true, "cleanReplacement": "getSeparators()", "fullMethod": "CharSequence getSeparator()", "method": "getSeparator()"}, "tune": {"methodClass": "android.hardware.radio.RadioTuner", "methodName": "tune", "replacementComments": "/**\n* Tune to a specific frequency.\n* The operation is asynchronous and {@link Callback}\n* onProgramInfoChanged() will be called when tune completes or\n* onError() when cancelled or timeout.\n* @param channel the specific channel or frequency to tune to.\n* @param subChannel the specific sub-channel to tune to. N/A if the selected configuration\n* does not support cub channels.\n* @return\n* <ul>\n* <li>{@link RadioManager#STATUS_OK} in case of success, </li>\n* <li>{@link RadioManager#STATUS_ERROR} in case of unspecified error, </li>\n* <li>{@link RadioManager#STATUS_NO_INIT} if the native service cannot be reached, </li>\n* <li>{@link RadioManager#STATUS_BAD_VALUE} if parameters are invalid, </li>\n* <li>{@link RadioManager#STATUS_INVALID_OPERATION} if the call is out of sequence, </li>\n* <li>{@link RadioManager#STATUS_DEAD_OBJECT} if the binder transaction to the native\n* service fails, </li>\n* </ul>\n* @deprecated Use {@link tune(ProgramSelector)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "tune(ProgramSelector)", "methodReturn": "int", "isValid": true, "cleanReplacement": "tune(ProgramSelector)", "fullMethod": "int tune(int,int)", "method": "tune(int,int)"}, "copyFile": {"methodClass": "android.os.FileUtils", "methodName": "copyFile", "replacementComments": "/**\n* @deprecated use {@link #copy(File, File)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "copy(File, File)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "copy(File, File)", "fullMethod": "boolean copyFile(File,File)", "method": "copyFile(File,File)"}, "setSaveFromParentEnabled": {"methodClass": "androidx.core.view.ViewCompat", "methodName": "setSaveFromParentEnabled", "replacementComments": "/**\n* Controls whether the entire hierarchy under this view will save its\n* state when a state saving traversal occurs from its parent.\n*\n* @param enabled Set to false to <em>disable</em> state saving, or true\n* (the default) to allow it.\n*\n* @deprecated Use {@link View#setSaveFromParentEnabled(boolean)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "View#setSaveFromParentEnabled(boolean)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setSaveFromParentEnabled(boolean)", "fullMethod": "void setSaveFromParentEnabled(View,boolean)", "method": "setSaveFromParentEnabled(View,boolean)"}, "setMinutes": {"methodClass": "java.sql.Date", "methodName": "setMinutes", "replacementComments": "/**\n* @deprecated This method is deprecated and should not be used because SQL Date\n* values do not have a time component.\n*\n* @exception java.lang.IllegalArgumentException if this method is invoked\n* @see #getMinutes\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getMinutes", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void setMinutes(int)", "method": "setMinutes(int)"}, "writeSInt64": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writeSInt64", "replacementComments": "/**\n* Write a single proto \"sint64\" type field value.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writeSInt64(long,long)", "method": "writeSInt64(long,long)"}, "onSendMultipartTextSms": {"methodClass": "android.service.carrier.CarrierMessagingService", "methodName": "onSendMultipartTextSms", "replacementComments": "/**\n* Override this method to intercept long SMSs sent from the device.\n* @deprecated Override {@link #onSendMultipartTextSms} below instead.\n*\n* @param parts a {@link List} of the message parts\n* @param subId SMS subscription ID of the SIM\n* @param destAddress phone number of the recipient of the message\n* @param callback result callback. Call with a {@link SendMultipartSmsResult}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "onSendMultipartTextSms", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void onSendMultipartTextSms(List<String>,int,String,ResultCallback<SendMultipartSmsResult>)", "method": "onSendMultipartTextSms(List<String>,int,String,ResultCallback<SendMultipartSmsResult>)"}, "isBlob": {"methodClass": "android.database.AbstractWindowedCursor", "methodName": "isBlob", "replacementComments": "/**\n* @deprecated Use {@link #getType}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getType", "methodReturn": "boolean", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "boolean isBlob(int)", "method": "isBlob(int)"}, "setActionView": {"methodClass": "androidx.core.view.MenuItemCompat", "methodName": "setActionView", "replacementComments": "/**\n* Set an action view for this menu item. An action view will be displayed in place\n* of an automatically generated menu item element in the UI when this item is shown\n* as an action within a parent.\n* <p>\n* <strong>Note:</strong> Setting an action view overrides the action provider\n* set via {@link #setActionProvider(MenuItem, ActionProvider)}.\n* </p>\n*\n* @param item the item to change\n* @param resId Layout resource to use for presenting this item to the user.\n* @return This Item so additional setters can be called.\n*\n* @see #setShowAsAction(MenuItem, int)\n*\n* @deprecated Use {@link MenuItem#setActionView(int)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "MenuItem#setActionView(int)", "methodReturn": "MenuItem", "isValid": true, "cleanReplacement": "setActionView(int)", "fullMethod": "MenuItem setActionView(MenuItem,int)", "method": "setActionView(MenuItem,int)"}, "getValidNotBefore": {"methodClass": "android.net.http.SslCertificate", "methodName": "getValidNotBefore", "replacementComments": "/**\n* @return Not-before date from the certificate validity period in\n* ISO 8601 format or \"\" if none has been set\n*\n* @deprecated Use {@link #getValidNotBeforeDate()}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getValidNotBeforeDate()", "methodReturn": "String", "isValid": true, "cleanReplacement": "getValidNotBeforeDate()", "fullMethod": "String getValidNotBefore()", "method": "getValidNotBefore()"}, "setFactory": {"methodClass": "androidx.core.view.LayoutInflaterCompat", "methodName": "setFactory", "replacementComments": "/**\n* Attach a custom Factory interface for creating views while using\n* this LayoutInflater. This must not be null, and can only be set once;\n* after setting, you can not change the factory.\n*\n* @see LayoutInflater#setFactory(android.view.LayoutInflater.Factory)\n*\n* @deprecated Use {@link #setFactory2(LayoutInflater, LayoutInflater.Factory2)} instead to set\n* and {@link LayoutInflater#getFactory2()} to get the factory.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setFactory2(LayoutInflater, LayoutInflater.Factory2)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setFactory2(LayoutInflater, LayoutInflater.Factory2)", "fullMethod": "void setFactory(LayoutInflater,LayoutInflaterFactory)", "method": "setFactory(LayoutInflater,LayoutInflaterFactory)"}, "setOnActionExpandListener": {"methodClass": "androidx.core.view.MenuItemCompat", "methodName": "setOnActionExpandListener", "replacementComments": "/**\n* Set an {@link OnActionExpandListener} on this menu\n* item to be notified when the associated action view is expanded or collapsed.\n* The menu item must be configured to expand or collapse its action view using the flag\n* {@link #SHOW_AS_ACTION_COLLAPSE_ACTION_VIEW}.\n*\n* @param listener Listener that will respond to expand/collapse events\n* @return This menu item instance for call chaining\n*\n* @deprecated Use {@link MenuItem#setOnActionExpandListener(MenuItem.OnActionExpandListener)}\n* directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "MenuItem#setOnActionExpandListener(MenuItem.OnActionExpandListener)", "methodReturn": "MenuItem", "isValid": true, "cleanReplacement": "setOnActionExpandListener(MenuItem.OnActionExpandListener)", "fullMethod": "MenuItem setOnActionExpandListener(MenuItem,OnActionExpandListener)", "method": "setOnActionExpandListener(MenuItem,OnActionExpandListener)"}, "setChildrenDrawnWithCacheEnabled": {"methodClass": "android.view.ViewGroup", "methodName": "setChildrenDrawnWithCacheEnabled", "replacementComments": "/**\n* Tells the ViewGroup to draw its children using their drawing cache. This property\n* is ignored when {@link #isAlwaysDrawnWithCacheEnabled()} is true. A child's drawing cache\n* will be used only if it has been enabled.\n*\n* Subclasses should call this method to start and stop using the drawing cache when\n* they perform performance sensitive operations, like scrolling or animating.\n*\n* @param enabled true if children should be drawn with their cache, false otherwise\n*\n* @see #setAlwaysDrawnWithCacheEnabled(boolean)\n* @see #isChildrenDrawnWithCacheEnabled()\n*\n* @deprecated As of {@link android.os.Build.VERSION_CODES#M}, this property is ignored.\n* Child views may no longer be forced to cache their rendering state by their parents.\n* Use {@link View#setLayerType(int, Paint)} on individual Views instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "View#setLayerType(int, Paint)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setLayerType(int, Paint)", "fullMethod": "void setChildrenDrawnWithCacheEnabled(boolean)", "method": "setChildrenDrawnWithCacheEnabled(boolean)"}, "getPointerCount": {"methodClass": "androidx.core.view.MotionEventCompat", "methodName": "getPointerCount", "replacementComments": "/**\n* The number of pointers of data contained in this event.  Always\n*\n* @deprecated Call {@link MotionEvent#getPointerCount()} directly. This method will be\n* removed in a future release.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "MotionEvent#getPointerCount()", "methodReturn": "int", "isValid": true, "cleanReplacement": "getPointerCount()", "fullMethod": "int getPointerCount(MotionEvent)", "method": "getPointerCount(MotionEvent)"}, "setBufferedProgressLong": {"methodClass": "androidx.leanback.widget.PlaybackControlsRow", "methodName": "setBufferedProgressLong", "replacementComments": "/**\n* Sets the buffered progress for the playback controls row.\n* @param ms Buffered progress in milliseconds of long type.\n* @deprecated Use {@link #setBufferedPosition(long)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setBufferedPosition(long)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setBufferedPosition(long)", "fullMethod": "void setBufferedProgressLong(long)", "method": "setBufferedProgressLong(long)"}, "getUidUdpTxBytes": {"methodClass": "android.net.TrafficStats", "methodName": "getUidUdpTxBytes", "replacementComments": "/**\n* @deprecated Starting in {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2},\n* transport layer statistics are no longer available, and will\n* always return {@link #UNSUPPORTED}.\n* @see #getUidTxBytes(int)\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getUidTxBytes(int)", "methodReturn": "long", "isValid": true, "cleanReplacement": "getUidTxBytes(int)", "fullMethod": "long getUidUdpTxBytes(int)", "method": "getUidUdpTxBytes(int)"}, "onEditingModeChange": {"methodClass": "androidx.leanback.widget.GuidedActionsStylist", "methodName": "onEditingModeChange", "replacementComments": "/**\n* @deprecated Use {@link #onEditingModeChange(ViewHolder, boolean, boolean)}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "onEditingModeChange(ViewHolder, boolean, boolean)", "methodReturn": "void", "isValid": true, "cleanReplacement": "onEditingModeChange(ViewHolder, boolean, boolean)", "fullMethod": "void onEditingModeChange(ViewHolder,GuidedAction,boolean)", "method": "onEditingModeChange(ViewHolder,GuidedAction,boolean)"}, "obtain": {"methodClass": "android.view.MotionEvent", "methodName": "obtain", "replacementComments": "/**\n* Create a new MotionEvent, filling in all of the basic values that\n* define the motion.\n*\n* @param downTime The time (in ms) when the user originally pressed down to start\n* a stream of position events.  This must be obtained from {@link SystemClock#uptimeMillis()}.\n* @param eventTime  The the time (in ms) when this specific event was generated.  This\n* must be obtained from {@link SystemClock#uptimeMillis()}.\n* @param action The kind of action being performed, such as {@link #ACTION_DOWN}.\n* @param pointerCount The number of pointers that are active in this event.\n* @param x The X coordinate of this event.\n* @param y The Y coordinate of this event.\n* @param pressure The current pressure of this event.  The pressure generally\n* ranges from 0 (no pressure at all) to 1 (normal pressure), however\n* values higher than 1 may be generated depending on the calibration of\n* the input device.\n* @param size A scaled value of the approximate size of the area being pressed when\n* touched with the finger. The actual value in pixels corresponding to the finger\n* touch is normalized with a device specific range of values\n* and scaled to a value between 0 and 1.\n* @param metaState The state of any meta / modifier keys that were in effect when\n* the event was generated.\n* @param xPrecision The precision of the X coordinate being reported.\n* @param yPrecision The precision of the Y coordinate being reported.\n* @param deviceId The id for the device that this event came from.  An id of\n* zero indicates that the event didn't come from a physical device; other\n* numbers are arbitrary and you shouldn't depend on the values.\n* @param edgeFlags A bitfield indicating which edges, if any, were touched by this\n* MotionEvent.\n*\n* @deprecated Use {@link #obtain(long, long, int, float, float, float, float, int, float, float, int, int)}\n* instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "obtain(long, long, int, float, float, float, float, int, float, float, int, int)", "methodReturn": "MotionEvent", "isValid": true, "cleanReplacement": "obtain(long, long, int, float, float, float, float, int, float, float, int, int)", "fullMethod": "MotionEvent obtain(long,long,int,int,float,float,float,float,int,float,float,int,int)", "method": "obtain(long,long,int,int,float,float,float,float,int,float,float,int,int)"}, "isVtProvisionedOnDevice": {"methodClass": "com.android.ims.ImsManager", "methodName": "isVtProvisionedOnDevice", "replacementComments": "/**\n* Indicates whether VT is provisioned on device\n*\n* @deprecated Does not support MSIM devices. Please use\n* {@link #isVtProvisionedOnDevice()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "isVtProvisionedOnDevice()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "isVtProvisionedOnDevice()", "fullMethod": "boolean isVtProvisionedOnDevice(Context)", "method": "isVtProvisionedOnDevice(Context)"}, "setShowRunningNotification": {"methodClass": "android.app.DownloadManager.Request", "methodName": "setShowRunningNotification", "replacementComments": "/**\n* Control whether a system notification is posted by the download manager while this\n* download is running. If enabled, the download manager posts notifications about downloads\n* through the system {@link android.app.NotificationManager}. By default, a notification is\n* shown.\n*\n* If set to false, this requires the permission\n* android.permission.DOWNLOAD_WITHOUT_NOTIFICATION.\n*\n* @param show whether the download manager should show a notification for this download.\n* @return this object\n* @deprecated use {@link #setNotificationVisibility(int)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setNotificationVisibility(int)", "methodReturn": "Request", "isValid": true, "cleanReplacement": "setNotificationVisibility(int)", "fullMethod": "Request setShowRunningNotification(boolean)", "method": "setShowRunningNotification(boolean)"}, "setConnecting": {"methodClass": "androidx.mediarouter.media.MediaRouteDescriptor.Builder", "methodName": "setConnecting", "replacementComments": "/**\n* Sets whether the route is in the process of connecting and is not yet\n* ready for use.\n* @deprecated Use {@link #setConnectionState} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setConnectionState", "methodReturn": "Builder", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "Builder setConnecting(boolean)", "method": "setConnecting(boolean)"}, "setProcessDefaultNetwork": {"methodClass": "android.net.ConnectivityManager", "methodName": "setProcessDefaultNetwork", "replacementComments": "/**\n* Binds the current process to {@code network}.  All Sockets created in the future\n* (and not explicitly bound via a bound SocketFactory from\n* {@link Network#getSocketFactory() Network.getSocketFactory()}) will be bound to\n* {@code network}.  All host name resolutions will be limited to {@code network} as well.\n* Note that if {@code network} ever disconnects, all Sockets created in this way will cease to\n* work and all host name resolutions will fail.  This is by design so an application doesn't\n* accidentally use Sockets it thinks are still bound to a particular {@link Network}.\n* To clear binding pass {@code null} for {@code network}.  Using individually bound\n* Sockets created by Network.getSocketFactory().createSocket() and\n* performing network-specific host name resolutions via\n* {@link Network#getAllByName Network.getAllByName} is preferred to calling\n* {@code setProcessDefaultNetwork}.\n*\n* @param network The {@link Network} to bind the current process to, or {@code null} to clear\n* the current binding.\n* @return {@code true} on success, {@code false} if the {@link Network} is no longer valid.\n* @deprecated This function can throw {@link IllegalStateException}.  Use\n* {@link #bindProcessToNetwork} instead.  {@code bindProcessToNetwork}\n* is a direct replacement.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "IllegalStateException", "methodReturn": "boolean", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "boolean setProcessDefaultNetwork(Network)", "method": "setProcessDefaultNetwork(Network)"}, "getMaxScrollX": {"methodClass": "androidx.core.view.accessibility.AccessibilityRecordCompat", "methodName": "getMaxScrollX", "replacementComments": "/**\n* Gets the max scroll offset of the source left edge in pixels.\n*\n* @return The max scroll.\n*\n* @deprecated Use {@link #getMaxScrollX(AccessibilityRecord)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getMaxScrollX(AccessibilityRecord)", "methodReturn": "int", "isValid": true, "cleanReplacement": "getMaxScrollX(AccessibilityRecord)", "fullMethod": "int getMaxScrollX()", "method": "getMaxScrollX()"}, "getMaxScrollY": {"methodClass": "androidx.core.view.accessibility.AccessibilityRecordCompat", "methodName": "getMaxScrollY", "replacementComments": "/**\n* Gets the max scroll offset of the source top edge in pixels.\n*\n* @return The max scroll.\n*\n* @deprecated Use {@link #getMaxScrollY(AccessibilityRecord)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getMaxScrollY(AccessibilityRecord)", "methodReturn": "int", "isValid": true, "cleanReplacement": "getMaxScrollY(AccessibilityRecord)", "fullMethod": "int getMaxScrollY()", "method": "getMaxScrollY()"}, "commaEllipsize": {"methodClass": "android.text.TextUtils", "methodName": "commaEllipsize", "replacementComments": "/**\n* Converts a CharSequence of the comma-separated form \"Andy, Bob,\n* Charles, David\" that is too wide to fit into the specified width\n* into one like \"Andy, Bob, 2 more\".\n*\n* @param text the text to truncate\n* @param p the Paint with which to measure the text\n* @param avail the horizontal width available for the text (in pixels)\n* @param oneMore the string for \"1 more\" in the current locale\n* @param more the string for \"%d more\" in the current locale\n*\n* @deprecated Do not use. This is not internationalized, and has known issues\n* with right-to-left text, languages that have more than one plural form, languages\n* that use a different character as a comma-like separator, etc.\n* Use {@link #listEllipsize} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "listEllipsize", "methodReturn": "CharSequence", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "CharSequence commaEllipsize(CharSequence,TextPaint,float,String,String)", "method": "commaEllipsize(CharSequence,TextPaint,float,String,String)"}, "setThreadStatsTag": {"methodClass": "androidx.core.net.TrafficStatsCompat", "methodName": "setThreadStatsTag", "replacementComments": "/**\n* Set active tag to use when accounting {@link Socket} traffic originating\n* from the current thread. Only one active tag per thread is supported.\n* <p>\n* Changes only take effect during subsequent calls to\n* {@link #tagSocket(Socket)}.\n* <p>\n* Tags between {@code 0xFFFFFF00} and {@code 0xFFFFFFFF} are reserved and\n* used internally by system services like DownloadManager when performing\n* traffic on behalf of an application.\n*\n* @deprecated Use {@link TrafficStats#setThreadStatsTag(int)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "TrafficStats#setThreadStatsTag(int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "TrafficStats#setThreadStatsTag(int)", "fullMethod": "void setThreadStatsTag(int)", "method": "setThreadStatsTag(int)"}, "setRssi": {"methodClass": "android.telephony.NeighboringCellInfo", "methodName": "setRssi", "replacementComments": "/**\n* Set the signal strength of the cell.\n*\n* NeighboringCellInfo is a one time shot for the neighboring cells based on\n* the radio network type at that moment. It shouldn't be changed after\n* creation.\n*\n* @deprecated initial rssi value passed as parameter to constructor\n* {@link #NeighboringCellInfo(int, String, int)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "NeighboringCellInfo(int, String, int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "NeighboringCellInfo(int, String, int)", "fullMethod": "void setRssi(int)", "method": "setRssi(int)"}, "removeGlobalOnLayoutListener": {"methodClass": "android.view.ViewTreeObserver", "methodName": "removeGlobalOnLayoutListener", "replacementComments": "/**\n* Remove a previously installed global layout callback\n*\n* @param victim The callback to remove\n*\n* @throws IllegalStateException If {@link #isAlive()} returns false\n*\n* @deprecated Use #removeOnGlobalLayoutListener instead\n*\n* @see #addOnGlobalLayoutListener(OnGlobalLayoutListener)\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "removeOnGlobalLayoutListener", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void removeGlobalOnLayoutListener(OnGlobalLayoutListener)", "method": "removeGlobalOnLayoutListener(OnGlobalLayoutListener)"}, "onNestedScroll": {"methodClass": "androidx.coordinatorlayout.widget.CoordinatorLayout.Behavior", "methodName": "onNestedScroll", "replacementComments": "/**\n* @deprecated You should now override\n* {@link #onNestedScroll(CoordinatorLayout, View, View, int, int, int, int, int)}.\n* This method will still continue to be called if the type is\n* {@link ViewCompat#TYPE_TOUCH}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "onNestedScroll(CoordinatorLayout, View, View, int, int, int, int, int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "onNestedScroll(CoordinatorLayout, View, View, int, int, int, int, int)", "fullMethod": "void onNestedScroll(CoordinatorLayout,V,View,int,int,int,int)", "method": "onNestedScroll(CoordinatorLayout,V,View,int,int,int,int)"}, "setPivotY": {"methodClass": "androidx.core.view.ViewCompat", "methodName": "setPivotY", "replacementComments": "/**\n* Sets the y location of the point around which the view is\n* {@link #setRotation(View, float) rotated} and {@link #setScaleY(View, float) scaled}.\n* By default, the pivot point is centered on the object.\n* Setting this property disables this behavior and causes the view to use only the\n* explicitly set pivotX and pivotY values.\n*\n* @param value The y location of the pivot point.\n*\n* @deprecated Use {@link View#setPivotX(float)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "View#setPivotX(float)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setPivotX(float)", "fullMethod": "void setPivotY(View,float)", "method": "setPivotY(View,float)"}, "getSuggestions": {"methodClass": "android.view.textservice.SpellCheckerSession", "methodName": "getSuggestions", "replacementComments": "/**\n* Get candidate strings for a substring of the specified text.\n* @param textInfo text metadata for a spell checker\n* @param suggestionsLimit the maximum number of suggestions that will be returned\n* @deprecated use {@link SpellCheckerSession#getSentenceSuggestions(TextInfo[], int)} instead\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "SpellCheckerSession#getSentenceSuggestions(TextInfo[], int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "getSentenceSuggestions(TextInfo[], int)", "fullMethod": "void getSuggestions(TextInfo,int)", "method": "getSuggestions(TextInfo,int)"}, "isWiredHeadsetOn": {"methodClass": "android.media.AudioManager", "methodName": "isWiredHeadsetOn", "replacementComments": "/**\n* Checks whether a wired headset is connected or not.\n* <p>This is not a valid indication that audio playback is\n* actually over the wired headset as audio routing depends on other conditions.\n*\n* @return true if a wired headset is connected.\n* false if otherwise\n* @deprecated Use {@link AudioManager#getDevices(int)} instead to list available audio devices.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AudioManager#getDevices(int)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "getDevices(int)", "fullMethod": "boolean isWiredHeadsetOn()", "method": "isWiredHeadsetOn()"}, "onStartNestedScroll": {"methodClass": "androidx.coordinatorlayout.widget.CoordinatorLayout.Behavior", "methodName": "onStartNestedScroll", "replacementComments": "/**\n* @deprecated You should now override\n* {@link #onStartNestedScroll(CoordinatorLayout, View, View, View, int, int)}. This\n* method will still continue to be called if the type is {@link ViewCompat#TYPE_TOUCH}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "onStartNestedScroll(CoordinatorLayout, View, View, View, int, int)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "onStartNestedScroll(CoordinatorLayout, View, View, View, int, int)", "fullMethod": "boolean onStartNestedScroll(CoordinatorLayout,V,View,View,int)", "method": "onStartNestedScroll(CoordinatorLayout,V,View,View,int)"}, "setRemoteAdapter": {"methodClass": "android.widget.RemoteViews", "methodName": "setRemoteAdapter", "replacementComments": "/**\n* Equivalent to calling {@link android.widget.AbsListView#setRemoteViewsAdapter(Intent)}.\n*\n* @param appWidgetId The id of the app widget which contains the specified view. (This\n* parameter is ignored in this deprecated method)\n* @param viewId The id of the {@link AdapterView}\n* @param intent The intent of the service which will be\n* providing data to the RemoteViewsAdapter\n* @deprecated This method has been deprecated. See\n* {@link android.widget.RemoteViews#setRemoteAdapter(int, Intent)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "android.widget.RemoteViews#setRemoteAdapter(int, Intent)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setRemoteAdapter(int, Intent)", "fullMethod": "void setRemoteAdapter(int,int,Intent)", "method": "setRemoteAdapter(int,int,Intent)"}, "writePackedInt64": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writePackedInt64", "replacementComments": "/**\n* Write a list of packed proto \"int64\" type field value.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writePackedInt64(long,long[])", "method": "writePackedInt64(long,long[])"}, "registerRemoteControlClient": {"methodClass": "android.media.AudioManager", "methodName": "registerRemoteControlClient", "replacementComments": "/**\n* Registers the remote control client for providing information to display on the remote\n* controls.\n* @param rcClient The remote control client from which remote controls will receive\n* information to display.\n* @see RemoteControlClient\n* @deprecated Use {@link MediaSession} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "MediaSession", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void registerRemoteControlClient(RemoteControlClient)", "method": "registerRemoteControlClient(RemoteControlClient)"}, "setShadowDrawable": {"methodClass": "androidx.slidingpanelayout.widget.SlidingPaneLayout", "methodName": "setShadowDrawable", "replacementComments": "/**\n* @deprecated Renamed to {@link #setShadowDrawableLeft(Drawable d)} to support LTR (left to\n* right language) and {@link #setShadowDrawableRight(Drawable d)} to support RTL (right to left\n* language) during opening/closing.\n*\n* @param d drawable to use as a shadow\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setShadowDrawableLeft(Drawable d)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setShadowDrawableLeft(Drawable d)", "fullMethod": "void setShadowDrawable(Drawable)", "method": "setShadowDrawable(Drawable)"}, "writeBool": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writeBool", "replacementComments": "/**\n* Write a single proto \"bool\" type field value.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writeBool(long,boolean)", "method": "writeBool(long,boolean)"}, "getValidNotAfter": {"methodClass": "android.net.http.SslCertificate", "methodName": "getValidNotAfter", "replacementComments": "/**\n* @return Not-after date from the certificate validity period in\n* ISO 8601 format or \"\" if none has been set\n*\n* @deprecated Use {@link #getValidNotAfterDate()}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getValidNotAfterDate()", "methodReturn": "String", "isValid": true, "cleanReplacement": "getValidNotAfterDate()", "fullMethod": "String getValidNotAfter()", "method": "getValidNotAfter()"}, "getCodecCount": {"methodClass": "android.media.MediaCodecList", "methodName": "getCodecCount", "replacementComments": "/**\n* Count the number of available (regular) codecs.\n*\n* @deprecated Use {@link #getCodecInfos} instead.\n*\n* @see #REGULAR_CODECS\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getCodecInfos", "methodReturn": "int", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "int getCodecCount()", "method": "getCodecCount()"}, "addPerson": {"methodClass": "android.app.Notification.Builder", "methodName": "addPerson", "replacementComments": "/**\n* Add a person that is relevant to this notification.\n*\n* <P>\n* Depending on user preferences, this annotation may allow the notification to pass\n* through interruption filters, if this notification is of category {@link #CATEGORY_CALL}\n* or {@link #CATEGORY_MESSAGE}. The addition of people may also cause this notification to\n* appear more prominently in the user interface.\n* </P>\n*\n* <P>\n* The person should be specified by the {@code String} representation of a\n* {@link android.provider.ContactsContract.Contacts#CONTENT_LOOKUP_URI}.\n* </P>\n*\n* <P>The system will also attempt to resolve {@code mailto:} and {@code tel:} schema\n* URIs.  The path part of these URIs must exist in the contacts database, in the\n* appropriate column, or the reference will be discarded as invalid. Telephone schema\n* URIs will be resolved by {@link android.provider.ContactsContract.PhoneLookup}.\n* It is also possible to provide a URI with the schema {@code name:} in order to uniquely\n* identify a person without an entry in the contacts database.\n* </P>\n*\n* @param uri A URI for the person.\n* @see Notification#EXTRA_PEOPLE\n* @deprecated use {@link #addPerson(Person)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "addPerson(Person)", "methodReturn": "Builder", "isValid": true, "cleanReplacement": "addPerson(Person)", "fullMethod": "Builder addPerson(String)", "method": "addPerson(String)"}, "abortAnimation": {"methodClass": "androidx.core.widget.ScrollerCompat", "methodName": "abortAnimation", "replacementComments": "/**\n* Stops the animation. Aborting the animation causes the scroller to move to the final x and y\n* position.\n*\n* @deprecated Use {@link OverScroller#abortAnimation()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "OverScroller#abortAnimation()", "methodReturn": "void", "isValid": true, "cleanReplacement": "OverScroller#abortAnimation()", "fullMethod": "void abortAnimation()", "method": "abortAnimation()"}, "setChecked": {"methodClass": "androidx.core.view.accessibility.AccessibilityRecordCompat", "methodName": "setChecked", "replacementComments": "/**\n* Sets if the source is checked.\n*\n* @param isChecked True if the view is checked, false otherwise.\n*\n* @throws IllegalStateException If called from an AccessibilityService.\n*\n* @deprecated Use {@link AccessibilityRecord#setChecked(boolean)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityRecord#setChecked(boolean)", "methodReturn": "void", "isValid": true, "cleanReplacement": "AccessibilityRecord#setChecked(boolean)", "fullMethod": "void setChecked(boolean)", "method": "setChecked(boolean)"}, "onStartedWakingUp": {"methodClass": "com.android.keyguard.KeyguardUpdateMonitorCallback", "methodName": "onStartedWakingUp", "replacementComments": "/**\n* Called when the device has started waking up.\n*\n* @deprecated use {@link com.android.systemui.keyguard.WakefulnessLifecycle}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "com.android.systemui.keyguard.WakefulnessLifecycle", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void onStartedWakingUp()", "method": "onStartedWakingUp()"}, "setIcon": {"methodClass": "android.view.textclassifier.TextClassification.Builder", "methodName": "setIcon", "replacementComments": "/**\n* Sets the icon for the <i>primary</i> action that may be rendered on a widget used to act\n* on the classified text.\n*\n* <p><strong>NOTE: </strong>This field is not parcelled. If read from a parcel, the\n* returned icon represents the icon of the first {@link RemoteAction} (if one exists).\n*\n* @deprecated Use {@link #addAction(RemoteAction)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "addAction(RemoteAction)", "methodReturn": "Builder", "isValid": true, "cleanReplacement": "addAction(RemoteAction)", "fullMethod": "Builder setIcon(Drawable)", "method": "setIcon(Drawable)"}, "setHours": {"methodClass": "java.sql.Date", "methodName": "setHours", "replacementComments": "/**\n* @deprecated This method is deprecated and should not be used because SQL Date\n* values do not have a time component.\n*\n* @exception java.lang.IllegalArgumentException if this method is invoked\n* @see #getHours\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getHours", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void setHours(int)", "method": "setHours(int)"}, "setShowAsAction": {"methodClass": "androidx.core.view.MenuCompat", "methodName": "setShowAsAction", "replacementComments": "/**\n* Call {@link MenuItem#setShowAsAction(int) MenuItem.setShowAsAction()}.\n*\n* @deprecated Use {@link MenuItem#setShowAsAction(int)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "MenuItem#setShowAsAction(int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setShowAsAction(int)", "fullMethod": "void setShowAsAction(MenuItem,int)", "method": "setShowAsAction(MenuItem,int)"}, "isScrollable": {"methodClass": "androidx.core.view.accessibility.AccessibilityRecordCompat", "methodName": "isScrollable", "replacementComments": "/**\n* Gets if the source is scrollable.\n*\n* @return True if the source is scrollable, false otherwise.\n*\n* @deprecated Use {@link AccessibilityRecord#isScrollable()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityRecord#isScrollable()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "AccessibilityRecord#isScrollable()", "fullMethod": "boolean isScrollable()", "method": "isScrollable()"}, "getApplicationIndex": {"methodClass": "com.android.internal.telephony.uicc.UiccCard", "methodName": "getApplicationIndex", "replacementComments": "/**\n* @deprecated Please use {@link UiccProfile#getApplicationIndex(int)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "UiccProfile#getApplicationIndex(int)", "methodReturn": "UiccCardApplication", "isValid": true, "cleanReplacement": "UiccProfile#getApplicationIndex(int)", "fullMethod": "UiccCardApplication getApplicationIndex(int)", "method": "getApplicationIndex(int)"}, "fadeOut": {"methodClass": "androidx.leanback.media.PlaybackGlueHost", "methodName": "fadeOut", "replacementComments": "/**\n* Fades out the playback overlay immediately.\n* @deprecated Call {@link #hideControlsOverlay(boolean)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "hideControlsOverlay(boolean)", "methodReturn": "void", "isValid": true, "cleanReplacement": "hideControlsOverlay(boolean)", "fullMethod": "void fadeOut()", "method": "fadeOut()"}, "getLoaderManager": {"methodClass": "androidx.fragment.app.Fragment", "methodName": "getLoaderManager", "replacementComments": "/**\n* Return the LoaderManager for this fragment.\n*\n* @deprecated Use\n* {@link LoaderManager#getInstance(LifecycleOwner) LoaderManager.getInstance(this)}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "LoaderManager#getInstance(LifecycleOwner) LoaderManager.getInstance(this)", "methodReturn": "LoaderManager", "isValid": true, "cleanReplacement": "getInstance(LifecycleOwner) LoaderManager.getInstance(this)", "fullMethod": "LoaderManager getLoaderManager()", "method": "getLoaderManager()"}, "addEarcon": {"methodClass": "android.speech.tts.TextToSpeech", "methodName": "addEarcon", "replacementComments": "/**\n* Adds a mapping between a string of text and a sound file.\n* Use this to add custom earcons.\n*\n* @see #playEarcon(String, int, HashMap)\n*\n* @param earcon\n* The name of the earcon.\n* Example: <code>\"[tick]\"</code>\n* @param filename\n* The full path to the sound file (for example:\n* \"/sdcard/mysounds/tick.wav\")\n*\n* @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.\n*\n* @deprecated As of API level 21, replaced by\n* {@link #addEarcon(String, File)}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "addEarcon(String, File)", "methodReturn": "int", "isValid": true, "cleanReplacement": "addEarcon(String, File)", "fullMethod": "int addEarcon(String,String)", "method": "addEarcon(String,String)"}, "getDividerInset": {"methodClass": "com.android.setupwizardlib.template.ListMixin", "methodName": "getDividerInset", "replacementComments": "/**\n* @return The number of pixels inset on the start side of the divider.\n* @deprecated This is the same as {@link #getDividerInsetStart()}. Use that instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "that", "methodReturn": "int", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "int getDividerInset()", "method": "getDividerInset()"}, "setItemMargin": {"methodClass": "androidx.leanback.widget.BaseGridView", "methodName": "setItemMargin", "replacementComments": "/**\n* Sets the spacing in pixels between two child items.\n* @deprecated use {@link #setItemSpacing(int)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setItemSpacing(int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setItemSpacing(int)", "fullMethod": "void setItemMargin(int)", "method": "setItemMargin(int)"}, "getLoadingState": {"methodClass": "androidx.slice.SliceUtils", "methodName": "getLoadingState", "replacementComments": "/**\n* @return the current loading state of the provided {@link Slice}.\n*\n* @deprecated TO BE REMOVED: use {@link SliceMetadata#getLoadingState()}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "SliceMetadata#getLoadingState()", "methodReturn": "int", "isValid": true, "cleanReplacement": "getLoadingState()", "fullMethod": "int getLoadingState(Slice)", "method": "getLoadingState(Slice)"}, "getXVelocity": {"methodClass": "androidx.core.view.VelocityTrackerCompat", "methodName": "getXVelocity", "replacementComments": "/**\n* Call {@link VelocityTracker#getXVelocity(int)}.\n* If running on a pre-{@link android.os.Build.VERSION_CODES#HONEYCOMB} device,\n* returns {@link VelocityTracker#getXVelocity()}.\n*\n* @deprecated Use {@link VelocityTracker#getXVelocity(int)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "VelocityTracker#getXVelocity(int)", "methodReturn": "float", "isValid": true, "cleanReplacement": "getXVelocity(int)", "fullMethod": "float getXVelocity(VelocityTracker,int)", "method": "getXVelocity(VelocityTracker,int)"}, "invokeOemRilRequestRaw": {"methodClass": "com.android.internal.telephony.Phone", "methodName": "invokeOemRilRequestRaw", "replacementComments": "/**\n* Invokes RIL_REQUEST_OEM_HOOK_RAW on RIL implementation.\n*\n* @param data The data for the request.\n* @param response <strong>On success</strong>,\n* (byte[])(((AsyncResult)response.obj).result)\n* <strong>On failure</strong>,\n* (((AsyncResult)response.obj).result) == null and\n* (((AsyncResult)response.obj).exception) being an instance of\n* com.android.internal.telephony.gsm.CommandException\n*\n* @see #invokeOemRilRequestRaw(byte[], android.os.Message)\n* @deprecated OEM needs a vendor-extension hal and their apps should use that instead\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "that", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void invokeOemRilRequestRaw(byte[],Message)", "method": "invokeOemRilRequestRaw(byte[],Message)"}, "destroy": {"methodClass": "java.lang.Thread", "methodName": "destroy", "replacementComments": "/**\n* Throws {@link UnsupportedOperationException}.\n*\n* @deprecated This method was originally designed to destroy this\n* thread without any cleanup. Any monitors it held would have\n* remained locked. However, the method was never implemented.\n* If if were to be implemented, it would be deadlock-prone in\n* much the manner of {@link #suspend}. If the target thread held\n* a lock protecting a critical system resource when it was\n* destroyed, no thread could ever access this resource again.\n* If another thread ever attempted to lock this resource, deadlock\n* would result. Such deadlocks typically manifest themselves as\n* \"frozen\" processes. For more information, see\n* <a href=\"{@docRoot}openjdk-redirect.html?v=8&path=/technotes/guides/concurrency/threadPrimitiveDeprecation.html\">\n* Why are Thread.stop, Thread.suspend and Thread.resume Deprecated?</a>.\n* @throws UnsupportedOperationException always\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "suspend", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void destroy()", "method": "destroy()"}, "getCarrierCycles": {"methodClass": "android.location.GnssMeasurement", "methodName": "getCarrierCycles", "replacementComments": "/**\n* The number of full carrier cycles between the satellite and the receiver.\n*\n* <p>The reference frequency is given by the value of {@link #getCarrierFrequencyHz()}.\n*\n* <p>The value is only available if {@link #hasCarrierCycles()} is {@code true}.\n*\n* @deprecated use {@link #getAccumulatedDeltaRangeMeters()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getAccumulatedDeltaRangeMeters()", "methodReturn": "long", "isValid": true, "cleanReplacement": "getAccumulatedDeltaRangeMeters()", "fullMethod": "long getCarrierCycles()", "method": "getCarrierCycles()"}, "getDescriprition": {"methodClass": "android.drm.DrmSupportInfo", "methodName": "getDescriprition", "replacementComments": "/**\n* Retrieves the DRM plug-in (agent) description.\n*\n* @return The plug-in description.\n* @deprecated The method name is mis-spelled, and it is replaced by\n* {@link #getDescription()}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getDescription()", "methodReturn": "String", "isValid": true, "cleanReplacement": "getDescription()", "fullMethod": "String getDescriprition()", "method": "getDescriprition()"}, "setDrawerListener": {"methodClass": "androidx.drawerlayout.widget.DrawerLayout", "methodName": "setDrawerListener", "replacementComments": "/**\n* Set a listener to be notified of drawer events. Note that this method is deprecated\n* and you should use {@link #addDrawerListener(DrawerListener)} to add a listener and\n* {@link #removeDrawerListener(DrawerListener)} to remove a registered listener.\n*\n* @param listener Listener to notify when drawer events occur\n* @deprecated Use {@link #addDrawerListener(DrawerListener)}\n* @see DrawerListener\n* @see #addDrawerListener(DrawerListener)\n* @see #removeDrawerListener(DrawerListener)\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "DrawerListener", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void setDrawerListener(DrawerListener)", "method": "setDrawerListener(DrawerListener)"}, "writeFixed64": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writeFixed64", "replacementComments": "/**\n* Write a single proto \"fixed64\" type field value.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writeFixed64(long,long)", "method": "writeFixed64(long,long)"}, "addGpsStatusListener": {"methodClass": "android.location.LocationManager", "methodName": "addGpsStatusListener", "replacementComments": "/**\n* Adds a GPS status listener.\n*\n* @param listener GPS status listener object to register\n*\n* @return true if the listener was successfully added\n*\n* @throws SecurityException if the ACCESS_FINE_LOCATION permission is not present\n* @deprecated use {@link #registerGnssStatusCallback(GnssStatus.Callback)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "registerGnssStatusCallback(GnssStatus.Callback)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "registerGnssStatusCallback(GnssStatus.Callback)", "fullMethod": "boolean addGpsStatusListener(Listener)", "method": "addGpsStatusListener(Listener)"}, "startActivityFromFragment": {"methodClass": "android.app.Activity", "methodName": "startActivityFromFragment", "replacementComments": "/**\n* This is called when a Fragment in this activity calls its\n* {@link Fragment#startActivity} or {@link Fragment#startActivityForResult}\n* method.\n*\n* <p>This method throws {@link android.content.ActivityNotFoundException}\n* if there was no Activity found to run the given Intent.\n*\n* @param fragment The fragment making the call.\n* @param intent The intent to start.\n* @param requestCode Reply request code.  < 0 if reply is not requested.\n* @param options Additional options for how the Activity should be started.\n* See {@link android.content.Context#startActivity(Intent, Bundle)}\n* Context.startActivity(Intent, Bundle)} for more details.\n*\n* @throws android.content.ActivityNotFoundException\n*\n* @see Fragment#startActivity\n* @see Fragment#startActivityForResult\n*\n* @deprecated Use {@link android.support.v4.app.FragmentActivity#startActivityFromFragment(\n* android.support.v4.app.Fragment,Intent,int,Bundle)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "android.support.v4.app.FragmentActivity#startActivityFromFragment(  android.support.v4.app.Fragment,Intent,int,Bundle)", "methodReturn": "void", "isValid": true, "cleanReplacement": "startActivityFromFragment(  android.support.v4.app.Fragment,Intent,int,Bundle)", "fullMethod": "void startActivityFromFragment(Fragment,Intent,int,Bundle)", "method": "startActivityFromFragment(Fragment,Intent,int,Bundle)"}, "setTotalTime": {"methodClass": "androidx.leanback.widget.PlaybackControlsRow", "methodName": "setTotalTime", "replacementComments": "/**\n* Sets the total time in milliseconds for the playback controls row.\n* <p>If set after the row has been bound to a view, the adapter must be notified that\n* this row has changed.</p>\n* @deprecated Use {@link #setDuration(long)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setDuration(long)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setDuration(long)", "fullMethod": "void setTotalTime(int)", "method": "setTotalTime(int)"}, "onStartedGoingToSleep": {"methodClass": "com.android.keyguard.KeyguardUpdateMonitorCallback", "methodName": "onStartedGoingToSleep", "replacementComments": "/**\n* Called when the device has started going to sleep.\n* @param why see {@link #onFinishedGoingToSleep(int)}\n*\n* @deprecated use {@link com.android.systemui.keyguard.WakefulnessLifecycle}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "com.android.systemui.keyguard.WakefulnessLifecycle", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void onStartedGoingToSleep(int)", "method": "onStartedGoingToSleep(int)"}, "getApplication": {"methodClass": "com.android.internal.telephony.uicc.UiccCard", "methodName": "getApplication", "replacementComments": "/**\n* @deprecated Please use {@link UiccProfile#getApplication(int)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "UiccProfile#getApplication(int)", "methodReturn": "UiccCardApplication", "isValid": true, "cleanReplacement": "UiccProfile#getApplication(int)", "fullMethod": "UiccCardApplication getApplication(int)", "method": "getApplication(int)"}, "enableForegroundNdefPush": {"methodClass": "android.nfc.NfcAdapter", "methodName": "enableForegroundNdefPush", "replacementComments": "/**\n* Enable NDEF message push over NFC while this Activity is in the foreground.\n*\n* <p>You must explicitly call this method every time the activity is\n* resumed, and you must call {@link #disableForegroundNdefPush} before\n* your activity completes {@link Activity#onPause}.\n*\n* <p>Strongly recommend to use the new {@link #setNdefPushMessage}\n* instead: it automatically hooks into your activity life-cycle,\n* so you do not need to call enable/disable in your onResume/onPause.\n*\n* <p>For NDEF push to function properly the other NFC device must\n* support either NFC Forum's SNEP (Simple Ndef Exchange Protocol), or\n* Android's \"com.android.npp\" (Ndef Push Protocol). This was optional\n* on Gingerbread level Android NFC devices, but SNEP is mandatory on\n* Ice-Cream-Sandwich and beyond.\n*\n* <p>This method must be called from the main thread.\n*\n* <p class=\"note\">Requires the {@link android.Manifest.permission#NFC} permission.\n*\n* @param activity foreground activity\n* @param message a NDEF Message to push over NFC\n* @throws IllegalStateException if the activity is not currently in the foreground\n* @throws UnsupportedOperationException if FEATURE_NFC is unavailable.\n* @deprecated use {@link #setNdefPushMessage} instead\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setNdefPushMessage", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void enableForegroundNdefPush(Activity,NdefMessage)", "method": "enableForegroundNdefPush(Activity,NdefMessage)"}, "broadcastStickyIntent": {"methodClass": "android.app.ActivityManagerNative", "methodName": "broadcastStickyIntent", "replacementComments": "/**\n* @deprecated use ActivityManager.broadcastStickyIntent instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "ActivityManager.broadcastStickyIntent", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void broadcastStickyIntent(Intent,String,int)", "method": "broadcastStickyIntent(Intent,String,int)"}, "registerRemoteController": {"methodClass": "android.media.AudioManager", "methodName": "registerRemoteController", "replacementComments": "/**\n* Registers a {@link RemoteController} instance for it to receive media\n* metadata updates and playback state information from applications using\n* {@link RemoteControlClient}, and control their playback.\n* <p>\n* Registration requires the {@link RemoteController.OnClientUpdateListener} listener to be\n* one of the enabled notification listeners (see\n* {@link android.service.notification.NotificationListenerService}).\n*\n* @param rctlr the object to register.\n* @return true if the {@link RemoteController} was successfully registered,\n* false if an error occurred, due to an internal system error, or\n* insufficient permissions.\n* @deprecated Use\n* {@link MediaSessionManager#addOnActiveSessionsChangedListener(android.media.session.MediaSessionManager.OnActiveSessionsChangedListener, ComponentName)}\n* and {@link MediaController} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "MediaSessionManager#addOnActiveSessionsChangedListener(android.media.session.MediaSessionManager.OnActiveSessionsChangedListener, ComponentName)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "addOnActiveSessionsChangedListener(android.media.session.MediaSessionManager.OnActiveSessionsChangedListener, ComponentName)", "fullMethod": "boolean registerRemoteController(RemoteController)", "method": "registerRemoteController(RemoteController)"}, "getActionView": {"methodClass": "androidx.core.view.MenuItemCompat", "methodName": "getActionView", "replacementComments": "/**\n* Returns the currently set action view for this menu item.\n*\n* @param item the item to query\n* @return This item's action view\n*\n* @deprecated Use {@link MenuItem#getActionView()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "MenuItem#getActionView()", "methodReturn": "View", "isValid": true, "cleanReplacement": "getActionView()", "fullMethod": "View getActionView(MenuItem)", "method": "getActionView(MenuItem)"}, "getLanguage": {"methodClass": "android.speech.tts.TextToSpeech", "methodName": "getLanguage", "replacementComments": "/**\n* Returns a Locale instance describing the language currently being used for synthesis\n* requests sent to the TextToSpeech engine.\n*\n* In Android 4.2 and before (API <= 17) this function returns the language that is currently\n* being used by the TTS engine. That is the last language set by this or any other\n* client by a {@link TextToSpeech#setLanguage} call to the same engine.\n*\n* In Android versions after 4.2 this function returns the language that is currently being\n* used for the synthesis requests sent from this client. That is the last language set\n* by a {@link TextToSpeech#setLanguage} call on this instance.\n*\n* If a voice is set (by {@link #setVoice(Voice)}), getLanguage will return the language of\n* the currently set voice.\n*\n* Please note that the Locale object returned by this method is NOT a valid Locale object. Its\n* language field contains a three-letter ISO 639-2/T code (where a proper Locale would use\n* a two-letter ISO 639-1 code), and the country field contains a three-letter ISO 3166 country\n* code (where a proper Locale would use a two-letter ISO 3166-1 code).\n*\n* @return language, country (if any) and variant (if any) used by the client stored in a\n* Locale instance, or {@code null} on error.\n*\n* @deprecated As of API level 21, please use <code>getVoice().getLocale()</code>\n* ({@link #getVoice()}).\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getVoice()", "methodReturn": "Locale", "isValid": true, "cleanReplacement": "getVoice()", "fullMethod": "Locale getLanguage()", "method": "getLanguage()"}, "shouldShowRequestPermissionRationale": {"methodClass": "androidx.legacy.app.FragmentCompat", "methodName": "shouldShowRequestPermissionRationale", "replacementComments": "/**\n* Gets whether you should show UI with rationale for requesting a permission.\n* You should do this only if you do not have the permission and the context in\n* which the permission is requested does not clearly communicate to the user\n* what would be the benefit from granting this permission.\n* <p>\n* For example, if you write a camera app, requesting the camera permission\n* would be expected by the user and no rationale for why it is requested is\n* needed. If however, the app needs location for tagging photos then a non-tech\n* savvy user may wonder how location is related to taking photos. In this case\n* you may choose to show UI with rationale of requesting this permission.\n* </p>\n*\n* @param fragment The target fragment.\n* @param permission A permission your app wants to request.\n* @return Whether you can show permission rationale UI.\n*\n* @see androidx.core.content.ContextCompat#checkSelfPermission(\n* android.content.Context, String)\n* @see #requestPermissions(android.app.Fragment, String[], int)\n*\n* @deprecated Use {@link androidx.fragment.app.Fragment} instead of the framework\n* {@link Fragment}.\n*/\n", "isClassDeprecated": true, "dirtyReplacement": "androidx.fragment.app.Fragment", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "androidx.fragment.app.Fragment", "fullMethod": "boolean shouldShowRequestPermissionRationale(Fragment,String)", "method": "shouldShowRequestPermissionRationale(Fragment,String)"}, "onNestedScrollAccepted": {"methodClass": "androidx.coordinatorlayout.widget.CoordinatorLayout.Behavior", "methodName": "onNestedScrollAccepted", "replacementComments": "/**\n* @deprecated You should now override\n* {@link #onNestedScrollAccepted(CoordinatorLayout, View, View, View, int, int)}. This\n* method will still continue to be called if the type is {@link ViewCompat#TYPE_TOUCH}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "onNestedScrollAccepted(CoordinatorLayout, View, View, View, int, int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "onNestedScrollAccepted(CoordinatorLayout, View, View, View, int, int)", "fullMethod": "void onNestedScrollAccepted(CoordinatorLayout,V,View,View,int)", "method": "onNestedScrollAccepted(CoordinatorLayout,V,View,View,int)"}, "addToGroup": {"methodClass": "android.provider.Contacts.People", "methodName": "addToGroup", "replacementComments": "/**\n* Adds a person to a group.\n*\n* @param resolver the resolver to use\n* @param personId the person to add to the group\n* @param groupId the group to add the person to\n* @return the URI of the group membership row\n* @deprecated see {@link android.provider.ContactsContract}\n*/\n", "isClassDeprecated": true, "dirtyReplacement": "android.provider.ContactsContract", "methodReturn": "Uri", "isValid": true, "cleanReplacement": "android.provider.ContactsContract", "fullMethod": "Uri addToGroup(ContentResolver,long,long)", "method": "addToGroup(ContentResolver,long,long)"}, "setLocationModeForUser": {"methodClass": "android.provider.Settings.Secure", "methodName": "setLocationModeForUser", "replacementComments": "/**\n* Thread-safe method for setting the location mode to one of\n* {@link #LOCATION_MODE_HIGH_ACCURACY}, {@link #LOCATION_MODE_SENSORS_ONLY},\n* {@link #LOCATION_MODE_BATTERY_SAVING}, or {@link #LOCATION_MODE_OFF}.\n* Necessary because the mode is a composite of the underlying location provider\n* settings.\n*\n* @param cr the content resolver to use\n* @param mode such as {@link #LOCATION_MODE_HIGH_ACCURACY}\n* @param userId the userId for which to change mode\n* @return true if the value was set, false on database errors\n*\n* @throws IllegalArgumentException if mode is not one of the supported values\n*\n* @deprecated To enable/disable location, use\n* {@link LocationManager#setLocationEnabledForUser(boolean, int)}.\n* To enable/disable a specific location provider, use\n* {@link LocationManager#setProviderEnabledForUser(String, boolean, int)}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "LocationManager#setLocationEnabledForUser(boolean, int)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "setLocationEnabledForUser(boolean, int)", "fullMethod": "boolean setLocationModeForUser(ContentResolver,int,int)", "method": "setLocationModeForUser(ContentResolver,int,int)"}, "startDrag": {"methodClass": "android.view.View", "methodName": "startDrag", "replacementComments": "/**\n* @deprecated Use {@link #startDragAndDrop(ClipData, DragShadowBuilder, Object, int)\n* startDragAndDrop()} for newer platform versions.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "startDragAndDrop(ClipData, DragShadowBuilder, Object, int)  startDragAndDrop()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "startDragAndDrop(ClipData, DragShadowBuilder, Object, int)  startDragAndDrop()", "fullMethod": "boolean startDrag(ClipData,DragShadowBuilder,Object,int)", "method": "startDrag(ClipData,DragShadowBuilder,Object,int)"}, "disableForegroundNdefPush": {"methodClass": "android.nfc.NfcAdapter", "methodName": "disableForegroundNdefPush", "replacementComments": "/**\n* Disable NDEF message push over P2P.\n*\n* <p>After calling {@link #enableForegroundNdefPush}, an activity\n* must call this method before its {@link Activity#onPause} callback\n* completes.\n*\n* <p>Strongly recommend to use the new {@link #setNdefPushMessage}\n* instead: it automatically hooks into your activity life-cycle,\n* so you do not need to call enable/disable in your onResume/onPause.\n*\n* <p>This method must be called from the main thread.\n*\n* <p class=\"note\">Requires the {@link android.Manifest.permission#NFC} permission.\n*\n* @param activity the Foreground activity\n* @throws IllegalStateException if the Activity has already been paused\n* @throws UnsupportedOperationException if FEATURE_NFC is unavailable.\n* @deprecated use {@link #setNdefPushMessage} instead\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setNdefPushMessage", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void disableForegroundNdefPush(Activity)", "method": "disableForegroundNdefPush(Activity)"}, "setContentDescription": {"methodClass": "androidx.core.view.accessibility.AccessibilityRecordCompat", "methodName": "setContentDescription", "replacementComments": "/**\n* Sets the description of the source.\n*\n* @param contentDescription The description.\n*\n* @throws IllegalStateException If called from an AccessibilityService.\n*\n* @deprecated Use {@link AccessibilityRecord#setContentDescription(CharSequence)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityRecord#setContentDescription(CharSequence)", "methodReturn": "void", "isValid": true, "cleanReplacement": "AccessibilityRecord#setContentDescription(CharSequence)", "fullMethod": "void setContentDescription(CharSequence)", "method": "setContentDescription(CharSequence)"}, "getHours": {"methodClass": "java.sql.Date", "methodName": "getHours", "replacementComments": "/**\n* @deprecated This method is deprecated and should not be used because SQL Date\n* values do not have a time component.\n*\n* @exception java.lang.IllegalArgumentException if this method is invoked\n* @see #setHours\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setHours", "methodReturn": "int", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "int getHours()", "method": "getHours()"}, "getKeyData": {"methodClass": "android.view.KeyCharacterMap", "methodName": "getKeyData", "replacementComments": "/**\n* Get the character conversion data for a given key code.\n*\n* @param keyCode The keyCode to query.\n* @param results A {@link KeyData} instance that will be filled with the results.\n* @return True if the key was mapped.  If the key was not mapped, results is not modified.\n*\n* @deprecated instead use {@link KeyCharacterMap#getDisplayLabel(int)},\n* {@link KeyCharacterMap#getNumber(int)} or {@link KeyCharacterMap#get(int, int)}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "KeyCharacterMap#getDisplayLabel(int)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "getDisplayLabel(int)", "fullMethod": "boolean getKeyData(int,KeyData)", "method": "getKeyData(int,KeyData)"}, "createSnapScroller": {"methodClass": "androidx.recyclerview.widget.SnapHelper", "methodName": "createSnapScroller", "replacementComments": "/**\n* Creates a scroller to be used in the snapping implementation.\n*\n* @param layoutManager     The {@link RecyclerView.LayoutManager} associated with the attached\n* {@link RecyclerView}.\n*\n* @return a {@link LinearSmoothScroller} which will handle the scrolling.\n* @deprecated use {@link #createScroller(RecyclerView.LayoutManager)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "createScroller(RecyclerView.LayoutManager)", "methodReturn": "LinearSmoothScroller", "isValid": true, "cleanReplacement": "createScroller(RecyclerView.LayoutManager)", "fullMethod": "LinearSmoothScroller createSnapScroller(LayoutManager)", "method": "createSnapScroller(LayoutManager)"}, "scrollToBottom": {"methodClass": "android.test.TouchUtils", "methodName": "scrollToBottom", "replacementComments": "/**\n* Scroll a ViewGroup to the bottom by repeatedly calling\n* {@link #dragQuarterScreenUp(InstrumentationTestCase, Activity)}\n*\n* @param test The test case that is being run\n* @param v The ViewGroup that should be dragged\n*\n* @deprecated {@link android.test.ActivityInstrumentationTestCase} is deprecated in favor of\n* {@link android.test.ActivityInstrumentationTestCase2}, which provides more options for\n* configuring the Activity under test\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "android.test.ActivityInstrumentationTestCase2", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void scrollToBottom(ActivityInstrumentationTestCase,ViewGroup)", "method": "scrollToBottom(ActivityInstrumentationTestCase,ViewGroup)"}, "setHorizontalMargin": {"methodClass": "androidx.leanback.widget.BaseGridView", "methodName": "setHorizontalMargin", "replacementComments": "/**\n* Sets the spacing in pixels between two child items horizontally.\n* @deprecated Use {@link #setHorizontalSpacing(int)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setHorizontalSpacing(int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setHorizontalSpacing(int)", "fullMethod": "void setHorizontalMargin(int)", "method": "setHorizontalMargin(int)"}, "setParcelableData": {"methodClass": "androidx.core.view.accessibility.AccessibilityRecordCompat", "methodName": "setParcelableData", "replacementComments": "/**\n* Sets the {@link Parcelable} data of the event.\n*\n* @param parcelableData The parcelable data.\n*\n* @throws IllegalStateException If called from an AccessibilityService.\n*\n* @deprecated Use {@link AccessibilityRecord#setParcelableData(Parcelable)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityRecord#setParcelableData(Parcelable)", "methodReturn": "void", "isValid": true, "cleanReplacement": "AccessibilityRecord#setParcelableData(Parcelable)", "fullMethod": "void setParcelableData(Parcelable)", "method": "setParcelableData(Parcelable)"}, "getBlockSize": {"methodClass": "android.os.StatFs", "methodName": "getBlockSize", "replacementComments": "/**\n* @deprecated Use {@link #getBlockSizeLong()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getBlockSizeLong()", "methodReturn": "int", "isValid": true, "cleanReplacement": "getBlockSizeLong()", "fullMethod": "int getBlockSize()", "method": "getBlockSize()"}, "getStreamType": {"methodClass": "android.media.Ringtone", "methodName": "getStreamType", "replacementComments": "/**\n* Gets the stream type where this ringtone will be played.\n*\n* @return The stream type, see {@link AudioManager}.\n* @deprecated use of stream types is deprecated, see\n* {@link #setAudioAttributes(AudioAttributes)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setAudioAttributes(AudioAttributes)", "methodReturn": "int", "isValid": true, "cleanReplacement": "setAudioAttributes(AudioAttributes)", "fullMethod": "int getStreamType()", "method": "getStreamType()"}, "markAsContacted": {"methodClass": "android.provider.ContactsContract.Contacts", "methodName": "markAsContacted", "replacementComments": "/**\n* Mark a contact as having been contacted. Updates two fields:\n* {@link #TIMES_CONTACTED} and {@link #LAST_TIME_CONTACTED}. The\n* TIMES_CONTACTED field is incremented by 1 and the LAST_TIME_CONTACTED\n* field is populated with the current system time.\n*\n* @param resolver the ContentResolver to use\n* @param contactId the person who was contacted\n*\n* @deprecated The class DataUsageStatUpdater of the Android support library should\n* be used instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "d", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void markAsContacted(ContentResolver,long)", "method": "markAsContacted(ContentResolver,long)"}, "peekWallpaper": {"methodClass": "android.content.Context", "methodName": "peekWallpaper", "replacementComments": "/**\n* @deprecated Use {@link android.app.WallpaperManager#peekDrawable\n* WallpaperManager.peek()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "android.app.WallpaperManager#peekDrawable  WallpaperManager.peek()", "methodReturn": "Drawable", "isValid": true, "cleanReplacement": "peekDrawable  WallpaperManager.peek()", "fullMethod": "Drawable peekWallpaper()", "method": "peekWallpaper()"}, "getCellLocation": {"methodClass": "android.telephony.TelephonyManager", "methodName": "getCellLocation", "replacementComments": "/**\n* Returns the current location of the device.\n* <p>\n* If there is only one radio in the device and that radio has an LTE connection,\n* this method will return null. The implementation must not to try add LTE\n* identifiers into the existing cdma/gsm classes.\n* <p>\n* @return Current location of the device or null if not available.\n*\n* @deprecated use {@link #getAllCellInfo} instead, which returns a superset of this API.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getAllCellInfo", "methodReturn": "CellLocation", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "CellLocation getCellLocation()", "method": "getCellLocation()"}, "invokeOemRilRequestStrings": {"methodClass": "com.android.internal.telephony.Phone", "methodName": "invokeOemRilRequestStrings", "replacementComments": "/**\n* Invokes RIL_REQUEST_OEM_HOOK_Strings on RIL implementation.\n*\n* @param strings The strings to make available as the request data.\n* @param response <strong>On success</strong>, \"response\" bytes is\n* made available as:\n* (String[])(((AsyncResult)response.obj).result).\n* <strong>On failure</strong>,\n* (((AsyncResult)response.obj).result) == null and\n* (((AsyncResult)response.obj).exception) being an instance of\n* com.android.internal.telephony.gsm.CommandException\n*\n* @see #invokeOemRilRequestStrings(java.lang.String[], android.os.Message)\n* @deprecated OEM needs a vendor-extension hal and their apps should use that instead\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "that", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void invokeOemRilRequestStrings(String[],Message)", "method": "invokeOemRilRequestStrings(String[],Message)"}, "getFactory": {"methodClass": "androidx.core.view.LayoutInflaterCompat", "methodName": "getFactory", "replacementComments": "/**\n* Return the current {@link LayoutInflaterFactory} (or null). This is\n* called on each element name. If the factory returns a View, add that\n* to the hierarchy. If it returns null, proceed to call onCreateView(name).\n*\n* @return The {@link LayoutInflaterFactory} associated with the\n* {@link LayoutInflater}. Will be {@code null} if the inflater does not\n* have a {@link LayoutInflaterFactory} but a raw {@link LayoutInflater.Factory}.\n* @see LayoutInflater#getFactory()\n*\n* @deprecated Use {@link #setFactory2(LayoutInflater, LayoutInflater.Factory2)} to set and\n* {@link LayoutInflater#getFactory2()} to get the factory.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setFactory2(LayoutInflater, LayoutInflater.Factory2)", "methodReturn": "LayoutInflaterFactory", "isValid": true, "cleanReplacement": "setFactory2(LayoutInflater, LayoutInflater.Factory2)", "fullMethod": "LayoutInflaterFactory getFactory(LayoutInflater)", "method": "getFactory(LayoutInflater)"}, "isNull": {"methodClass": "android.database.CursorWindow", "methodName": "isNull", "replacementComments": "/**\n* Returns true if the field at the specified row and column index\n* has type {@link Cursor#FIELD_TYPE_NULL}.\n*\n* @param row The zero-based row index.\n* @param column The zero-based column index.\n* @return True if the field has type {@link Cursor#FIELD_TYPE_NULL}.\n* @deprecated Use {@link #getType(int, int)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getType(int, int)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "getType(int, int)", "fullMethod": "boolean isNull(int,int)", "method": "isNull(int,int)"}, "playSilence": {"methodClass": "android.speech.tts.TextToSpeech", "methodName": "playSilence", "replacementComments": "/**\n* Plays silence for the specified amount of time using the specified\n* queue mode.\n* This method is asynchronous, i.e. the method just adds the request to the queue of TTS\n* requests and then returns. The synthesis might not have finished (or even started!) at the\n* time when this method returns. In order to reliably detect errors during synthesis,\n* we recommend setting an utterance progress listener (see\n* {@link #setOnUtteranceProgressListener}) and using the\n* {@link Engine#KEY_PARAM_UTTERANCE_ID} parameter.\n*\n* @param durationInMs The duration of the silence.\n* @param queueMode {@link #QUEUE_ADD} or {@link #QUEUE_FLUSH}.\n* @param params Parameters for the request. Can be null.\n* Supported parameter names:\n* {@link Engine#KEY_PARAM_UTTERANCE_ID}.\n* Engine specific parameters may be passed in but the parameter keys\n* must be prefixed by the name of the engine they are intended for. For example\n* the keys \"com.svox.pico_foo\" and \"com.svox.pico:bar\" will be passed to the\n* engine named \"com.svox.pico\" if it is being used.\n*\n* @return {@link #ERROR} or {@link #SUCCESS} of <b>queuing</b> the playSilence operation.\n* @deprecated As of API level 21, replaced by\n* {@link #playSilentUtterance(long, int, String)}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "playSilentUtterance(long, int, String)", "methodReturn": "int", "isValid": true, "cleanReplacement": "playSilentUtterance(long, int, String)", "fullMethod": "int playSilence(long,int,HashMap<String, String>)", "method": "playSilence(long,int,HashMap<String,"}, "writePackedUInt64": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writePackedUInt64", "replacementComments": "/**\n* Write a single proto \"uint64\" type field value.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writePackedUInt64(long,long[])", "method": "writePackedUInt64(long,long[])"}, "toURL": {"methodClass": "java.io.File", "methodName": "toURL", "replacementComments": "/**\n* Converts this abstract pathname into a <code>file:</code> URL.  The\n* exact form of the URL is system-dependent.  If it can be determined that\n* the file denoted by this abstract pathname is a directory, then the\n* resulting URL will end with a slash.\n*\n* @return  A URL object representing the equivalent file URL\n*\n* @throws  MalformedURLException\n* If the path cannot be parsed as a URL\n*\n* @see     #toURI()\n* @see     java.net.URI\n* @see     java.net.URI#toURL()\n* @see     java.net.URL\n* @since   1.2\n*\n* @deprecated This method does not automatically escape characters that\n* are illegal in URLs.  It is recommended that new code convert an\n* abstract pathname into a URL by first converting it into a URI, via the\n* {@link #toURI() toURI} method, and then converting the URI into a URL\n* via the {@link java.net.URI#toURL() URI.toURL} method.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "toURI() toURI", "methodReturn": "URL", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "URL toURL()", "method": "toURL()"}, "addPostalLocation": {"methodClass": "android.provider.Contacts.ContactMethods", "methodName": "addPostalLocation", "replacementComments": "/**\n* Add a longitude and latitude location to a postal address.\n*\n* @param context the context to use when updating the database\n* @param postalId the address to update\n* @param latitude the latitude for the address\n* @param longitude the longitude for the address\n* @deprecated see {@link android.provider.ContactsContract}\n*/\n", "isClassDeprecated": true, "dirtyReplacement": "android.provider.ContactsContract", "methodReturn": "void", "isValid": true, "cleanReplacement": "android.provider.ContactsContract", "fullMethod": "void addPostalLocation(Context,long,double,double)", "method": "addPostalLocation(Context,long,double,double)"}, "writeDouble": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writeDouble", "replacementComments": "/**\n* Write a single proto \"double\" type field value.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writeDouble(long,double)", "method": "writeDouble(long,double)"}, "toURI": {"methodClass": "android.content.Intent", "methodName": "toURI", "replacementComments": "/**\n* Call {@link #toUri} with 0 flags.\n* @deprecated Use {@link #toUri} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "toUri", "methodReturn": "String", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "String toURI()", "method": "toURI()"}, "resetAppWithAid": {"methodClass": "com.android.internal.telephony.uicc.UiccCard", "methodName": "resetAppWithAid", "replacementComments": "/**\n* Resets the application with the input AID. Returns true if any changes were made.\n*\n* A null aid implies a card level reset - all applications must be reset.\n*\n* @deprecated Please use {@link UiccProfile#resetAppWithAid(String)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "UiccProfile#resetAppWithAid(String)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "UiccProfile#resetAppWithAid(String)", "fullMethod": "boolean resetAppWithAid(String)", "method": "resetAppWithAid(String)"}, "isWfcRoamingEnabledByUser": {"methodClass": "com.android.ims.ImsManager", "methodName": "isWfcRoamingEnabledByUser", "replacementComments": "/**\n* Returns the user configuration of WFC roaming setting\n*\n* @deprecated Does not support MSIM devices. Please use\n* {@link #isWfcRoamingEnabledByUser()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "isWfcRoamingEnabledByUser()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "isWfcRoamingEnabledByUser()", "fullMethod": "boolean isWfcRoamingEnabledByUser(Context)", "method": "isWfcRoamingEnabledByUser(Context)"}, "setLaunchDocument": {"methodClass": "androidx.navigation.NavOptions.Builder", "methodName": "setLaunchDocument", "replacementComments": "/**\n* Launch a navigation target as a document if you want it to appear as its own\n* entry in the system Overview screen. If the same document is launched multiple times\n* it will not create a new task, it will bring the existing document task to the front.\n*\n* <p>If the user presses the system Back key from a new document task they will land\n* on their previous task. If the user reached the document task from the system Overview\n* screen they will be taken to their home screen.</p>\n*\n* @param launchDocument true to launch a new document task\n* @deprecated As per the {@link android.content.Intent#FLAG_ACTIVITY_NEW_DOCUMENT}\n* documentation, it is recommended to use {@link android.R.attr#documentLaunchMode} on an\n* Activity you wish to launch as a new document.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "android.content.Intent#FLAG_ACTIVITY_NEW_DOCUMENT", "methodReturn": "Builder", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "Builder setLaunchDocument(boolean)", "method": "setLaunchDocument(boolean)"}, "calledPartyBCDFragmentToString": {"methodClass": "android.telephony.PhoneNumberUtils", "methodName": "calledPartyBCDFragmentToString", "replacementComments": "/**\n* Like calledPartyBCDToString, but field does not start with a\n* TOA byte. For example: SIM ADN extension fields\n*\n* @deprecated use {@link #calledPartyBCDFragmentToString(byte[], int, int, int)} instead.\n* Calling this method is equivalent to calling\n* {@link #calledPartyBCDFragmentToString(byte[], int, int, int)} with\n* {@link #BCD_EXTENDED_TYPE_EF_ADN} as the extended type.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "calledPartyBCDFragmentToString(byte[], int, int, int)", "methodReturn": "String", "isValid": true, "cleanReplacement": "calledPartyBCDFragmentToString(byte[], int, int, int)", "fullMethod": "String calledPartyBCDFragmentToString(byte[],int,int)", "method": "calledPartyBCDFragmentToString(byte[],int,int)"}, "createFromPdu": {"methodClass": "android.telephony.SmsMessage", "methodName": "createFromPdu", "replacementComments": "/**\n* Create an SmsMessage from a raw PDU. Guess format based on Voice\n* technology first, if it fails use other format.\n* All applications which handle\n* incoming SMS messages by processing the {@code SMS_RECEIVED_ACTION} broadcast\n* intent <b>must</b> now pass the new {@code format} String extra from the intent\n* into the new method {@code createFromPdu(byte[], String)} which takes an\n* extra format parameter. This is required in order to correctly decode the PDU on\n* devices that require support for both 3GPP and 3GPP2 formats at the same time,\n* such as dual-mode GSM/CDMA and CDMA/LTE phones.\n* @deprecated Use {@link #createFromPdu(byte[], String)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "createFromPdu(byte[], String)", "methodReturn": "SmsMessage", "isValid": true, "cleanReplacement": "createFromPdu(byte[], String)", "fullMethod": "SmsMessage createFromPdu(byte[])", "method": "createFromPdu(byte[])"}, "unregisterListener": {"methodClass": "android.hardware.SensorManager", "methodName": "unregisterListener", "replacementComments": "/**\n* Unregisters a listener for the sensors with which it is registered.\n*\n* @deprecated This method is deprecated, use\n* {@link SensorManager#unregisterListener(SensorEventListener, Sensor)}\n* instead.\n*\n* @param listener\n* a SensorListener object\n*\n* @param sensors\n* a bit masks of the sensors to unregister from\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "SensorManager#unregisterListener(SensorEventListener, Sensor)", "methodReturn": "void", "isValid": true, "cleanReplacement": "unregisterListener(SensorEventListener, Sensor)", "fullMethod": "void unregisterListener(SensorListener,int)", "method": "unregisterListener(SensorListener,int)"}, "setRotation": {"methodClass": "androidx.core.view.ViewCompat", "methodName": "setRotation", "replacementComments": "/**\n* Sets the degrees that the view is rotated around the pivot point. Increasing values\n* result in clockwise rotation.\n*\n* @param value The degrees of rotation.\n*\n* @deprecated Use {@link View#setRotation(float)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "View#setRotation(float)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setRotation(float)", "fullMethod": "void setRotation(View,float)", "method": "setRotation(View,float)"}, "getWindowTouchSlop": {"methodClass": "android.view.ViewConfiguration", "methodName": "getWindowTouchSlop", "replacementComments": "/**\n* @return Distance in dips a touch must be outside the bounds of a window for it\n* to be counted as outside the window for purposes of dismissing that\n* window.\n*\n* @deprecated Use {@link #getScaledWindowTouchSlop()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getScaledWindowTouchSlop()", "methodReturn": "int", "isValid": true, "cleanReplacement": "getScaledWindowTouchSlop()", "fullMethod": "int getWindowTouchSlop()", "method": "getWindowTouchSlop()"}, "getEnabledAccessibilityServiceList": {"methodClass": "androidx.core.view.accessibility.AccessibilityManagerCompat", "methodName": "getEnabledAccessibilityServiceList", "replacementComments": "/**\n* Returns the {@link AccessibilityServiceInfo}s of the enabled accessibility services\n* for a given feedback type.\n*\n* @param manager The accessibility manager.\n* @param feedbackTypeFlags The feedback type flags.\n* @return An unmodifiable list with {@link AccessibilityServiceInfo}s.\n*\n* @see AccessibilityServiceInfo#FEEDBACK_AUDIBLE\n* @see AccessibilityServiceInfo#FEEDBACK_GENERIC\n* @see AccessibilityServiceInfo#FEEDBACK_HAPTIC\n* @see AccessibilityServiceInfo#FEEDBACK_SPOKEN\n* @see AccessibilityServiceInfo#FEEDBACK_VISUAL\n*\n* @deprecated Use {@link AccessibilityManager#getEnabledAccessibilityServiceList(int)}\n* directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityManager#getEnabledAccessibilityServiceList(int)", "methodReturn": "List<AccessibilityServiceInfo>", "isValid": true, "cleanReplacement": "getEnabledAccessibilityServiceList(int)", "fullMethod": "List<AccessibilityServiceInfo> getEnabledAccessibilityServiceList(AccessibilityManager,int)", "method": "getEnabledAccessibilityServiceList(AccessibilityManager,int)"}, "onDetachedFromWindow": {"methodClass": "androidx.legacy.app.FragmentTabHost", "methodName": "onDetachedFromWindow", "replacementComments": "/**\n* @deprecated Use {@link androidx.fragment.app.FragmentTabHost} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "androidx.fragment.app.FragmentTabHost", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void onDetachedFromWindow()", "method": "onDetachedFromWindow()"}, "unregisterMediaButtonEventReceiver": {"methodClass": "android.media.AudioManager", "methodName": "unregisterMediaButtonEventReceiver", "replacementComments": "/**\n* Unregister the receiver of MEDIA_BUTTON intents.\n* @param eventReceiver identifier of a {@link android.content.BroadcastReceiver}\n* that was registered with {@link #registerMediaButtonEventReceiver(ComponentName)}.\n* @deprecated Use {@link MediaSession} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "MediaSession", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void unregisterMediaButtonEventReceiver(ComponentName)", "method": "unregisterMediaButtonEventReceiver(ComponentName)"}, "setColorScheme": {"methodClass": "androidx.swiperefreshlayout.widget.SwipeRefreshLayout", "methodName": "setColorScheme", "replacementComments": "/**\n* @deprecated Use {@link #setColorSchemeResources(int...)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setColorSchemeResources(int...)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setColorSchemeResources(int...)", "fullMethod": "void setColorScheme(int)", "method": "setColorScheme(int)"}, "getRecordCount": {"methodClass": "androidx.core.view.accessibility.AccessibilityEventCompat", "methodName": "getRecordCount", "replacementComments": "/**\n* Gets the number of records contained in the event.\n*\n* @return The number of records.\n*\n* @deprecated Use {@link AccessibilityEvent#getRecordCount()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityEvent#getRecordCount()", "methodReturn": "int", "isValid": true, "cleanReplacement": "getRecordCount()", "fullMethod": "int getRecordCount(AccessibilityEvent)", "method": "getRecordCount(AccessibilityEvent)"}, "onFinishedGoingToSleep": {"methodClass": "com.android.keyguard.KeyguardUpdateMonitorCallback", "methodName": "onFinishedGoingToSleep", "replacementComments": "/**\n* Called when the device has finished going to sleep.\n* @param why either {@link WindowManagerPolicyConstants#OFF_BECAUSE_OF_ADMIN},\n* {@link WindowManagerPolicyConstants#OFF_BECAUSE_OF_USER}, or\n* {@link WindowManagerPolicyConstants#OFF_BECAUSE_OF_TIMEOUT}.\n*\n* @deprecated use {@link com.android.systemui.keyguard.WakefulnessLifecycle}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "com.android.systemui.keyguard.WakefulnessLifecycle", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void onFinishedGoingToSleep(int)", "method": "onFinishedGoingToSleep(int)"}, "buildUnionSubQuery": {"methodClass": "android.database.sqlite.SQLiteQueryBuilder", "methodName": "buildUnionSubQuery", "replacementComments": "/**\n* @deprecated This method's signature is misleading since no SQL parameter\n* substitution is carried out.  The selection arguments parameter does not get\n* used at all.  To avoid confusion, call\n* {@link #buildUnionSubQuery}\n* instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "buildUnionSubQuery", "methodReturn": "String", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "String buildUnionSubQuery(String,String[],Set<String>,int,String,String,String[],String,String)", "method": "buildUnionSubQuery(String,String[],Set<String>,int,String,String,String[],String,String)"}, "getOutputBuffers": {"methodClass": "android.media.MediaCodec", "methodName": "getOutputBuffers", "replacementComments": "/**\n* Retrieve the set of output buffers.  Call this after start()\n* returns and whenever dequeueOutputBuffer signals an output\n* buffer change by returning {@link\n* #INFO_OUTPUT_BUFFERS_CHANGED}. After calling this method, any\n* ByteBuffers previously returned by an earlier call to this\n* method MUST no longer be used.\n*\n* @deprecated Use the new {@link #getOutputBuffer} method instead\n* each time an output buffer is dequeued.  This method is not\n* supported if codec is configured in asynchronous mode.\n*\n* <b>Note:</b> As of API 21, the position and limit of output\n* buffers that are dequeued will be set to the valid data\n* range.\n*\n* <em>Do not use this method if using an output surface.</em>\n*\n* @throws IllegalStateException if not in the Executing state,\n* or codec is configured in asynchronous mode.\n* @throws MediaCodec.CodecException upon codec error.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getOutputBuffer", "methodReturn": "ByteBuffer[]", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "ByteBuffer[] getOutputBuffers()", "method": "getOutputBuffers()"}, "onRelease": {"methodClass": "androidx.core.widget.EdgeEffectCompat", "methodName": "onRelease", "replacementComments": "/**\n* Call when the object is released after being pulled.\n* This will begin the \"decay\" phase of the effect. After calling this method\n* the host view should {@link android.view.View#invalidate()} if this method\n* returns true and thereby draw the results accordingly.\n*\n* @return true if the host view should invalidate, false if it should not.\n*\n* @deprecated Use {@link EdgeEffect#onRelease()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "EdgeEffect#onRelease()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "EdgeEffect#onRelease()", "fullMethod": "boolean onRelease()", "method": "onRelease()"}, "setY": {"methodClass": "androidx.core.view.ViewCompat", "methodName": "setY", "replacementComments": "/**\n* Sets the visual y position of this view, in pixels. This is equivalent to setting the\n* {@link #setTranslationY(View, float) translationY} property to be the difference between\n* the y value passed in and the current top property of the view as determined by the\n* layout bounds.\n*\n* @param value The visual y position of this view, in pixels.\n*\n* @deprecated Use {@link View#setY(float)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "View#setY(float)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setY(float)", "fullMethod": "void setY(View,float)", "method": "setY(View,float)"}, "isRoaming": {"methodClass": "android.net.NetworkInfo", "methodName": "isRoaming", "replacementComments": "/**\n* Indicates whether the device is currently roaming on this network. When\n* {@code true}, it suggests that use of data on this network may incur\n* extra costs.\n*\n* @return {@code true} if roaming is in effect, {@code false} otherwise.\n* @deprecated Callers should switch to checking\n* {@link NetworkCapabilities#NET_CAPABILITY_NOT_ROAMING}\n* instead, since that handles more complex situations, such as\n* VPNs.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "NetworkCapabilities#NET_CAPABILITY_NOT_ROAMING", "methodReturn": "boolean", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "boolean isRoaming()", "method": "isRoaming()"}, "iccTransmitApduLogicalChannel": {"methodClass": "com.android.internal.telephony.uicc.UiccCard", "methodName": "iccTransmitApduLogicalChannel", "replacementComments": "/**\n* Exposes {@link CommandsInterface#iccTransmitApduLogicalChannel}\n* @deprecated Please use {@link\n* UiccProfile#iccTransmitApduLogicalChannel(int, int, int, int, int, int, String, Message)}\n* instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "UiccProfile#iccTransmitApduLogicalChannel(int, int, int, int, int, int, String, Message)", "methodReturn": "void", "isValid": true, "cleanReplacement": "iccTransmitApduLogicalChannel(int, int, int, int, int, int, String, Message)", "fullMethod": "void iccTransmitApduLogicalChannel(int,int,int,int,int,int,String,Message)", "method": "iccTransmitApduLogicalChannel(int,int,int,int,int,int,String,Message)"}, "isLocationProviderEnabled": {"methodClass": "android.provider.Settings.Secure", "methodName": "isLocationProviderEnabled", "replacementComments": "/**\n* Helper method for determining if a location provider is enabled.\n*\n* @param cr the content resolver to use\n* @param provider the location provider to query\n* @return true if the provider is enabled\n*\n* @deprecated use {@link LocationManager#isProviderEnabled(String)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "LocationManager#isProviderEnabled(String)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "isProviderEnabled(String)", "fullMethod": "boolean isLocationProviderEnabled(ContentResolver,String)", "method": "isLocationProviderEnabled(ContentResolver,String)"}, "hidden": {"methodClass": "com.android.internal.logging.MetricsLogger", "methodName": "hidden", "replacementComments": "/**\n* @deprecated use {@link #hidden(int)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "hidden(int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "hidden(int)", "fullMethod": "void hidden(Context,int)", "method": "hidden(Context,int)"}, "removeDialog": {"methodClass": "android.app.Activity", "methodName": "removeDialog", "replacementComments": "/**\n* Removes any internal references to a dialog managed by this Activity.\n* If the dialog is showing, it will dismiss it as part of the clean up.\n*\n* <p>This can be useful if you know that you will never show a dialog again and\n* want to avoid the overhead of saving and restoring it in the future.\n*\n* <p>As of {@link android.os.Build.VERSION_CODES#GINGERBREAD}, this function\n* will not throw an exception if you try to remove an ID that does not\n* currently have an associated dialog.</p>\n*\n* @param id The id of the managed dialog.\n*\n* @see #onCreateDialog(int, Bundle)\n* @see #onPrepareDialog(int, Dialog, Bundle)\n* @see #showDialog(int)\n* @see #dismissDialog(int)\n*\n* @deprecated Use the new {@link DialogFragment} class with\n* {@link FragmentManager} instead; this is also\n* available on older platforms through the Android compatibility package.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "DialogFragment", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void removeDialog(int)", "method": "removeDialog(int)"}, "of": {"methodClass": "androidx.lifecycle.ViewModelStores", "methodName": "of", "replacementComments": "/**\n* Returns the {@link ViewModelStore} of the given activity.\n*\n* @param activity an activity whose {@code ViewModelStore} is requested\n* @return a {@code ViewModelStore}\n* @deprecated Use {@link FragmentActivity#getViewModelStore()}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "FragmentActivity#getViewModelStore()", "methodReturn": "ViewModelStore", "isValid": true, "cleanReplacement": "getViewModelStore()", "fullMethod": "ViewModelStore of(FragmentActivity)", "method": "of(FragmentActivity)"}, "iconResourceId": {"methodClass": "androidx.leanback.widget.GuidedAction.BuilderBase", "methodName": "iconResourceId", "replacementComments": "/**\n* Sets the action's icon drawable by retrieving it by resource ID from the specified\n* context. This is a convenience function that simply looks up the drawable and calls\n* {@link #icon(Drawable)}.\n* @param iconResourceId The resource ID for the icon associated with this action.\n* @param context The context whose resource ID should be retrieved.\n* @deprecated Use {@link #icon(int)}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "icon(int)", "methodReturn": "B", "isValid": true, "cleanReplacement": "icon(int)", "fullMethod": "B iconResourceId(int,Context)", "method": "iconResourceId(int,Context)"}, "jumpDrawablesToCurrentState": {"methodClass": "androidx.core.view.ViewCompat", "methodName": "jumpDrawablesToCurrentState", "replacementComments": "/**\n* On API 11 devices and above, call <code>Drawable.jumpToCurrentState()</code>\n* on all Drawable objects associated with this view.\n* <p>\n* On API 21 and above, also calls <code>StateListAnimator#jumpToCurrentState()</code>\n* if there is a StateListAnimator attached to this view.\n*\n* @deprecated Use {@link View#jumpDrawablesToCurrentState()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "View#jumpDrawablesToCurrentState()", "methodReturn": "void", "isValid": true, "cleanReplacement": "jumpDrawablesToCurrentState()", "fullMethod": "void jumpDrawablesToCurrentState(View)", "method": "jumpDrawablesToCurrentState(View)"}, "getBitmap": {"methodClass": "android.hardware.radio.RadioMetadata", "methodName": "getBitmap", "replacementComments": "/**\n* Returns a {@link Bitmap} for the given key or null if the key is not found in the meta data.\n*\n* @param key The key the value is stored under\n* @return a {@link Bitmap} or null\n* @deprecated Use getBitmapId(String) instead\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getBitmapId(String)", "methodReturn": "Bitmap", "isValid": true, "cleanReplacement": "getBitmapId(String)", "fullMethod": "Bitmap getBitmap(String)", "method": "getBitmap(String)"}, "instantScrollToPosition": {"methodClass": "com.android.internal.widget.RecyclerView.SmoothScroller", "methodName": "instantScrollToPosition", "replacementComments": "/**\n* @see RecyclerView#scrollToPosition(int)\n* @deprecated Use {@link Action#jumpTo(int)}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "Action#jumpTo(int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "jumpTo(int)", "fullMethod": "void instantScrollToPosition(int)", "method": "instantScrollToPosition(int)"}, "concatenateWhere": {"methodClass": "androidx.core.database.DatabaseUtilsCompat", "methodName": "concatenateWhere", "replacementComments": "/**\n* Concatenates two SQL WHERE clauses, handling empty or null values.\n*\n* @deprecated Use {@link android.database.DatabaseUtils#concatenateWhere(String, String)}\n* directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "android.database.DatabaseUtils#concatenateWhere(String, String)", "methodReturn": "String", "isValid": true, "cleanReplacement": "concatenateWhere(String, String)", "fullMethod": "String concatenateWhere(String,String)", "method": "concatenateWhere(String,String)"}, "isViewFromObject": {"methodClass": "androidx.legacy.app.FragmentPagerAdapter", "methodName": "isViewFromObject", "replacementComments": "/**\n* @deprecated Use {@link androidx.fragment.app.FragmentPagerAdapter} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "androidx.fragment.app.FragmentPagerAdapter", "methodReturn": "boolean", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "boolean isViewFromObject(View,Object)", "method": "isViewFromObject(View,Object)"}, "getBlockCount": {"methodClass": "android.os.StatFs", "methodName": "getBlockCount", "replacementComments": "/**\n* @deprecated Use {@link #getBlockCountLong()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getBlockCountLong()", "methodReturn": "int", "isValid": true, "cleanReplacement": "getBlockCountLong()", "fullMethod": "int getBlockCount()", "method": "getBlockCount()"}, "queryCallBarring": {"methodClass": "com.android.ims.ImsUt", "methodName": "queryCallBarring", "replacementComments": "/**\n* Operations for the supplementary service configuration\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "queryCallBarring(int, Message, int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "queryCallBarring(int, Message, int)", "fullMethod": "void queryCallBarring(int,Message)", "method": "queryCallBarring(int,Message)"}, "getItem": {"methodClass": "androidx.legacy.app.FragmentStatePagerAdapter", "methodName": "getItem", "replacementComments": "/**\n* Return the Fragment associated with a specified position.\n*\n* @deprecated Use {@link androidx.fragment.app.FragmentStatePagerAdapter} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "androidx.fragment.app.FragmentStatePagerAdapter", "methodReturn": "Fragment", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "Fragment getItem(int)", "method": "getItem(int)"}, "addRegistrationListener": {"methodClass": "com.android.ims.ImsManager", "methodName": "addRegistrationListener", "replacementComments": "/**\n* Adds registration listener to the IMS service.\n*\n* @param serviceClass a service class specified in {@link ImsServiceClass}\n* For VoLTE service, it MUST be a {@link ImsServiceClass#MMTEL}.\n* @param listener To listen to IMS registration events; It cannot be null\n* @throws NullPointerException if {@code listener} is null\n* @throws ImsException if calling the IMS service results in an error\n*\n* @deprecated Use {@link #addRegistrationListener(ImsConnectionStateListener)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "addRegistrationListener(ImsConnectionStateListener)", "methodReturn": "void", "isValid": true, "cleanReplacement": "addRegistrationListener(ImsConnectionStateListener)", "fullMethod": "void addRegistrationListener(int,ImsConnectionStateListener)", "method": "addRegistrationListener(int,ImsConnectionStateListener)"}, "setFromIndex": {"methodClass": "androidx.core.view.accessibility.AccessibilityRecordCompat", "methodName": "setFromIndex", "replacementComments": "/**\n* Sets the index of the first character of the changed sequence\n* or the beginning of a text selection or the index of the first\n* visible item when scrolling.\n*\n* @param fromIndex The index of the first character or selection\n* start or the first visible item.\n*\n* @throws IllegalStateException If called from an AccessibilityService.\n*\n* @deprecated Use {@link AccessibilityRecord#setFromIndex(int)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityRecord#setFromIndex(int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "AccessibilityRecord#setFromIndex(int)", "fullMethod": "void setFromIndex(int)", "method": "setFromIndex(int)"}, "setMaxScrollX": {"methodClass": "androidx.core.view.accessibility.AccessibilityRecordCompat", "methodName": "setMaxScrollX", "replacementComments": "/**\n* Sets the max scroll offset of the source left edge in pixels.\n*\n* @param maxScrollX The max scroll.\n*\n* @deprecated Use {@link #setMaxScrollX(AccessibilityRecord, int)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setMaxScrollX(AccessibilityRecord, int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setMaxScrollX(AccessibilityRecord, int)", "fullMethod": "void setMaxScrollX(int)", "method": "setMaxScrollX(int)"}, "setMaxScrollY": {"methodClass": "androidx.core.view.accessibility.AccessibilityRecordCompat", "methodName": "setMaxScrollY", "replacementComments": "/**\n* Sets the max scroll offset of the source top edge in pixels.\n*\n* @param maxScrollY The max scroll.\n*\n* @deprecated Use {@link #setMaxScrollY(AccessibilityRecord, int)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setMaxScrollY(AccessibilityRecord, int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setMaxScrollY(AccessibilityRecord, int)", "fullMethod": "void setMaxScrollY(int)", "method": "setMaxScrollY(int)"}, "visible": {"methodClass": "com.android.internal.logging.MetricsLogger", "methodName": "visible", "replacementComments": "/**\n* @deprecated use {@link #visible(int)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "visible(int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "visible(int)", "fullMethod": "void visible(Context,int)", "method": "visible(Context,int)"}, "getCanRetrieveWindowContent": {"methodClass": "android.accessibilityservice.AccessibilityServiceInfo", "methodName": "getCanRetrieveWindowContent", "replacementComments": "/**\n* Whether this service can retrieve the current window's content.\n* <p>\n* <strong>Statically set from\n* {@link AccessibilityService#SERVICE_META_DATA meta-data}.</strong>\n* </p>\n* @return True if window content can be retrieved.\n*\n* @deprecated Use {@link #getCapabilities()}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getCapabilities()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "getCapabilities()", "fullMethod": "boolean getCanRetrieveWindowContent()", "method": "getCanRetrieveWindowContent()"}, "setToIndex": {"methodClass": "androidx.core.view.accessibility.AccessibilityRecordCompat", "methodName": "setToIndex", "replacementComments": "/**\n* Sets the index of text selection end or the index of the last\n* visible item when scrolling.\n*\n* @param toIndex The index of selection end or last item index.\n*\n* @deprecated Use {@link AccessibilityRecord#setToIndex(int)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityRecord#setToIndex(int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "AccessibilityRecord#setToIndex(int)", "fullMethod": "void setToIndex(int)", "method": "setToIndex(int)"}, "dupFileDescriptor": {"methodClass": "android.os.Parcel", "methodName": "dupFileDescriptor", "replacementComments": "/**\n* @deprecated use {@link android.system.Os#dup(FileDescriptor)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "android.system.Os#dup(FileDescriptor)", "methodReturn": "FileDescriptor", "isValid": true, "cleanReplacement": "dup(FileDescriptor)", "fullMethod": "FileDescriptor dupFileDescriptor(FileDescriptor)", "method": "dupFileDescriptor(FileDescriptor)"}, "setInputMethodAndSubtype": {"methodClass": "android.view.inputmethod.InputMethodManager", "methodName": "setInputMethodAndSubtype", "replacementComments": "/**\n* Force switch to a new input method and subtype. This can only be called\n* from an application or a service which has a token of the currently active input method.\n* @param token Supplies the identifying token given to an input method\n* when it was started, which allows it to perform this operation on\n* itself.\n* @param id The unique identifier for the new input method to be switched to.\n* @param subtype The new subtype of the new input method to be switched to.\n* @deprecated Use\n* {@link InputMethodService#switchInputMethod(String, InputMethodSubtype)}\n* instead. This method was intended for IME developers who should be accessing APIs through\n* the service. APIs in this class are intended for app developers interacting with the IME.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "InputMethodService#switchInputMethod(String, InputMethodSubtype)", "methodReturn": "void", "isValid": true, "cleanReplacement": "switchInputMethod(String, InputMethodSubtype)", "fullMethod": "void setInputMethodAndSubtype(IBinder,String,InputMethodSubtype)", "method": "setInputMethodAndSubtype(IBinder,String,InputMethodSubtype)"}, "onPopulateAccessibilityEvent": {"methodClass": "androidx.core.view.ViewCompat", "methodName": "onPopulateAccessibilityEvent", "replacementComments": "/**\n* Called from {@link View#dispatchPopulateAccessibilityEvent(AccessibilityEvent)}\n* giving a chance to this View to populate the accessibility event with its\n* text content. While this method is free to modify event\n* attributes other than text content, doing so should normally be performed in\n* {@link View#onInitializeAccessibilityEvent(AccessibilityEvent)}.\n* <p>\n* Example: Adding formatted date string to an accessibility event in addition\n* to the text added by the super implementation:\n* <pre> public void onPopulateAccessibilityEvent(AccessibilityEvent event) {\n* super.onPopulateAccessibilityEvent(event);\n* final int flags = DateUtils.FORMAT_SHOW_DATE | DateUtils.FORMAT_SHOW_WEEKDAY;\n* String selectedDateUtterance = DateUtils.formatDateTime(mContext,\n* mCurrentDate.getTimeInMillis(), flags);\n* event.getText().add(selectedDateUtterance);\n* }</pre>\n* <p>\n* If an {@link AccessibilityDelegateCompat} has been specified via calling\n* {@link ViewCompat#setAccessibilityDelegate(View, AccessibilityDelegateCompat)} its\n* {@link AccessibilityDelegateCompat#onPopulateAccessibilityEvent(View, AccessibilityEvent)}\n* is responsible for handling this call.\n* </p>\n* <p class=\"note\"><strong>Note:</strong> Always call the super implementation before adding\n* information to the event, in case the default implementation has basic information to add.\n* </p>\n*\n* @param v The View against which to invoke the method.\n* @param event The accessibility event which to populate.\n*\n* @see View#sendAccessibilityEvent(int)\n* @see View#dispatchPopulateAccessibilityEvent(AccessibilityEvent)\n*\n* @deprecated Call {@link View#onPopulateAccessibilityEvent(AccessibilityEvent)} directly.\n* This method will be removed in a future release.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "View#onPopulateAccessibilityEvent(AccessibilityEvent)", "methodReturn": "void", "isValid": true, "cleanReplacement": "onPopulateAccessibilityEvent(AccessibilityEvent)", "fullMethod": "void onPopulateAccessibilityEvent(View,AccessibilityEvent)", "method": "onPopulateAccessibilityEvent(View,AccessibilityEvent)"}, "expandActionView": {"methodClass": "androidx.core.view.MenuItemCompat", "methodName": "expandActionView", "replacementComments": "/**\n* Expand the action view associated with this menu item.\n* The menu item must have an action view set, as well as\n* the showAsAction flag {@link #SHOW_AS_ACTION_COLLAPSE_ACTION_VIEW}.\n* If a listener has been set using\n* {@link #setOnActionExpandListener(MenuItem, OnActionExpandListener)}\n* it will have its {@link OnActionExpandListener#onMenuItemActionExpand(MenuItem)}\n* method invoked. The listener may return false from this method to prevent expanding\n* the action view.\n*\n* @return true if the action view was expanded, false otherwise.\n*\n* @deprecated Use {@link MenuItem#expandActionView()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "MenuItem#expandActionView()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "expandActionView()", "fullMethod": "boolean expandActionView(MenuItem)", "method": "expandActionView(MenuItem)"}, "getItemCount": {"methodClass": "androidx.core.view.accessibility.AccessibilityRecordCompat", "methodName": "getItemCount", "replacementComments": "/**\n* Gets the number of items that can be visited.\n*\n* @return The number of items.\n*\n* @deprecated Use {@link AccessibilityRecord#getItemCount()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityRecord#getItemCount()", "methodReturn": "int", "isValid": true, "cleanReplacement": "AccessibilityRecord#getItemCount()", "fullMethod": "int getItemCount()", "method": "getItemCount()"}, "hasEnrolledFingerprints": {"methodClass": "android.hardware.fingerprint.FingerprintManager", "methodName": "hasEnrolledFingerprints", "replacementComments": "/**\n* Determine if there is at least one fingerprint enrolled.\n*\n* @return true if at least one fingerprint is enrolled, false otherwise\n* @deprecated See {@link BiometricPrompt} and\n* {@link FingerprintManager#FINGERPRINT_ERROR_NO_FINGERPRINTS}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "BiometricPrompt", "methodReturn": "boolean", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "boolean hasEnrolledFingerprints()", "method": "hasEnrolledFingerprints()"}, "getBytes": {"methodClass": "java.lang.String", "methodName": "getBytes", "replacementComments": "/**\n* Copies characters from this string into the destination byte array. Each\n* byte receives the 8 low-order bits of the corresponding character. The\n* eight high-order bits of each character are not copied and do not\n* participate in the transfer in any way.\n*\n* <p> The first character to be copied is at index {@code srcBegin}; the\n* last character to be copied is at index {@code srcEnd-1}.  The total\n* number of characters to be copied is {@code srcEnd-srcBegin}. The\n* characters, converted to bytes, are copied into the subarray of {@code\n* dst} starting at index {@code dstBegin} and ending at index:\n*\n* <blockquote><pre>\n* dstBegin + (srcEnd-srcBegin) - 1\n* </pre></blockquote>\n*\n* @deprecated  This method does not properly convert characters into\n* bytes.  As of JDK&nbsp;1.1, the preferred way to do this is via the\n* {@link #getBytes()} method, which uses the platform's default charset.\n*\n* @param  srcBegin\n* Index of the first character in the string to copy\n*\n* @param  srcEnd\n* Index after the last character in the string to copy\n*\n* @param  dst\n* The destination array\n*\n* @param  dstBegin\n* The start offset in the destination array\n*\n* @throws  IndexOutOfBoundsException\n* If any of the following is true:\n* <ul>\n* <li> {@code srcBegin} is negative\n* <li> {@code srcBegin} is greater than {@code srcEnd}\n* <li> {@code srcEnd} is greater than the length of this String\n* <li> {@code dstBegin} is negative\n* <li> {@code dstBegin+(srcEnd-srcBegin)} is larger than {@code\n* dst.length}\n* </ul>\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getBytes()", "methodReturn": "void", "isValid": true, "cleanReplacement": "getBytes()", "fullMethod": "void getBytes(int,int,byte[],int)", "method": "getBytes(int,int,byte[],int)"}, "getStatusOnSim": {"methodClass": "android.telephony.gsm.SmsMessage", "methodName": "getStatusOnSim", "replacementComments": "/**\n* Returns the status of the message on the SIM (read, unread, sent, unsent).\n*\n* @return the status of the message on the SIM.  These are:\n* SmsManager.STATUS_ON_SIM_FREE\n* SmsManager.STATUS_ON_SIM_READ\n* SmsManager.STATUS_ON_SIM_UNREAD\n* SmsManager.STATUS_ON_SIM_SEND\n* SmsManager.STATUS_ON_SIM_UNSENT\n* @deprecated Use android.telephony.SmsMessage and getStatusOnIcc instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "android.telephony.SmsMessage and getStatusOnIcc", "methodReturn": "int", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "int getStatusOnSim()", "method": "getStatusOnSim()"}, "getBigDecimal": {"methodClass": "java.sql.CallableStatement", "methodName": "getBigDecimal", "replacementComments": "/**\n* Retrieves the value of the designated JDBC <code>NUMERIC</code> parameter as a\n* <code>java.math.BigDecimal</code> object with <i>scale</i> digits to\n* the right of the decimal point.\n* @param parameterIndex the first parameter is 1, the second is 2,\n* and so on\n* @param scale the number of digits to the right of the decimal point\n* @return the parameter value.  If the value is SQL <code>NULL</code>, the result\n* is <code>null</code>.\n* @exception SQLException if the parameterIndex is not valid;\n* if a database access error occurs or\n* this method is called on a closed <code>CallableStatement</code>\n* @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n* this method\n* @deprecated use <code>getBigDecimal(int parameterIndex)</code>\n* or <code>getBigDecimal(String parameterName)</code>\n* @see #setBigDecimal\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setBigDecimal", "methodReturn": "BigDecimal", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "BigDecimal getBigDecimal(int,int)", "method": "getBigDecimal(int,int)"}, "setBeforeText": {"methodClass": "androidx.core.view.accessibility.AccessibilityRecordCompat", "methodName": "setBeforeText", "replacementComments": "/**\n* Sets the text before a change.\n*\n* @param beforeText The text before the change.\n*\n* @throws IllegalStateException If called from an AccessibilityService.\n*\n* @deprecated Use {@link AccessibilityRecord#setBeforeText(CharSequence)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityRecord#setBeforeText(CharSequence)", "methodReturn": "void", "isValid": true, "cleanReplacement": "AccessibilityRecord#setBeforeText(CharSequence)", "fullMethod": "void setBeforeText(CharSequence)", "method": "setBeforeText(CharSequence)"}, "restartPackage": {"methodClass": "android.app.ActivityManager", "methodName": "restartPackage", "replacementComments": "/**\n* @deprecated This is now just a wrapper for\n* {@link #killBackgroundProcesses(String)}; the previous behavior here\n* is no longer available to applications because it allows them to\n* break other applications by removing their alarms, stopping their\n* services, etc.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "killBackgroundProcesses(String)", "methodReturn": "void", "isValid": true, "cleanReplacement": "killBackgroundProcesses(String)", "fullMethod": "void restartPackage(String)", "method": "restartPackage(String)"}, "unregisterCallback": {"methodClass": "android.hardware.location.ContextHubManager", "methodName": "unregisterCallback", "replacementComments": "/**\n* Unregister a callback for receive messages from the context hub.\n*\n* @see Callback\n*\n* @param callback method to deregister\n*\n* @return int 0 on success, -1 otherwise\n*\n* @deprecated Use {@link android.hardware.location.ContextHubClient#close()} to unregister\n* a {@link android.hardware.location.ContextHubClientCallback}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "android.hardware.location.ContextHubClient#close()", "methodReturn": "int", "isValid": true, "cleanReplacement": "close()", "fullMethod": "int unregisterCallback(Callback)", "method": "unregisterCallback(Callback)"}, "getDeviceId": {"methodClass": "android.telephony.TelephonyManager", "methodName": "getDeviceId", "replacementComments": "/**\n* Returns the unique device ID of a subscription, for example, the IMEI for\n* GSM and the MEID for CDMA phones. Return null if device ID is not available.\n*\n* <p>Requires Permission: {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\n* or that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\n*\n* @param slotIndex of which deviceID is returned\n*\n* @deprecated Use (@link getImei} which returns IMEI for GSM or (@link getMeid} which returns\n* MEID for CDMA.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getImei", "methodReturn": "String", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "String getDeviceId(int)", "method": "getDeviceId(int)"}, "isTurnOffImsAllowedByPlatform": {"methodClass": "com.android.ims.ImsManager", "methodName": "isTurnOffImsAllowedByPlatform", "replacementComments": "/**\n* Returns whether turning off ims is allowed by platform.\n* The platform property may override the carrier config.\n*\n* @deprecated Does not support MSIM devices. Please use\n* {@link #isTurnOffImsAllowedByPlatform()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "isTurnOffImsAllowedByPlatform()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "isTurnOffImsAllowedByPlatform()", "fullMethod": "boolean isTurnOffImsAllowedByPlatform(Context)", "method": "isTurnOffImsAllowedByPlatform(Context)"}, "setVerticalMargin": {"methodClass": "androidx.leanback.widget.BaseGridView", "methodName": "setVerticalMargin", "replacementComments": "/**\n* Sets the spacing in pixels between two child items vertically.\n* @deprecated Use {@link #setVerticalSpacing(int)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setVerticalSpacing(int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setVerticalSpacing(int)", "fullMethod": "void setVerticalMargin(int)", "method": "setVerticalMargin(int)"}, "onPrepareDialog": {"methodClass": "android.app.Activity", "methodName": "onPrepareDialog", "replacementComments": "/**\n* @deprecated Old no-arguments version of\n* {@link #onPrepareDialog(int, Dialog, Bundle)}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "onPrepareDialog(int, Dialog, Bundle)", "methodReturn": "void", "isValid": true, "cleanReplacement": "onPrepareDialog(int, Dialog, Bundle)", "fullMethod": "void onPrepareDialog(int,Dialog)", "method": "onPrepareDialog(int,Dialog)"}, "setDrawingCacheEnabled": {"methodClass": "android.view.View", "methodName": "setDrawingCacheEnabled", "replacementComments": "/**\n* <p>Enables or disables the drawing cache. When the drawing cache is enabled, the next call\n* to {@link #getDrawingCache()} or {@link #buildDrawingCache()} will draw the view in a\n* bitmap. Calling {@link #draw(android.graphics.Canvas)} will not draw from the cache when\n* the cache is enabled. To benefit from the cache, you must request the drawing cache by\n* calling {@link #getDrawingCache()} and draw it on screen if the returned bitmap is not\n* null.</p>\n*\n* <p>Enabling the drawing cache is similar to\n* {@link #setLayerType(int, android.graphics.Paint) setting a layer} when hardware\n* acceleration is turned off. When hardware acceleration is turned on, enabling the\n* drawing cache has no effect on rendering because the system uses a different mechanism\n* for acceleration which ignores the flag. If you want to use a Bitmap for the view, even\n* when hardware acceleration is enabled, see {@link #setLayerType(int, android.graphics.Paint)}\n* for information on how to enable software and hardware layers.</p>\n*\n* <p>This API can be used to manually generate\n* a bitmap copy of this view, by setting the flag to <code>true</code> and calling\n* {@link #getDrawingCache()}.</p>\n*\n* @param enabled true to enable the drawing cache, false otherwise\n*\n* @see #isDrawingCacheEnabled()\n* @see #getDrawingCache()\n* @see #buildDrawingCache()\n* @see #setLayerType(int, android.graphics.Paint)\n*\n* @deprecated The view drawing cache was largely made obsolete with the introduction of\n* hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache\n* layers are largely unnecessary and can easily result in a net loss in performance due to the\n* cost of creating and updating the layer. In the rare cases where caching layers are useful,\n* such as for alpha animations, {@link #setLayerType(int, Paint)} handles this with hardware\n* rendering. For software-rendered snapshots of a small part of the View hierarchy or\n* individual Views it is recommended to create a {@link Canvas} from either a {@link Bitmap} or\n* {@link android.graphics.Picture} and call {@link #draw(Canvas)} on the View. However these\n* software-rendered usages are discouraged and have compatibility issues with hardware-only\n* rendering features such as {@link android.graphics.Bitmap.Config#HARDWARE Config.HARDWARE}\n* bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback\n* reports or unit testing the {@link PixelCopy} API is recommended.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setLayerType(int, Paint)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setLayerType(int, Paint)", "fullMethod": "void setDrawingCacheEnabled(boolean)", "method": "setDrawingCacheEnabled(boolean)"}, "currentLoadedClass": {"methodClass": "java.lang.SecurityManager", "methodName": "currentLoadedClass", "replacementComments": "/**\n* @deprecated Use {@link #checkPermission} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "checkPermission", "methodReturn": "Class<?>", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "Class<?> currentLoadedClass()", "method": "currentLoadedClass()"}, "getSupportedPreviewFrameRates": {"methodClass": "android.hardware.Camera.Parameters", "methodName": "getSupportedPreviewFrameRates", "replacementComments": "/**\n* Gets the supported preview frame rates.\n*\n* @return a list of supported preview frame rates. null if preview\n* frame rate setting is not supported.\n* @deprecated replaced by {@link #getSupportedPreviewFpsRange()}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getSupportedPreviewFpsRange()", "methodReturn": "List<Integer>", "isValid": true, "cleanReplacement": "getSupportedPreviewFpsRange()", "fullMethod": "List<Integer> getSupportedPreviewFrameRates()", "method": "getSupportedPreviewFrameRates()"}, "getClassName": {"methodClass": "androidx.core.view.accessibility.AccessibilityRecordCompat", "methodName": "getClassName", "replacementComments": "/**\n* Gets the class name of the source.\n*\n* @return The class name.\n*\n* @deprecated Use {@link AccessibilityRecord#getClassName()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityRecord#getClassName()", "methodReturn": "CharSequence", "isValid": true, "cleanReplacement": "AccessibilityRecord#getClassName()", "fullMethod": "CharSequence getClassName()", "method": "getClassName()"}, "getState": {"methodClass": "android.net.NetworkInfo", "methodName": "getState", "replacementComments": "/**\n* Reports the current coarse-grained state of the network.\n* @return the coarse-grained state\n* @deprecated Apps should instead use the\n* {@link android.net.ConnectivityManager.NetworkCallback} API to\n* learn about connectivity changes.\n* {@link ConnectivityManager#registerDefaultNetworkCallback} and\n* {@link ConnectivityManager#registerNetworkCallback}. These will\n* give a more accurate picture of the connectivity state of\n* the device and let apps react more easily and quickly to changes.\n*/\n", "isClassDeprecated": true, "dirtyReplacement": "android.net.ConnectivityManager.NetworkCallback", "methodReturn": "State", "isValid": true, "cleanReplacement": "android.net.ConnectivityManager.NetworkCallback", "fullMethod": "State getState()", "method": "getState()"}, "setRemovedCount": {"methodClass": "androidx.core.view.accessibility.AccessibilityRecordCompat", "methodName": "setRemovedCount", "replacementComments": "/**\n* Sets the number of removed characters.\n*\n* @param removedCount The number of removed characters.\n*\n* @throws IllegalStateException If called from an AccessibilityService.\n*\n* @deprecated Use {@link AccessibilityRecord#setRemovedCount(int)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityRecord#setRemovedCount(int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "AccessibilityRecord#setRemovedCount(int)", "fullMethod": "void setRemovedCount(int)", "method": "setRemovedCount(int)"}, "setPersistentDrawingCache": {"methodClass": "android.view.ViewGroup", "methodName": "setPersistentDrawingCache", "replacementComments": "/**\n* Indicates what types of drawing caches should be kept in memory after\n* they have been created.\n*\n* @see #getPersistentDrawingCache()\n* @see #setAnimationCacheEnabled(boolean)\n*\n* @param drawingCacheToKeep one or a combination of {@link #PERSISTENT_NO_CACHE},\n* {@link #PERSISTENT_ANIMATION_CACHE}, {@link #PERSISTENT_SCROLLING_CACHE}\n* and {@link #PERSISTENT_ALL_CACHES}\n*\n* @deprecated The view drawing cache was largely made obsolete with the introduction of\n* hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache\n* layers are largely unnecessary and can easily result in a net loss in performance due to the\n* cost of creating and updating the layer. In the rare cases where caching layers are useful,\n* such as for alpha animations, {@link #setLayerType(int, Paint)} handles this with hardware\n* rendering. For software-rendered snapshots of a small part of the View hierarchy or\n* individual Views it is recommended to create a {@link Canvas} from either a {@link Bitmap} or\n* {@link android.graphics.Picture} and call {@link #draw(Canvas)} on the View. However these\n* software-rendered usages are discouraged and have compatibility issues with hardware-only\n* rendering features such as {@link android.graphics.Bitmap.Config#HARDWARE Config.HARDWARE}\n* bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback\n* reports or unit testing the {@link PixelCopy} API is recommended.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setLayerType(int, Paint)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setLayerType(int, Paint)", "fullMethod": "void setPersistentDrawingCache(int)", "method": "setPersistentDrawingCache(int)"}, "dispatchReallyStop": {"methodClass": "androidx.fragment.app.FragmentController", "methodName": "dispatchReallyStop", "replacementComments": "/**\n* @deprecated This functionality has been rolled into {@link #dispatchStop()}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "dispatchStop()", "methodReturn": "void", "isValid": true, "cleanReplacement": "dispatchStop()", "fullMethod": "void dispatchReallyStop()", "method": "dispatchReallyStop()"}, "getDefaultRequestProperty": {"methodClass": "java.net.URLConnection", "methodName": "getDefaultRequestProperty", "replacementComments": "/**\n* Returns the value of the default request property. Default request\n* properties are set for every connection.\n*\n* @param key the keyword by which the request is known (e.g., \"Accept\").\n* @return  the value of the default request property\n* for the specified key.\n*\n* @see java.net.URLConnection#getRequestProperty(java.lang.String)\n*\n* @deprecated The instance specific getRequestProperty method\n* should be used after an appropriate instance of URLConnection\n* is obtained.\n*\n* @see #setDefaultRequestProperty(java.lang.String, java.lang.String)\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setDefaultRequestProperty(java.lang.String,", "methodReturn": "String", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "String getDefaultRequestProperty(String)", "method": "getDefaultRequestProperty(String)"}, "iccTransmitApduBasicChannel": {"methodClass": "com.android.internal.telephony.uicc.UiccCard", "methodName": "iccTransmitApduBasicChannel", "replacementComments": "/**\n* Exposes {@link CommandsInterface#iccTransmitApduBasicChannel}\n* @deprecated Please use\n* {@link UiccProfile#iccTransmitApduBasicChannel(int, int, int, int, int, String, Message)}\n* instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "UiccProfile#iccTransmitApduBasicChannel(int, int, int, int, int, String, Message)", "methodReturn": "void", "isValid": true, "cleanReplacement": "iccTransmitApduBasicChannel(int, int, int, int, int, String, Message)", "fullMethod": "void iccTransmitApduBasicChannel(int,int,int,int,int,String,Message)", "method": "iccTransmitApduBasicChannel(int,int,int,int,int,String,Message)"}, "histogram": {"methodClass": "com.android.internal.logging.MetricsLogger", "methodName": "histogram", "replacementComments": "/**\n* Increment the bucket with the integer label on the histogram with the given name.\n* @deprecated use {@link #histogram(String, int)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "histogram(String, int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "histogram(String, int)", "fullMethod": "void histogram(Context,String,int)", "method": "histogram(Context,String,int)"}, "writeRepeatedFixed32": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writeRepeatedFixed32", "replacementComments": "/**\n* Write a single repeated proto \"fixed32\" type field value.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writeRepeatedFixed32(long,int)", "method": "writeRepeatedFixed32(long,int)"}, "getProvisionedStringValue": {"methodClass": "com.android.ims.ImsConfig", "methodName": "getProvisionedStringValue", "replacementComments": "/**\n* @deprecated see {@link #getConfigString(int)} instead\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getConfigString(int)", "methodReturn": "String", "isValid": true, "cleanReplacement": "getConfigString(int)", "fullMethod": "String getProvisionedStringValue(int)", "method": "getProvisionedStringValue(int)"}, "getRotationX": {"methodClass": "androidx.core.view.ViewCompat", "methodName": "getRotationX", "replacementComments": "/**\n* @deprecated Use {@link View#getRotationX()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "View#getRotationX()", "methodReturn": "float", "isValid": true, "cleanReplacement": "getRotationX()", "fullMethod": "float getRotationX(View)", "method": "getRotationX(View)"}, "setProvisionedValue": {"methodClass": "com.android.ims.ImsConfig", "methodName": "setProvisionedValue", "replacementComments": "/**\n* @deprecated see {@link #setConfig(int, int)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setConfig(int, int)", "methodReturn": "int", "isValid": true, "cleanReplacement": "setConfig(int, int)", "fullMethod": "int setProvisionedValue(int,int)", "method": "setProvisionedValue(int,int)"}, "getIntent": {"methodClass": "android.content.Intent", "methodName": "getIntent", "replacementComments": "/**\n* Call {@link #parseUri} with 0 flags.\n* @deprecated Use {@link #parseUri} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "parseUri", "methodReturn": "Intent", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "Intent getIntent(String)", "method": "getIntent(String)"}, "isHardwareDetected": {"methodClass": "android.hardware.fingerprint.FingerprintManager", "methodName": "isHardwareDetected", "replacementComments": "/**\n* Determine if fingerprint hardware is present and functional.\n*\n* @return true if hardware is present and functional, false otherwise.\n* @deprecated See {@link BiometricPrompt} and\n* {@link FingerprintManager#FINGERPRINT_ERROR_HW_UNAVAILABLE}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "BiometricPrompt", "methodReturn": "boolean", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "boolean isHardwareDetected()", "method": "isHardwareDetected()"}, "startLeScan": {"methodClass": "android.bluetooth.BluetoothAdapter", "methodName": "startLeScan", "replacementComments": "/**\n* Starts a scan for Bluetooth LE devices, looking for devices that\n* advertise given services.\n*\n* <p>Devices which advertise all specified services are reported using the\n* {@link LeScanCallback#onLeScan} callback.\n*\n* @param serviceUuids Array of services to look for\n* @param callback the callback LE scan results are delivered\n* @return true, if the scan was started successfully\n* @deprecated use {@link BluetoothLeScanner#startScan(List, ScanSettings, ScanCallback)}\n* instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "BluetoothLeScanner#startScan(List, ScanSettings, ScanCallback)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "startScan(List, ScanSettings, ScanCallback)", "fullMethod": "boolean startLeScan(UUID[],LeScanCallback)", "method": "startLeScan(UUID[],LeScanCallback)"}, "getRotationY": {"methodClass": "androidx.core.view.ViewCompat", "methodName": "getRotationY", "replacementComments": "/**\n* @deprecated Use {@link View#getRotationY()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "View#getRotationY()", "methodReturn": "float", "isValid": true, "cleanReplacement": "getRotationY()", "fullMethod": "float getRotationY(View)", "method": "getRotationY(View)"}, "getIndexOnSim": {"methodClass": "android.telephony.SmsMessage", "methodName": "getIndexOnSim", "replacementComments": "/**\n* Returns the record index of the message on the SIM (1-based index).\n* @return the record index of the message on the SIM, or -1 if this\n* SmsMessage was not created from a SIM SMS EF record.\n* @deprecated Use getIndexOnIcc instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getIndexOnIcc", "methodReturn": "int", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "int getIndexOnSim()", "method": "getIndexOnSim()"}, "onSendTextSms": {"methodClass": "android.service.carrier.CarrierMessagingService", "methodName": "onSendTextSms", "replacementComments": "/**\n* Override this method to intercept text SMSs sent from the device.\n* @deprecated Override {@link #onSendTextSms} below instead.\n*\n* @param text the text to send\n* @param subId SMS subscription ID of the SIM\n* @param destAddress phone number of the recipient of the message\n* @param callback result callback. Call with a {@link SendSmsResult}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "onSendTextSms", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void onSendTextSms(String,int,String,ResultCallback<SendSmsResult>)", "method": "onSendTextSms(String,int,String,ResultCallback<SendSmsResult>)"}, "removeOnRoutingChangedListener": {"methodClass": "android.media.AudioRecord", "methodName": "removeOnRoutingChangedListener", "replacementComments": "/**\n* Removes an {@link OnRoutingChangedListener} which has been previously added\n* to receive rerouting notifications.\n* @param listener The previously added {@link OnRoutingChangedListener} interface to remove.\n* @deprecated users should switch to the general purpose\n* {@link AudioRouting.OnRoutingChangedListener} class instead.\n*/\n", "isClassDeprecated": true, "dirtyReplacement": "AudioRouting.OnRoutingChangedListener", "methodReturn": "void", "isValid": true, "cleanReplacement": "AudioRouting.OnRoutingChangedListener", "fullMethod": "void removeOnRoutingChangedListener(OnRoutingChangedListener)", "method": "removeOnRoutingChangedListener(OnRoutingChangedListener)"}, "count": {"methodClass": "com.android.internal.logging.MetricsLogger", "methodName": "count", "replacementComments": "/**\n* Add an integer value to the monotonically increasing counter with the given name.\n* @deprecated use {@link #count(String, int)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "count(String, int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "count(String, int)", "fullMethod": "void count(Context,String,int)", "method": "count(Context,String,int)"}, "isFloat": {"methodClass": "android.database.CursorWindow", "methodName": "isFloat", "replacementComments": "/**\n* Returns true if the field at the specified row and column index\n* has type {@link Cursor#FIELD_TYPE_FLOAT}.\n*\n* @param row The zero-based row index.\n* @param column The zero-based column index.\n* @return True if the field has type {@link Cursor#FIELD_TYPE_FLOAT}.\n* @deprecated Use {@link #getType(int, int)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getType(int, int)", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "getType(int, int)", "fullMethod": "boolean isFloat(int,int)", "method": "isFloat(int,int)"}, "isInLockTaskMode": {"methodClass": "android.app.ActivityManager", "methodName": "isInLockTaskMode", "replacementComments": "/**\n* Return whether currently in lock task mode.  When in this mode\n* no new tasks can be created or switched to.\n*\n* @see Activity#startLockTask()\n*\n* @deprecated Use {@link #getLockTaskModeState} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getLockTaskModeState", "methodReturn": "boolean", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "boolean isInLockTaskMode()", "method": "isInLockTaskMode()"}, "writePackedEnum": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writePackedEnum", "replacementComments": "/**\n* Write a list of packed proto enum type field value.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writePackedEnum(long,int[])", "method": "writePackedEnum(long,int[])"}, "writePackedSFixed64": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writePackedSFixed64", "replacementComments": "/**\n* Write a list of packed proto \"sfixed64\" type field value.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writePackedSFixed64(long,long[])", "method": "writePackedSFixed64(long,long[])"}, "<init>": {"methodClass": "androidx.cursoradapter.widget.SimpleCursorAdapter", "methodName": "<init>", "replacementComments": "/**\n* Constructor the enables auto-requery.\n*\n* @deprecated This option is discouraged, as it results in Cursor queries\n* being performed on the application's UI thread and thus can cause poor\n* responsiveness or even Application Not Responding errors.  As an alternative,\n* use {@link android.app.LoaderManager} with a {@link android.content.CursorLoader}.\n*/\n", "isClassDeprecated": true, "dirtyReplacement": "android.app.LoaderManager", "methodReturn": "void", "isValid": true, "cleanReplacement": "android.app.LoaderManager", "fullMethod": "void <init>(Context,int,Cursor,String[],int[])", "method": "<init>(Context,int,Cursor,String[],int[])"}, "cancelSync": {"methodClass": "android.content.ContentResolver", "methodName": "cancelSync", "replacementComments": "/**\n* Cancel any active or pending syncs that match the Uri. If the uri is null then\n* all syncs will be canceled.\n*\n* @param uri the uri of the provider to sync or null to sync all providers.\n* @deprecated instead use {@link #cancelSync(android.accounts.Account, String)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "cancelSync(android.accounts.Account, String)", "methodReturn": "void", "isValid": true, "cleanReplacement": "cancelSync(android.accounts.Account, String)", "fullMethod": "void cancelSync(Uri)", "method": "cancelSync(Uri)"}, "getRemovedCount": {"methodClass": "androidx.core.view.accessibility.AccessibilityRecordCompat", "methodName": "getRemovedCount", "replacementComments": "/**\n* Gets the number of removed characters.\n*\n* @return The number of removed characters.\n*\n* @deprecated Use {@link AccessibilityRecord#getRemovedCount()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityRecord#getRemovedCount()", "methodReturn": "int", "isValid": true, "cleanReplacement": "AccessibilityRecord#getRemovedCount()", "fullMethod": "int getRemovedCount()", "method": "getRemovedCount()"}, "removeNmeaListener": {"methodClass": "android.location.LocationManager", "methodName": "removeNmeaListener", "replacementComments": "/**\n* Removes an NMEA listener.\n*\n* @param listener a {@link GpsStatus.NmeaListener} object to remove\n* @deprecated use {@link #removeNmeaListener(OnNmeaMessageListener)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "removeNmeaListener(OnNmeaMessageListener)", "methodReturn": "void", "isValid": true, "cleanReplacement": "removeNmeaListener(OnNmeaMessageListener)", "fullMethod": "void removeNmeaListener(NmeaListener)", "method": "removeNmeaListener(NmeaListener)"}, "getTypeName": {"methodClass": "android.net.NetworkInfo", "methodName": "getTypeName", "replacementComments": "/**\n* Return a human-readable name describe the type of the network,\n* for example \"WIFI\" or \"MOBILE\".\n* @return the name of the network type\n* @deprecated Callers should switch to checking {@link NetworkCapabilities#hasTransport}\n* instead with one of the NetworkCapabilities#TRANSPORT_* constants :\n* {@link #getType} and {@link #getTypeName} cannot account for networks using\n* multiple transports. Note that generally apps should not care about transport;\n* {@link NetworkCapabilities#NET_CAPABILITY_NOT_METERED} and\n* {@link NetworkCapabilities#getLinkDownstreamBandwidthKbps} are calls that\n* apps concerned with meteredness or bandwidth should be looking at, as they\n* offer this information with much better accuracy.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "NetworkCapabilities#hasTransport", "methodReturn": "String", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "String getTypeName()", "method": "getTypeName()"}, "getScrollY": {"methodClass": "androidx.core.view.accessibility.AccessibilityRecordCompat", "methodName": "getScrollY", "replacementComments": "/**\n* Gets the scroll offset of the source top edge in pixels.\n*\n* @return The scroll.\n*\n* @deprecated Use {@link AccessibilityRecord#getScrollY()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityRecord#getScrollY()", "methodReturn": "int", "isValid": true, "cleanReplacement": "AccessibilityRecord#getScrollY()", "fullMethod": "int getScrollY()", "method": "getScrollY()"}, "getScrollX": {"methodClass": "androidx.core.view.accessibility.AccessibilityRecordCompat", "methodName": "getScrollX", "replacementComments": "/**\n* Gets the scroll offset of the source left edge in pixels.\n*\n* @return The scroll.\n*\n* @deprecated Use {@link AccessibilityRecord#getScrollX()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityRecord#getScrollX()", "methodReturn": "int", "isValid": true, "cleanReplacement": "AccessibilityRecord#getScrollX()", "fullMethod": "int getScrollX()", "method": "getScrollX()"}, "getDefaultLanguage": {"methodClass": "android.speech.tts.TextToSpeech", "methodName": "getDefaultLanguage", "replacementComments": "/**\n* Returns a Locale instance describing the language currently being used as the default\n* Text-to-speech language.\n*\n* The locale object returned by this method is NOT a valid one. It has identical form to the\n* one in {@link #getLanguage()}. Please refer to {@link #getLanguage()} for more information.\n*\n* @return language, country (if any) and variant (if any) used by the client stored in a\n* Locale instance, or {@code null} on error.\n* @deprecated As of API level 21, use <code>getDefaultVoice().getLocale()</code> ({@link\n* #getDefaultVoice()})\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getDefaultVoice()", "methodReturn": "Locale", "isValid": true, "cleanReplacement": "getDefaultVoice()", "fullMethod": "Locale getDefaultLanguage()", "method": "getDefaultLanguage()"}, "getBackgroundDataSetting": {"methodClass": "android.net.ConnectivityManager", "methodName": "getBackgroundDataSetting", "replacementComments": "/**\n* Returns the value of the setting for background data usage. If false,\n* applications should not use the network if the application is not in the\n* foreground. Developers should respect this setting, and check the value\n* of this before performing any background data operations.\n* <p>\n* All applications that have background services that use the network\n* should listen to {@link #ACTION_BACKGROUND_DATA_SETTING_CHANGED}.\n* <p>\n* @deprecated As of {@link VERSION_CODES#ICE_CREAM_SANDWICH}, availability of\n* background data depends on several combined factors, and this method will\n* always return {@code true}. Instead, when background data is unavailable,\n* {@link #getActiveNetworkInfo()} will now appear disconnected.\n*\n* @return Whether background data usage is allowed.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "VERSION_CODES#ICE_CREAM_SANDWICH", "methodReturn": "boolean", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "boolean getBackgroundDataSetting()", "method": "getBackgroundDataSetting()"}, "setQuickScaleEnabled": {"methodClass": "androidx.core.view.ScaleGestureDetectorCompat", "methodName": "setQuickScaleEnabled", "replacementComments": "/**\n* Sets whether the associated {@link ScaleGestureDetector.OnScaleGestureListener} should\n* receive onScale callbacks when the user performs a doubleTap followed by a swipe. Note that\n* this is enabled by default if the app targets API 19 and newer.\n*\n* @param enabled true to enable quick scaling, false to disable\n*\n* @deprecated Use {@link #setQuickScaleEnabled(ScaleGestureDetector, boolean)} that takes\n* {@link ScaleGestureDetector} instead of {@link Object}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setQuickScaleEnabled(ScaleGestureDetector, boolean)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setQuickScaleEnabled(ScaleGestureDetector, boolean)", "fullMethod": "void setQuickScaleEnabled(Object,boolean)", "method": "setQuickScaleEnabled(Object,boolean)"}, "setOnPageChangeListener": {"methodClass": "androidx.viewpager.widget.ViewPager", "methodName": "setOnPageChangeListener", "replacementComments": "/**\n* Set a listener that will be invoked whenever the page changes or is incrementally\n* scrolled. See {@link OnPageChangeListener}.\n*\n* @param listener Listener to set\n*\n* @deprecated Use {@link #addOnPageChangeListener(OnPageChangeListener)}\n* and {@link #removeOnPageChangeListener(OnPageChangeListener)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "addOnPageChangeListener(OnPageChangeListener)", "methodReturn": "void", "isValid": true, "cleanReplacement": "addOnPageChangeListener(OnPageChangeListener)", "fullMethod": "void setOnPageChangeListener(OnPageChangeListener)", "method": "setOnPageChangeListener(OnPageChangeListener)"}, "getMcc": {"methodClass": "android.telephony.CellIdentityLte", "methodName": "getMcc", "replacementComments": "/**\n* @return 3-digit Mobile Country Code, 0..999, Integer.MAX_VALUE if unknown\n* @deprecated Use {@link #getMccString} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getMccString", "methodReturn": "int", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "int getMcc()", "method": "getMcc()"}, "requestRestore": {"methodClass": "android.app.backup.BackupManager", "methodName": "requestRestore", "replacementComments": "/**\n* @deprecated Applications shouldn't request a restore operation using this method. In Android\n* P and later, this method is a no-op.\n*\n* <p>Restore the calling application from backup. The data will be restored from the\n* current backup dataset if the application has stored data there, or from\n* the dataset used during the last full device setup operation if the current\n* backup dataset has no matching data.  If no backup data exists for this application\n* in either source, a non-zero value is returned.\n*\n* <p>If this method returns zero (meaning success), the OS attempts to retrieve a backed-up\n* dataset from the remote transport, instantiate the application's backup agent, and pass the\n* dataset to the agent's\n* {@link android.app.backup.BackupAgent#onRestore(BackupDataInput, int, android.os.ParcelFileDescriptor) onRestore()}\n* method.\n*\n* <p class=\"caution\">Unlike other restore operations, this method doesn't terminate the\n* application after the restore. The application continues running to receive the\n* {@link RestoreObserver} callbacks on the {@code observer} argument. Full backups use an\n* {@link android.app.Application Application} base class while key-value backups use the\n* application subclass declared in the AndroidManifest.xml {@code <application>} tag.\n*\n* @param observer The {@link RestoreObserver} to receive callbacks during the restore\n* operation. This must not be null.\n*\n* @return Zero on success; nonzero on error.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "android.app.backup.BackupAgent#onRestore(BackupDataInput, int, android.os.ParcelFileDescriptor) onRestore()", "methodReturn": "int", "isValid": true, "cleanReplacement": "onRestore(BackupDataInput, int, android.os.ParcelFileDescriptor) onRestore()", "fullMethod": "int requestRestore(RestoreObserver)", "method": "requestRestore(RestoreObserver)"}, "setRotationX": {"methodClass": "androidx.core.view.ViewCompat", "methodName": "setRotationX", "replacementComments": "/**\n* Sets the degrees that the view is rotated around the horizontal axis through the pivot point.\n* Increasing values result in clockwise rotation from the viewpoint of looking down the\n* x axis.\n*\n* @param value The degrees of X rotation.\n*\n* @deprecated Use {@link View#setRotationX(float)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "View#setRotationX(float)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setRotationX(float)", "fullMethod": "void setRotationX(View,float)", "method": "setRotationX(View,float)"}, "isFullScreen": {"methodClass": "androidx.core.view.accessibility.AccessibilityRecordCompat", "methodName": "isFullScreen", "replacementComments": "/**\n* Gets if the source is taking the entire screen.\n*\n* @return True if the source is full screen, false otherwise.\n*\n* @deprecated Use {@link AccessibilityRecord#isFullScreen()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityRecord#isFullScreen()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "AccessibilityRecord#isFullScreen()", "fullMethod": "boolean isFullScreen()", "method": "isFullScreen()"}, "writeRepeatedFloat": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writeRepeatedFloat", "replacementComments": "/**\n* Write a single repeated proto \"float\" type field value.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writeRepeatedFloat(long,float)", "method": "writeRepeatedFloat(long,float)"}, "onGetInstantAppIntentFilter": {"methodClass": "android.app.InstantAppResolverService", "methodName": "onGetInstantAppIntentFilter", "replacementComments": "/**\n* Called to retrieve intent filters for instant applications from potentially expensive\n* sources.\n*\n* @param digestPrefix The hash prefix of the instant app's domain.\n* @deprecated should implement {@link #onGetInstantAppIntentFilter(Intent, int[], String,\n* InstantAppResolutionCallback)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "onGetInstantAppIntentFilter(Intent, int[], String,  InstantAppResolutionCallback)", "methodReturn": "void", "isValid": true, "cleanReplacement": "onGetInstantAppIntentFilter(Intent, int[], String,  InstantAppResolutionCallback)", "fullMethod": "void onGetInstantAppIntentFilter(int[],String,InstantAppResolutionCallback)", "method": "onGetInstantAppIntentFilter(int[],String,InstantAppResolutionCallback)"}, "encodeCustomImProtocol": {"methodClass": "android.provider.Contacts.ContactMethods", "methodName": "encodeCustomImProtocol", "replacementComments": "/**\n* @deprecated see {@link android.provider.ContactsContract}\n*/\n", "isClassDeprecated": true, "dirtyReplacement": "android.provider.ContactsContract", "methodReturn": "String", "isValid": true, "cleanReplacement": "android.provider.ContactsContract", "fullMethod": "String encodeCustomImProtocol(String)", "method": "encodeCustomImProtocol(String)"}, "setLights": {"methodClass": "android.app.Notification.Builder", "methodName": "setLights", "replacementComments": "/**\n* Set the desired color for the indicator LED on the device, as well as the\n* blink duty cycle (specified in milliseconds).\n*\n* Not all devices will honor all (or even any) of these values.\n*\n* @deprecated use {@link NotificationChannel#enableLights(boolean)} instead.\n* @see Notification#ledARGB\n* @see Notification#ledOnMS\n* @see Notification#ledOffMS\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "NotificationChannel#enableLights(boolean)", "methodReturn": "Builder", "isValid": true, "cleanReplacement": "enableLights(boolean)", "fullMethod": "Builder setLights(int,int,int)", "method": "setLights(int,int,int)"}, "hasCarrierPhaseUncertainty": {"methodClass": "android.location.GnssMeasurement", "methodName": "hasCarrierPhaseUncertainty", "replacementComments": "/**\n* Returns {@code true} if {@link #getCarrierPhaseUncertainty()} is available, {@code false}\n* otherwise.\n*\n* @deprecated use {@link #getAccumulatedDeltaRangeState()} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getAccumulatedDeltaRangeState()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "getAccumulatedDeltaRangeState()", "fullMethod": "boolean hasCarrierPhaseUncertainty()", "method": "hasCarrierPhaseUncertainty()"}, "countStackFrames": {"methodClass": "java.lang.Thread", "methodName": "countStackFrames", "replacementComments": "/**\n* Counts the number of stack frames in this thread. The thread must\n* be suspended.\n*\n* @return     the number of stack frames in this thread.\n* @exception  IllegalThreadStateException  if this thread is not\n* suspended.\n* @deprecated The definition of this call depends on {@link #suspend},\n* which is deprecated.  Further, the results of this call\n* were never well-defined.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "suspend", "methodReturn": "int", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "int countStackFrames()", "method": "countStackFrames()"}, "getPrompt": {"methodClass": "android.service.voice.VoiceInteractionSession.ConfirmationRequest", "methodName": "getPrompt", "replacementComments": "/**\n* Return the prompt informing the user of what will happen, as per\n* {@link android.app.VoiceInteractor.ConfirmationRequest\n* VoiceInteractor.ConfirmationRequest}.\n* @deprecated Prefer {@link #getVoicePrompt()} which allows multiple voice prompts.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getVoicePrompt()", "methodReturn": "CharSequence", "isValid": true, "cleanReplacement": "getVoicePrompt()", "fullMethod": "CharSequence getPrompt()", "method": "getPrompt()"}, "setControlsRowPresenter": {"methodClass": "androidx.leanback.media.PlaybackControlGlue", "methodName": "setControlsRowPresenter", "replacementComments": "/**\n* Sets the controls row Presenter to be managed by the glue layer.\n* @deprecated PlaybackControlGlue supports any PlaybackRowPresenter, use\n* {@link #setPlaybackRowPresenter(PlaybackRowPresenter)}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setPlaybackRowPresenter(PlaybackRowPresenter)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setPlaybackRowPresenter(PlaybackRowPresenter)", "fullMethod": "void setControlsRowPresenter(PlaybackControlsRowPresenter)", "method": "setControlsRowPresenter(PlaybackControlsRowPresenter)"}, "getHeight": {"methodClass": "android.view.Display", "methodName": "getHeight", "replacementComments": "/**\n* @deprecated Use {@link #getSize(Point)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getSize(Point)", "methodReturn": "int", "isValid": true, "cleanReplacement": "getSize(Point)", "fullMethod": "int getHeight()", "method": "getHeight()"}, "onPasswordChanged": {"methodClass": "android.app.admin.DeviceAdminReceiver", "methodName": "onPasswordChanged", "replacementComments": "/**\n* Called after the user has changed their device or profile challenge password, as a result of\n* receiving {@link #ACTION_PASSWORD_CHANGED}.  At this point you\n* can use {@link DevicePolicyManager#getPasswordQuality(android.content.ComponentName)}\n* to retrieve the active password characteristics.\n* @param context The running context as per {@link #onReceive}.\n* @param intent The received intent as per {@link #onReceive}.\n*\n* @deprecated From {@link android.os.Build.VERSION_CODES#O}, use\n* {@link #onPasswordChanged(Context, Intent, UserHandle)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "onPasswordChanged(Context, Intent, UserHandle)", "methodReturn": "void", "isValid": true, "cleanReplacement": "onPasswordChanged(Context, Intent, UserHandle)", "fullMethod": "void onPasswordChanged(Context,Intent)", "method": "onPasswordChanged(Context,Intent)"}, "writeFloat": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writeFloat", "replacementComments": "/**\n* Write a single proto \"float\" type field value.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writeFloat(long,float)", "method": "writeFloat(long,float)"}, "setAlpha": {"methodClass": "androidx.core.view.ViewCompat", "methodName": "setAlpha", "replacementComments": "/**\n* <p>Sets the opacity of the view. This is a value from 0 to 1, where 0 means the view is\n* completely transparent and 1 means the view is completely opaque.</p>\n*\n* <p> Note that setting alpha to a translucent value (0 < alpha < 1) can have significant\n* performance implications, especially for large views. It is best to use the alpha property\n* sparingly and transiently, as in the case of fading animations.</p>\n*\n* @param value The opacity of the view.\n*\n* @deprecated Use {@link View#setAlpha(float)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "View#setAlpha(float)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setAlpha(float)", "fullMethod": "void setAlpha(View,float)", "method": "setAlpha(View,float)"}, "getCodecInfoAt": {"methodClass": "android.media.MediaCodecList", "methodName": "getCodecInfoAt", "replacementComments": "/**\n* Return the {@link MediaCodecInfo} object for the codec at\n* the given {@code index} in the regular list.\n*\n* @deprecated Use {@link #getCodecInfos} instead.\n*\n* @see #REGULAR_CODECS\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getCodecInfos", "methodReturn": "MediaCodecInfo", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "MediaCodecInfo getCodecInfoAt(int)", "method": "getCodecInfoAt(int)"}, "getDrawingCache": {"methodClass": "android.view.View", "methodName": "getDrawingCache", "replacementComments": "/**\n* <p>Returns the bitmap in which this view drawing is cached. The returned bitmap\n* is null when caching is disabled. If caching is enabled and the cache is not ready,\n* this method will create it. Calling {@link #draw(android.graphics.Canvas)} will not\n* draw from the cache when the cache is enabled. To benefit from the cache, you must\n* request the drawing cache by calling this method and draw it on screen if the\n* returned bitmap is not null.</p>\n*\n* <p>Note about auto scaling in compatibility mode: When auto scaling is not enabled,\n* this method will create a bitmap of the same size as this view. Because this bitmap\n* will be drawn scaled by the parent ViewGroup, the result on screen might show\n* scaling artifacts. To avoid such artifacts, you should call this method by setting\n* the auto scaling to true. Doing so, however, will generate a bitmap of a different\n* size than the view. This implies that your application must be able to handle this\n* size.</p>\n*\n* @param autoScale Indicates whether the generated bitmap should be scaled based on\n* the current density of the screen when the application is in compatibility\n* mode.\n*\n* @return A bitmap representing this view or null if cache is disabled.\n*\n* @see #setDrawingCacheEnabled(boolean)\n* @see #isDrawingCacheEnabled()\n* @see #buildDrawingCache(boolean)\n* @see #destroyDrawingCache()\n*\n* @deprecated The view drawing cache was largely made obsolete with the introduction of\n* hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache\n* layers are largely unnecessary and can easily result in a net loss in performance due to the\n* cost of creating and updating the layer. In the rare cases where caching layers are useful,\n* such as for alpha animations, {@link #setLayerType(int, Paint)} handles this with hardware\n* rendering. For software-rendered snapshots of a small part of the View hierarchy or\n* individual Views it is recommended to create a {@link Canvas} from either a {@link Bitmap} or\n* {@link android.graphics.Picture} and call {@link #draw(Canvas)} on the View. However these\n* software-rendered usages are discouraged and have compatibility issues with hardware-only\n* rendering features such as {@link android.graphics.Bitmap.Config#HARDWARE Config.HARDWARE}\n* bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback\n* reports or unit testing the {@link PixelCopy} API is recommended.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setLayerType(int, Paint)", "methodReturn": "Bitmap", "isValid": true, "cleanReplacement": "setLayerType(int, Paint)", "fullMethod": "Bitmap getDrawingCache(boolean)", "method": "getDrawingCache(boolean)"}, "getHorizontalMargin": {"methodClass": "androidx.leanback.widget.BaseGridView", "methodName": "getHorizontalMargin", "replacementComments": "/**\n* Returns the spacing in pixels between two child items horizontally.\n* @deprecated Use {@link #getHorizontalSpacing()}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getHorizontalSpacing()", "methodReturn": "int", "isValid": true, "cleanReplacement": "getHorizontalSpacing()", "fullMethod": "int getHorizontalMargin()", "method": "getHorizontalMargin()"}, "getRootAdapter": {"methodClass": "androidx.car.drawer.CarDrawerActivity", "methodName": "getRootAdapter", "replacementComments": "/**\n* @return Adapter for root content of the Drawer.\n* @deprecated Do not implement this, instead call {@link #getDrawerController}.\n* {@link CarDrawerController#setRootAdapter(CarDrawerAdapter)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getDrawerController", "methodReturn": "CarDrawerAdapter", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "CarDrawerAdapter getRootAdapter()", "method": "getRootAdapter()"}, "iccOpenLogicalChannel": {"methodClass": "com.android.internal.telephony.uicc.UiccCard", "methodName": "iccOpenLogicalChannel", "replacementComments": "/**\n* Exposes {@link CommandsInterface#iccOpenLogicalChannel}\n* @deprecated Please use\n* {@link UiccProfile#iccOpenLogicalChannel(String, int, Message)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "UiccProfile#iccOpenLogicalChannel(String, int, Message)", "methodReturn": "void", "isValid": true, "cleanReplacement": "iccOpenLogicalChannel(String, int, Message)", "fullMethod": "void iccOpenLogicalChannel(String,int,Message)", "method": "iccOpenLogicalChannel(String,int,Message)"}, "findViewHolderForPosition": {"methodClass": "com.android.internal.widget.RecyclerView", "methodName": "findViewHolderForPosition", "replacementComments": "/**\n* @deprecated use {@link #findViewHolderForLayoutPosition(int)} or\n* {@link #findViewHolderForAdapterPosition(int)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "findViewHolderForLayoutPosition(int)", "methodReturn": "ViewHolder", "isValid": true, "cleanReplacement": "findViewHolderForLayoutPosition(int)", "fullMethod": "ViewHolder findViewHolderForPosition(int)", "method": "findViewHolderForPosition(int)"}, "draw": {"methodClass": "androidx.legacy.widget.Space", "methodName": "draw", "replacementComments": "/**\n* Draw nothing.\n*\n* @param canvas an unused parameter.\n*\n* @deprecated Use framework {@link android.widget.Space} class instead.\n*/\n", "isClassDeprecated": true, "dirtyReplacement": "android.widget.Space", "methodReturn": "void", "isValid": true, "cleanReplacement": "android.widget.Space", "fullMethod": "void draw(Canvas)", "method": "draw(Canvas)"}, "getType": {"methodClass": "android.net.NetworkInfo", "methodName": "getType", "replacementComments": "/**\n* Reports the type of network to which the\n* info in this {@code NetworkInfo} pertains.\n* @return one of {@link ConnectivityManager#TYPE_MOBILE}, {@link\n* ConnectivityManager#TYPE_WIFI}, {@link ConnectivityManager#TYPE_WIMAX}, {@link\n* ConnectivityManager#TYPE_ETHERNET},  {@link ConnectivityManager#TYPE_BLUETOOTH}, or other\n* types defined by {@link ConnectivityManager}.\n* @deprecated Callers should switch to checking {@link NetworkCapabilities#hasTransport}\n* instead with one of the NetworkCapabilities#TRANSPORT_* constants :\n* {@link #getType} and {@link #getTypeName} cannot account for networks using\n* multiple transports. Note that generally apps should not care about transport;\n* {@link NetworkCapabilities#NET_CAPABILITY_NOT_METERED} and\n* {@link NetworkCapabilities#getLinkDownstreamBandwidthKbps} are calls that\n* apps concerned with meteredness or bandwidth should be looking at, as they\n* offer this information with much better accuracy.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "NetworkCapabilities#hasTransport", "methodReturn": "int", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "int getType()", "method": "getType()"}, "classLoaderDepth": {"methodClass": "java.lang.SecurityManager", "methodName": "classLoaderDepth", "replacementComments": "/**\n* @deprecated Use {@link #checkPermission} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "checkPermission", "methodReturn": "int", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "int classLoaderDepth()", "method": "classLoaderDepth()"}, "getDrawingCacheBackgroundColor": {"methodClass": "android.view.View", "methodName": "getDrawingCacheBackgroundColor", "replacementComments": "/**\n* @see #setDrawingCacheBackgroundColor(int)\n*\n* @return The background color to used for the drawing cache's bitmap\n*\n* @deprecated The view drawing cache was largely made obsolete with the introduction of\n* hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache\n* layers are largely unnecessary and can easily result in a net loss in performance due to the\n* cost of creating and updating the layer. In the rare cases where caching layers are useful,\n* such as for alpha animations, {@link #setLayerType(int, Paint)} handles this with hardware\n* rendering. For software-rendered snapshots of a small part of the View hierarchy or\n* individual Views it is recommended to create a {@link Canvas} from either a {@link Bitmap} or\n* {@link android.graphics.Picture} and call {@link #draw(Canvas)} on the View. However these\n* software-rendered usages are discouraged and have compatibility issues with hardware-only\n* rendering features such as {@link android.graphics.Bitmap.Config#HARDWARE Config.HARDWARE}\n* bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback\n* reports or unit testing the {@link PixelCopy} API is recommended.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "setLayerType(int, Paint)", "methodReturn": "int", "isValid": true, "cleanReplacement": "setLayerType(int, Paint)", "fullMethod": "int getDrawingCacheBackgroundColor()", "method": "getDrawingCacheBackgroundColor()"}, "parseMonolithicPackage": {"methodClass": "android.content.pm.PackageParser", "methodName": "parseMonolithicPackage", "replacementComments": "/**\n* Parse the given APK file, treating it as as a single monolithic package.\n* <p>\n* Note that this <em>does not</em> perform signature verification; that\n* must be done separately in {@link #collectCertificates(Package, int)}.\n*\n* @deprecated external callers should move to\n* {@link #parsePackage(File, int)}. Eventually this method will\n* be marked private.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "parsePackage(File, int)", "methodReturn": "Package", "isValid": true, "cleanReplacement": "parsePackage(File, int)", "fullMethod": "Package parseMonolithicPackage(File,int)", "method": "parseMonolithicPackage(File,int)"}, "isConnectedOrConnecting": {"methodClass": "android.net.NetworkInfo", "methodName": "isConnectedOrConnecting", "replacementComments": "/**\n* Indicates whether network connectivity exists or is in the process\n* of being established. This is good for applications that need to\n* do anything related to the network other than read or write data.\n* For the latter, call {@link #isConnected()} instead, which guarantees\n* that the network is fully usable.\n* @return {@code true} if network connectivity exists or is in the process\n* of being established, {@code false} otherwise.\n* @deprecated Apps should instead use the\n* {@link android.net.ConnectivityManager.NetworkCallback} API to\n* learn about connectivity changes.\n* {@link ConnectivityManager#registerDefaultNetworkCallback} and\n* {@link ConnectivityManager#registerNetworkCallback}. These will\n* give a more accurate picture of the connectivity state of\n* the device and let apps react more easily and quickly to changes.\n*/\n", "isClassDeprecated": true, "dirtyReplacement": "android.net.ConnectivityManager.NetworkCallback", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "android.net.ConnectivityManager.NetworkCallback", "fullMethod": "boolean isConnectedOrConnecting()", "method": "isConnectedOrConnecting()"}, "setPivotX": {"methodClass": "androidx.core.view.ViewCompat", "methodName": "setPivotX", "replacementComments": "/**\n* Sets the x location of the point around which the view is\n* {@link #setRotation(View, float) rotated} and {@link #setScaleX(View, float) scaled}.\n* By default, the pivot point is centered on the object.\n* Setting this property disables this behavior and causes the view to use only the\n* explicitly set pivotX and pivotY values.\n*\n* @param value The x location of the pivot point.\n*\n* @deprecated Use {@link View#setPivotX(float)} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "View#setPivotX(float)", "methodReturn": "void", "isValid": true, "cleanReplacement": "setPivotX(float)", "fullMethod": "void setPivotX(View,float)", "method": "setPivotX(View,float)"}, "onMeasure": {"methodClass": "androidx.legacy.widget.Space", "methodName": "onMeasure", "replacementComments": "/**\n* @deprecated Use framework {@link android.widget.Space} class instead.\n*/\n", "isClassDeprecated": true, "dirtyReplacement": "android.widget.Space", "methodReturn": "void", "isValid": true, "cleanReplacement": "android.widget.Space", "fullMethod": "void onMeasure(int,int)", "method": "onMeasure(int,int)"}, "drag": {"methodClass": "android.test.TouchUtils", "methodName": "drag", "replacementComments": "/**\n* Simulate touching a specific location and dragging to a new location.\n*\n* @param test The test case that is being run\n* @param fromX X coordinate of the initial touch, in screen coordinates\n* @param toX Xcoordinate of the drag destination, in screen coordinates\n* @param fromY X coordinate of the initial touch, in screen coordinates\n* @param toY Y coordinate of the drag destination, in screen coordinates\n* @param stepCount How many move steps to include in the drag\n*\n* @deprecated {@link android.test.ActivityInstrumentationTestCase} is deprecated in favor of\n* {@link android.test.ActivityInstrumentationTestCase2}, which provides more options for\n* configuring the Activity under test\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "android.test.ActivityInstrumentationTestCase2", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void drag(ActivityInstrumentationTestCase,float,float,float,float,int)", "method": "drag(ActivityInstrumentationTestCase,float,float,float,float,int)"}, "authenticate": {"methodClass": "android.hardware.fingerprint.FingerprintManager", "methodName": "authenticate", "replacementComments": "/**\n* Request authentication of a crypto object. This call warms up the fingerprint hardware\n* and starts scanning for a fingerprint. It terminates when\n* {@link AuthenticationCallback#onAuthenticationError(int, CharSequence)} or\n* {@link AuthenticationCallback#onAuthenticationSucceeded(AuthenticationResult)} is called, at\n* which point the object is no longer valid. The operation can be canceled by using the\n* provided cancel object.\n*\n* @param crypto object associated with the call or null if none required.\n* @param cancel an object that can be used to cancel authentication\n* @param flags optional flags; should be 0\n* @param callback an object to receive authentication events\n* @param handler an optional handler to handle callback events\n*\n* @throws IllegalArgumentException if the crypto operation is not supported or is not backed\n* by <a href=\"{@docRoot}training/articles/keystore.html\">Android Keystore\n* facility</a>.\n* @throws IllegalStateException if the crypto primitive is not initialized.\n* @deprecated See {@link BiometricPrompt#authenticate(CancellationSignal, Executor,\n* BiometricPrompt.AuthenticationCallback)} and {@link BiometricPrompt#authenticate(\n* BiometricPrompt.CryptoObject, CancellationSignal, Executor,\n* BiometricPrompt.AuthenticationCallback)}\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "BiometricPrompt#authenticate(CancellationSignal, Executor,  BiometricPrompt.AuthenticationCallback)", "methodReturn": "void", "isValid": true, "cleanReplacement": "authenticate(CancellationSignal, Executor,  BiometricPrompt.AuthenticationCallback)", "fullMethod": "void authenticate(CryptoObject,CancellationSignal,int,AuthenticationCallback,Handler)", "method": "authenticate(CryptoObject,CancellationSignal,int,AuthenticationCallback,Handler)"}, "hideSoftInputFromInputMethod": {"methodClass": "android.view.inputmethod.InputMethodManager", "methodName": "hideSoftInputFromInputMethod", "replacementComments": "/**\n* Close/hide the input method's soft input area, so the user no longer\n* sees it or can interact with it.  This can only be called\n* from the currently active input method, as validated by the given token.\n*\n* @param token Supplies the identifying token given to an input method\n* when it was started, which allows it to perform this operation on\n* itself.\n* @param flags Provides additional operating flags.  Currently may be\n* 0 or have the {@link #HIDE_IMPLICIT_ONLY},\n* {@link #HIDE_NOT_ALWAYS} bit set.\n* @deprecated Use {@link InputMethodService#requestHideSelf(int)} instead. This method was\n* intended for IME developers who should be accessing APIs through the service. APIs in this\n* class are intended for app developers interacting with the IME.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "InputMethodService#requestHideSelf(int)", "methodReturn": "void", "isValid": true, "cleanReplacement": "requestHideSelf(int)", "fullMethod": "void hideSoftInputFromInputMethod(IBinder,int)", "method": "hideSoftInputFromInputMethod(IBinder,int)"}, "writeRepeatedSFixed64": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writeRepeatedSFixed64", "replacementComments": "/**\n* Write a single repeated proto \"sfixed64\" type field value.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writeRepeatedSFixed64(long,long)", "method": "writeRepeatedSFixed64(long,long)"}, "getProcessDefaultNetwork": {"methodClass": "android.net.ConnectivityManager", "methodName": "getProcessDefaultNetwork", "replacementComments": "/**\n* Returns the {@link Network} currently bound to this process via\n* {@link #bindProcessToNetwork}, or {@code null} if no {@link Network} is explicitly bound.\n*\n* @return {@code Network} to which this process is bound, or {@code null}.\n* @deprecated Using this function can lead to other functions throwing\n* {@link IllegalStateException}.  Use {@link #getBoundNetworkForProcess} instead.\n* {@code getBoundNetworkForProcess} is a direct replacement.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getBoundNetworkForProcess", "methodReturn": "Network", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "Network getProcessDefaultNetwork()", "method": "getProcessDefaultNetwork()"}, "logrb": {"methodClass": "java.util.logging.Logger", "methodName": "logrb", "replacementComments": "/**\n* Log a message, specifying source class, method, and resource bundle name,\n* with an array of object arguments.\n* <p>\n* If the logger is currently enabled for the given message\n* level then a corresponding LogRecord is created and forwarded\n* to all the registered output Handler objects.\n* <p>\n* The msg string is localized using the named resource bundle.  If the\n* resource bundle name is null, or an empty String or invalid\n* then the msg string is not localized.\n* <p>\n* @param   level   One of the message level identifiers, e.g., SEVERE\n* @param   sourceClass    name of class that issued the logging request\n* @param   sourceMethod   name of method that issued the logging request\n* @param   bundleName     name of resource bundle to localize msg,\n* can be null.\n* @param   msg     The string message (or a key in the message catalog)\n* @param   params  Array of parameters to the message\n* @deprecated Use {@link #logrb(java.util.logging.Level, java.lang.String,\n* java.lang.String, java.util.ResourceBundle, java.lang.String,\n* java.lang.Object...)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "logrb(java.util.logging.Level, java.lang.String,  java.lang.String, java.util.ResourceBundle, java.lang.String,  java.lang.Object...)", "methodReturn": "void", "isValid": true, "cleanReplacement": "logrb(java.util.logging.Level, java.lang.String,  java.lang.String, java.util.ResourceBundle, java.lang.String,  java.lang.Object...)", "fullMethod": "void logrb(Level,String,String,String,String,Object[])", "method": "logrb(Level,String,String,String,String,Object[])"}, "writeUInt32": {"methodClass": "android.util.proto.ProtoOutputStream", "methodName": "writeUInt32", "replacementComments": "/**\n* Write a single proto \"uint32\" type field value.\n*\n* @deprecated Use #write instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "write", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void writeUInt32(long,int)", "method": "writeUInt32(long,int)"}, "copyFileOrThrow": {"methodClass": "android.os.FileUtils", "methodName": "copyFileOrThrow", "replacementComments": "/**\n* @deprecated use {@link #copy(File, File)} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "copy(File, File)", "methodReturn": "void", "isValid": true, "cleanReplacement": "copy(File, File)", "fullMethod": "void copyFileOrThrow(File,File)", "method": "copyFileOrThrow(File,File)"}, "noteAlarmFinish": {"methodClass": "android.app.ActivityManagerNative", "methodName": "noteAlarmFinish", "replacementComments": "/**\n* @deprecated use ActivityManager.noteAlarmFinish instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "ActivityManager.noteAlarmFinish", "methodReturn": "void", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "void noteAlarmFinish(PendingIntent,int,String)", "method": "noteAlarmFinish(PendingIntent,int,String)"}, "getSource": {"methodClass": "androidx.core.view.accessibility.AccessibilityRecordCompat", "methodName": "getSource", "replacementComments": "/**\n* Gets the {@link android.view.accessibility.AccessibilityNodeInfo} of\n* the event source.\n* <p>\n* <strong>Note:</strong> It is a client responsibility to recycle the\n* received info by calling\n* {@link android.view.accessibility.AccessibilityNodeInfo#recycle()\n* AccessibilityNodeInfo#recycle()} to avoid creating of multiple instances.\n* </p>\n*\n* @return The info of the source.\n*\n* @deprecated Use {@link AccessibilityRecord#getSource()} directly.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "AccessibilityRecord#getSource()", "methodReturn": "AccessibilityNodeInfoCompat", "isValid": true, "cleanReplacement": "AccessibilityRecord#getSource()", "fullMethod": "AccessibilityNodeInfoCompat getSource()", "method": "getSource()"}, "onSaveInstanceState": {"methodClass": "androidx.legacy.app.FragmentTabHost", "methodName": "onSaveInstanceState", "replacementComments": "/**\n* @deprecated Use {@link androidx.fragment.app.FragmentTabHost} instead.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "androidx.fragment.app.FragmentTabHost", "methodReturn": "Parcelable", "isValid": false, "cleanReplacement": "Malformed Replacement", "fullMethod": "Parcelable onSaveInstanceState()", "method": "onSaveInstanceState()"}, "sendStickyBroadcastAsUser": {"methodClass": "android.content.Context", "methodName": "sendStickyBroadcastAsUser", "replacementComments": "/**\n* <p>Version of {@link #sendStickyBroadcast(Intent)} that allows you to specify the\n* user the broadcast will be sent to.  This is not available to applications\n* that are not pre-installed on the system image.\n*\n* @deprecated Sticky broadcasts should not be used.  They provide no security (anyone\n* can access them), no protection (anyone can modify them), and many other problems.\n* The recommended pattern is to use a non-sticky broadcast to report that <em>something</em>\n* has changed, with another mechanism for apps to retrieve the current value whenever\n* desired.\n*\n* @param intent The Intent to broadcast; all receivers matching this\n* Intent will receive the broadcast, and the Intent will be held to\n* be re-broadcast to future receivers.\n* @param user UserHandle to send the intent to.\n*\n* @see #sendBroadcast(Intent)\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "sendBroadcast(Intent)", "methodReturn": "void", "isValid": true, "cleanReplacement": "sendBroadcast(Intent)", "fullMethod": "void sendStickyBroadcastAsUser(Intent,UserHandle)", "method": "sendStickyBroadcastAsUser(Intent,UserHandle)"}, "getConsiderGoneChildrenWhenMeasuring": {"methodClass": "android.widget.FrameLayout", "methodName": "getConsiderGoneChildrenWhenMeasuring", "replacementComments": "/**\n* Determines whether all children, or just those in the VISIBLE or\n* INVISIBLE state, are considered when measuring.\n*\n* @return Whether all children are considered when measuring.\n*\n* @deprecated This method is deprecated in favor of\n* {@link #getMeasureAllChildren() getMeasureAllChildren()}, which was\n* renamed for consistency with\n* {@link #setMeasureAllChildren(boolean) setMeasureAllChildren()}.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getMeasureAllChildren() getMeasureAllChildren()", "methodReturn": "boolean", "isValid": true, "cleanReplacement": "getMeasureAllChildren() getMeasureAllChildren()", "fullMethod": "boolean getConsiderGoneChildrenWhenMeasuring()", "method": "getConsiderGoneChildrenWhenMeasuring()"}, "getHandle": {"methodClass": "android.opengl.EGLObjectHandle", "methodName": "getHandle", "replacementComments": "/**\n* @deprecated Use {@link #getNativeHandle()} instead. Handles on\n* 64 bit platforms will be wider than java ints.\n*/\n", "isClassDeprecated": false, "dirtyReplacement": "getNativeHandle()", "methodReturn": "int", "isValid": true, "cleanReplacement": "getNativeHandle()", "fullMethod": "int getHandle()", "method": "getHandle()"}}